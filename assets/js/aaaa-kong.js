 !function(T){ !function(a){"object"==typeof exports?module.exports=a():"function"==typeof define&&define.amd?define(a):"undefined"!=typeof window?window.decomp=a():"undefined"!=typeof global?global.decomp=a():"undefined"!=typeof self&&(self.decomp=a())}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);throw new Error("Cannot find module '"+g+"'")}var j=c[g]={exports:{}};b[g][0].call(j.exports,function(a){var c=b[g][1][a];return e(c?c:a)},j,j.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b){function c(){}var d=a("./Scalar");b.exports=c,c.lineInt=function(a,b,c){c=c||0;var e,f,g,h,i,j,k,l=[0,0];return e=a[1][1]-a[0][1],f=a[0][0]-a[1][0],g=e*a[0][0]+f*a[0][1],h=b[1][1]-b[0][1],i=b[0][0]-b[1][0],j=h*b[0][0]+i*b[0][1],k=e*i-h*f,d.eq(k,0,c)||(l[0]=(i*g-f*j)/k,l[1]=(e*j-h*g)/k),l},c.segmentsIntersect=function(a,b,c,d){var e=b[0]-a[0],f=b[1]-a[1],g=d[0]-c[0],h=d[1]-c[1];if(0==g*f-h*e)return!1;var i=(e*(c[1]-a[1])+f*(a[0]-c[0]))/(g*f-h*e),j=(g*(a[1]-c[1])+h*(c[0]-a[0]))/(h*e-g*f);return i>=0&&1>=i&&j>=0&&1>=j}},{"./Scalar":4}],2:[function(a,b){function c(){}b.exports=c,c.area=function(a,b,c){return(b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])},c.left=function(a,b,d){return c.area(a,b,d)>0},c.leftOn=function(a,b,d){return c.area(a,b,d)>=0},c.right=function(a,b,d){return c.area(a,b,d)<0},c.rightOn=function(a,b,d){return c.area(a,b,d)<=0};var d=[],e=[];c.collinear=function(a,b,f,g){if(g){var h=d,i=e;h[0]=b[0]-a[0],h[1]=b[1]-a[1],i[0]=f[0]-b[0],i[1]=f[1]-b[1];var j=h[0]*i[0]+h[1]*i[1],k=Math.sqrt(h[0]*h[0]+h[1]*h[1]),l=Math.sqrt(i[0]*i[0]+i[1]*i[1]),m=Math.acos(j/(k*l));return g>m}return 0==c.area(a,b,f)},c.sqdist=function(a,b){var c=b[0]-a[0],d=b[1]-a[1];return c*c+d*d}},{}],3:[function(a,b){function c(){this.vertices=[]}function d(a,b,c,d,e){e=e||0;var f=b[1]-a[1],h=a[0]-b[0],i=f*a[0]+h*a[1],j=d[1]-c[1],k=c[0]-d[0],l=j*c[0]+k*c[1],m=f*k-j*h;return g.eq(m,0,e)?[0,0]:[(k*i-h*l)/m,(f*l-j*i)/m]}var e=a("./Line"),f=a("./Point"),g=a("./Scalar");b.exports=c,c.prototype.at=function(a){var b=this.vertices,c=b.length;return b[0>a?a%c+c:a%c]},c.prototype.first=function(){return this.vertices[0]},c.prototype.last=function(){return this.vertices[this.vertices.length-1]},c.prototype.clear=function(){this.vertices.length=0},c.prototype.append=function(a,b,c){if("undefined"==typeof b)throw new Error("From is not given!");if("undefined"==typeof c)throw new Error("To is not given!");if(b>c-1)throw new Error("lol1");if(c>a.vertices.length)throw new Error("lol2");if(0>b)throw new Error("lol3");for(var d=b;c>d;d++)this.vertices.push(a.vertices[d])},c.prototype.makeCCW=function(){for(var a=0,b=this.vertices,c=1;c<this.vertices.length;++c)(b[c][1]<b[a][1]||b[c][1]==b[a][1]&&b[c][0]>b[a][0])&&(a=c);f.left(this.at(a-1),this.at(a),this.at(a+1))||this.reverse()},c.prototype.reverse=function(){for(var a=[],b=0,c=this.vertices.length;b!==c;b++)a.push(this.vertices.pop());this.vertices=a},c.prototype.isReflex=function(a){return f.right(this.at(a-1),this.at(a),this.at(a+1))};var h=[],i=[];c.prototype.canSee=function(a,b){var c,d,g=h,j=i;if(f.leftOn(this.at(a+1),this.at(a),this.at(b))&&f.rightOn(this.at(a-1),this.at(a),this.at(b)))return!1;d=f.sqdist(this.at(a),this.at(b));for(var k=0;k!==this.vertices.length;++k)if((k+1)%this.vertices.length!==a&&k!==a&&f.leftOn(this.at(a),this.at(b),this.at(k+1))&&f.rightOn(this.at(a),this.at(b),this.at(k))&&(g[0]=this.at(a),g[1]=this.at(b),j[0]=this.at(k),j[1]=this.at(k+1),c=e.lineInt(g,j),f.sqdist(this.at(a),c)<d))return!1;return!0},c.prototype.copy=function(a,b,d){var e=d||new c;if(e.clear(),b>a)for(var f=a;b>=f;f++)e.vertices.push(this.vertices[f]);else{for(var f=0;b>=f;f++)e.vertices.push(this.vertices[f]);for(var f=a;f<this.vertices.length;f++)e.vertices.push(this.vertices[f])}return e},c.prototype.getCutEdges=function(){for(var a=[],b=[],d=[],e=new c,f=Number.MAX_VALUE,g=0;g<this.vertices.length;++g)if(this.isReflex(g))for(var h=0;h<this.vertices.length;++h)if(this.canSee(g,h)){b=this.copy(g,h,e).getCutEdges(),d=this.copy(h,g,e).getCutEdges();for(var i=0;i<d.length;i++)b.push(d[i]);b.length<f&&(a=b,f=b.length,a.push([this.at(g),this.at(h)]))}return a},c.prototype.decomp=function(){var a=this.getCutEdges();return a.length>0?this.slice(a):[this]},c.prototype.slice=function(a){if(0==a.length)return[this];if(a instanceof Array&&a.length&&a[0]instanceof Array&&2==a[0].length&&a[0][0]instanceof Array){for(var b=[this],c=0;c<a.length;c++)for(var d=a[c],e=0;e<b.length;e++){var f=b[e],g=f.slice(d);if(g){b.splice(e,1),b.push(g[0],g[1]);break}}return b}var d=a,c=this.vertices.indexOf(d[0]),e=this.vertices.indexOf(d[1]);return-1!=c&&-1!=e?[this.copy(c,e),this.copy(e,c)]:!1},c.prototype.isSimple=function(){for(var a=this.vertices,b=0;b<a.length-1;b++)for(var c=0;b-1>c;c++)if(e.segmentsIntersect(a[b],a[b+1],a[c],a[c+1]))return!1;for(var b=1;b<a.length-2;b++)if(e.segmentsIntersect(a[0],a[a.length-1],a[b],a[b+1]))return!1;return!0},c.prototype.quickDecomp=function(a,b,e,g,h,i){h=h||100,i=i||0,g=g||25,a="undefined"!=typeof a?a:[],b=b||[],e=e||[];var j=[0,0],k=[0,0],l=[0,0],m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=new c,u=new c,v=this,w=this.vertices;if(w.length<3)return a;if(i++,i>h)return console.warn("quickDecomp: max level ("+h+") reached."),a;for(var x=0;x<this.vertices.length;++x)if(v.isReflex(x)){b.push(v.vertices[x]),m=n=Number.MAX_VALUE;for(var y=0;y<this.vertices.length;++y)f.left(v.at(x-1),v.at(x),v.at(y))&&f.rightOn(v.at(x-1),v.at(x),v.at(y-1))&&(l=d(v.at(x-1),v.at(x),v.at(y),v.at(y-1)),f.right(v.at(x+1),v.at(x),l)&&(o=f.sqdist(v.vertices[x],l),n>o&&(n=o,k=l,r=y))),f.left(v.at(x+1),v.at(x),v.at(y+1))&&f.rightOn(v.at(x+1),v.at(x),v.at(y))&&(l=d(v.at(x+1),v.at(x),v.at(y),v.at(y+1)),f.left(v.at(x-1),v.at(x),l)&&(o=f.sqdist(v.vertices[x],l),m>o&&(m=o,j=l,q=y)));if(r==(q+1)%this.vertices.length)l[0]=(k[0]+j[0])/2,l[1]=(k[1]+j[1])/2,e.push(l),q>x?(t.append(v,x,q+1),t.vertices.push(l),u.vertices.push(l),0!=r&&u.append(v,r,v.vertices.length),u.append(v,0,x+1)):(0!=x&&t.append(v,x,v.vertices.length),t.append(v,0,q+1),t.vertices.push(l),u.vertices.push(l),u.append(v,r,x+1));else{if(r>q&&(q+=this.vertices.length),p=Number.MAX_VALUE,r>q)return a;for(var y=r;q>=y;++y)f.leftOn(v.at(x-1),v.at(x),v.at(y))&&f.rightOn(v.at(x+1),v.at(x),v.at(y))&&(o=f.sqdist(v.at(x),v.at(y)),p>o&&(p=o,s=y%this.vertices.length));s>x?(t.append(v,x,s+1),0!=s&&u.append(v,s,w.length),u.append(v,0,x+1)):(0!=x&&t.append(v,x,w.length),t.append(v,0,s+1),u.append(v,s,x+1))}return t.vertices.length<u.vertices.length?(t.quickDecomp(a,b,e,g,h,i),u.quickDecomp(a,b,e,g,h,i)):(u.quickDecomp(a,b,e,g,h,i),t.quickDecomp(a,b,e,g,h,i)),a}return a.push(this),a},c.prototype.removeCollinearPoints=function(a){for(var b=0,c=this.vertices.length-1;this.vertices.length>3&&c>=0;--c)f.collinear(this.at(c-1),this.at(c),this.at(c+1),a)&&(this.vertices.splice(c%this.vertices.length,1),c--,b++);return b}},{"./Line":1,"./Point":2,"./Scalar":4}],4:[function(a,b){function c(){}b.exports=c,c.eq=function(a,b,c){return c=c||0,Math.abs(a-b)<c}},{}],5:[function(a,b){b.exports={Polygon:a("./Polygon"),Point:a("./Point")}},{"./Point":2,"./Polygon":3}]},{},[5])(5)});
(function(){"SVGPathSeg"in window||(window.SVGPathSeg=function(a,b,c){this.pathSegType=a;this.pathSegTypeAsLetter=b;this._owningPathSegList=c},window.SVGPathSeg.prototype.classname="SVGPathSeg",window.SVGPathSeg.PATHSEG_UNKNOWN=0,window.SVGPathSeg.PATHSEG_CLOSEPATH=1,window.SVGPathSeg.PATHSEG_MOVETO_ABS=2,window.SVGPathSeg.PATHSEG_MOVETO_REL=3,window.SVGPathSeg.PATHSEG_LINETO_ABS=4,window.SVGPathSeg.PATHSEG_LINETO_REL=5,window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS=6,window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL=
7,window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS=8,window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL=9,window.SVGPathSeg.PATHSEG_ARC_ABS=10,window.SVGPathSeg.PATHSEG_ARC_REL=11,window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS=12,window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL=13,window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS=14,window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL=15,window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS=16,window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL=17,window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS=
18,window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL=19,window.SVGPathSeg.prototype._segmentChanged=function(){this._owningPathSegList&&this._owningPathSegList.segmentChanged(this)},window.SVGPathSegClosePath=function(a){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_CLOSEPATH,"z",a)},window.SVGPathSegClosePath.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegClosePath.prototype.toString=function(){return"[object SVGPathSegClosePath]"},window.SVGPathSegClosePath.prototype._asPathString=
function(){return this.pathSegTypeAsLetter},window.SVGPathSegClosePath.prototype.clone=function(){return new window.SVGPathSegClosePath(void 0)},window.SVGPathSegMovetoAbs=function(a,b,c){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_MOVETO_ABS,"M",a);this._x=b;this._y=c},window.SVGPathSegMovetoAbs.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegMovetoAbs.prototype.toString=function(){return"[object SVGPathSegMovetoAbs]"},window.SVGPathSegMovetoAbs.prototype._asPathString=
function(){return this.pathSegTypeAsLetter+" "+this._x+" "+this._y},window.SVGPathSegMovetoAbs.prototype.clone=function(){return new window.SVGPathSegMovetoAbs(void 0,this._x,this._y)},Object.defineProperty(window.SVGPathSegMovetoAbs.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegMovetoAbs.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),
window.SVGPathSegMovetoRel=function(a,b,c){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_MOVETO_REL,"m",a);this._x=b;this._y=c},window.SVGPathSegMovetoRel.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegMovetoRel.prototype.toString=function(){return"[object SVGPathSegMovetoRel]"},window.SVGPathSegMovetoRel.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._x+" "+this._y},window.SVGPathSegMovetoRel.prototype.clone=function(){return new window.SVGPathSegMovetoRel(void 0,
this._x,this._y)},Object.defineProperty(window.SVGPathSegMovetoRel.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegMovetoRel.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegLinetoAbs=function(a,b,c){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_LINETO_ABS,"L",a);this._x=b;this._y=c},window.SVGPathSegLinetoAbs.prototype=
Object.create(window.SVGPathSeg.prototype),window.SVGPathSegLinetoAbs.prototype.toString=function(){return"[object SVGPathSegLinetoAbs]"},window.SVGPathSegLinetoAbs.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._x+" "+this._y},window.SVGPathSegLinetoAbs.prototype.clone=function(){return new window.SVGPathSegLinetoAbs(void 0,this._x,this._y)},Object.defineProperty(window.SVGPathSegLinetoAbs.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},
enumerable:!0}),Object.defineProperty(window.SVGPathSegLinetoAbs.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegLinetoRel=function(a,b,c){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_LINETO_REL,"l",a);this._x=b;this._y=c},window.SVGPathSegLinetoRel.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegLinetoRel.prototype.toString=function(){return"[object SVGPathSegLinetoRel]"},window.SVGPathSegLinetoRel.prototype._asPathString=
function(){return this.pathSegTypeAsLetter+" "+this._x+" "+this._y},window.SVGPathSegLinetoRel.prototype.clone=function(){return new window.SVGPathSegLinetoRel(void 0,this._x,this._y)},Object.defineProperty(window.SVGPathSegLinetoRel.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegLinetoRel.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),
window.SVGPathSegCurvetoCubicAbs=function(a,b,c,d,e,h,l){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS,"C",a);this._x=b;this._y=c;this._x1=d;this._y1=e;this._x2=h;this._y2=l},window.SVGPathSegCurvetoCubicAbs.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegCurvetoCubicAbs.prototype.toString=function(){return"[object SVGPathSegCurvetoCubicAbs]"},window.SVGPathSegCurvetoCubicAbs.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._x1+
" "+this._y1+" "+this._x2+" "+this._y2+" "+this._x+" "+this._y},window.SVGPathSegCurvetoCubicAbs.prototype.clone=function(){return new window.SVGPathSegCurvetoCubicAbs(void 0,this._x,this._y,this._x1,this._y1,this._x2,this._y2)},Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype,"y",{get:function(){return this._y},set:function(a){this._y=
a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype,"x1",{get:function(){return this._x1},set:function(a){this._x1=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype,"y1",{get:function(){return this._y1},set:function(a){this._y1=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype,"x2",{get:function(){return this._x2},set:function(a){this._x2=
a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype,"y2",{get:function(){return this._y2},set:function(a){this._y2=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegCurvetoCubicRel=function(a,b,c,d,e,h,l){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL,"c",a);this._x=b;this._y=c;this._x1=d;this._y1=e;this._x2=h;this._y2=l},window.SVGPathSegCurvetoCubicRel.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegCurvetoCubicRel.prototype.toString=
function(){return"[object SVGPathSegCurvetoCubicRel]"},window.SVGPathSegCurvetoCubicRel.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._x1+" "+this._y1+" "+this._x2+" "+this._y2+" "+this._x+" "+this._y},window.SVGPathSegCurvetoCubicRel.prototype.clone=function(){return new window.SVGPathSegCurvetoCubicRel(void 0,this._x,this._y,this._x1,this._y1,this._x2,this._y2)},Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype,"x",{get:function(){return this._x},set:function(a){this._x=
a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype,"x1",{get:function(){return this._x1},set:function(a){this._x1=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype,"y1",{get:function(){return this._y1},set:function(a){this._y1=
a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype,"x2",{get:function(){return this._x2},set:function(a){this._x2=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype,"y2",{get:function(){return this._y2},set:function(a){this._y2=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegCurvetoQuadraticAbs=function(a,b,c,d,e){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS,
"Q",a);this._x=b;this._y=c;this._x1=d;this._y1=e},window.SVGPathSegCurvetoQuadraticAbs.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegCurvetoQuadraticAbs.prototype.toString=function(){return"[object SVGPathSegCurvetoQuadraticAbs]"},window.SVGPathSegCurvetoQuadraticAbs.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._x1+" "+this._y1+" "+this._x+" "+this._y},window.SVGPathSegCurvetoQuadraticAbs.prototype.clone=function(){return new window.SVGPathSegCurvetoQuadraticAbs(void 0,
this._x,this._y,this._x1,this._y1)},Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype,"x1",{get:function(){return this._x1},set:function(a){this._x1=
a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype,"y1",{get:function(){return this._y1},set:function(a){this._y1=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegCurvetoQuadraticRel=function(a,b,c,d,e){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL,"q",a);this._x=b;this._y=c;this._x1=d;this._y1=e},window.SVGPathSegCurvetoQuadraticRel.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegCurvetoQuadraticRel.prototype.toString=
function(){return"[object SVGPathSegCurvetoQuadraticRel]"},window.SVGPathSegCurvetoQuadraticRel.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._x1+" "+this._y1+" "+this._x+" "+this._y},window.SVGPathSegCurvetoQuadraticRel.prototype.clone=function(){return new window.SVGPathSegCurvetoQuadraticRel(void 0,this._x,this._y,this._x1,this._y1)},Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},
enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype,"x1",{get:function(){return this._x1},set:function(a){this._x1=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype,"y1",{get:function(){return this._y1},set:function(a){this._y1=a;this._segmentChanged()},
enumerable:!0}),window.SVGPathSegArcAbs=function(a,b,c,d,e,h,l,k){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_ARC_ABS,"A",a);this._x=b;this._y=c;this._r1=d;this._r2=e;this._angle=h;this._largeArcFlag=l;this._sweepFlag=k},window.SVGPathSegArcAbs.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegArcAbs.prototype.toString=function(){return"[object SVGPathSegArcAbs]"},window.SVGPathSegArcAbs.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._r1+
" "+this._r2+" "+this._angle+" "+(this._largeArcFlag?"1":"0")+" "+(this._sweepFlag?"1":"0")+" "+this._x+" "+this._y},window.SVGPathSegArcAbs.prototype.clone=function(){return new window.SVGPathSegArcAbs(void 0,this._x,this._y,this._r1,this._r2,this._angle,this._largeArcFlag,this._sweepFlag)},Object.defineProperty(window.SVGPathSegArcAbs.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegArcAbs.prototype,
"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegArcAbs.prototype,"r1",{get:function(){return this._r1},set:function(a){this._r1=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegArcAbs.prototype,"r2",{get:function(){return this._r2},set:function(a){this._r2=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegArcAbs.prototype,"angle",{get:function(){return this._angle},
set:function(a){this._angle=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegArcAbs.prototype,"largeArcFlag",{get:function(){return this._largeArcFlag},set:function(a){this._largeArcFlag=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegArcAbs.prototype,"sweepFlag",{get:function(){return this._sweepFlag},set:function(a){this._sweepFlag=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegArcRel=function(a,b,c,d,e,h,l,k){window.SVGPathSeg.call(this,
window.SVGPathSeg.PATHSEG_ARC_REL,"a",a);this._x=b;this._y=c;this._r1=d;this._r2=e;this._angle=h;this._largeArcFlag=l;this._sweepFlag=k},window.SVGPathSegArcRel.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegArcRel.prototype.toString=function(){return"[object SVGPathSegArcRel]"},window.SVGPathSegArcRel.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._r1+" "+this._r2+" "+this._angle+" "+(this._largeArcFlag?"1":"0")+" "+(this._sweepFlag?"1":"0")+" "+
this._x+" "+this._y},window.SVGPathSegArcRel.prototype.clone=function(){return new window.SVGPathSegArcRel(void 0,this._x,this._y,this._r1,this._r2,this._angle,this._largeArcFlag,this._sweepFlag)},Object.defineProperty(window.SVGPathSegArcRel.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegArcRel.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),
Object.defineProperty(window.SVGPathSegArcRel.prototype,"r1",{get:function(){return this._r1},set:function(a){this._r1=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegArcRel.prototype,"r2",{get:function(){return this._r2},set:function(a){this._r2=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegArcRel.prototype,"angle",{get:function(){return this._angle},set:function(a){this._angle=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegArcRel.prototype,
"largeArcFlag",{get:function(){return this._largeArcFlag},set:function(a){this._largeArcFlag=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegArcRel.prototype,"sweepFlag",{get:function(){return this._sweepFlag},set:function(a){this._sweepFlag=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegLinetoHorizontalAbs=function(a,b){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS,"H",a);this._x=b},window.SVGPathSegLinetoHorizontalAbs.prototype=
Object.create(window.SVGPathSeg.prototype),window.SVGPathSegLinetoHorizontalAbs.prototype.toString=function(){return"[object SVGPathSegLinetoHorizontalAbs]"},window.SVGPathSegLinetoHorizontalAbs.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._x},window.SVGPathSegLinetoHorizontalAbs.prototype.clone=function(){return new window.SVGPathSegLinetoHorizontalAbs(void 0,this._x)},Object.defineProperty(window.SVGPathSegLinetoHorizontalAbs.prototype,"x",{get:function(){return this._x},
set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegLinetoHorizontalRel=function(a,b){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL,"h",a);this._x=b},window.SVGPathSegLinetoHorizontalRel.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegLinetoHorizontalRel.prototype.toString=function(){return"[object SVGPathSegLinetoHorizontalRel]"},window.SVGPathSegLinetoHorizontalRel.prototype._asPathString=function(){return this.pathSegTypeAsLetter+
" "+this._x},window.SVGPathSegLinetoHorizontalRel.prototype.clone=function(){return new window.SVGPathSegLinetoHorizontalRel(void 0,this._x)},Object.defineProperty(window.SVGPathSegLinetoHorizontalRel.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegLinetoVerticalAbs=function(a,b){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS,"V",a);this._y=b},window.SVGPathSegLinetoVerticalAbs.prototype=Object.create(window.SVGPathSeg.prototype),
window.SVGPathSegLinetoVerticalAbs.prototype.toString=function(){return"[object SVGPathSegLinetoVerticalAbs]"},window.SVGPathSegLinetoVerticalAbs.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._y},window.SVGPathSegLinetoVerticalAbs.prototype.clone=function(){return new window.SVGPathSegLinetoVerticalAbs(void 0,this._y)},Object.defineProperty(window.SVGPathSegLinetoVerticalAbs.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},
enumerable:!0}),window.SVGPathSegLinetoVerticalRel=function(a,b){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL,"v",a);this._y=b},window.SVGPathSegLinetoVerticalRel.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegLinetoVerticalRel.prototype.toString=function(){return"[object SVGPathSegLinetoVerticalRel]"},window.SVGPathSegLinetoVerticalRel.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._y},window.SVGPathSegLinetoVerticalRel.prototype.clone=
function(){return new window.SVGPathSegLinetoVerticalRel(void 0,this._y)},Object.defineProperty(window.SVGPathSegLinetoVerticalRel.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegCurvetoCubicSmoothAbs=function(a,b,c,d,e){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS,"S",a);this._x=b;this._y=c;this._x2=d;this._y2=e},window.SVGPathSegCurvetoCubicSmoothAbs.prototype=Object.create(window.SVGPathSeg.prototype),
window.SVGPathSegCurvetoCubicSmoothAbs.prototype.toString=function(){return"[object SVGPathSegCurvetoCubicSmoothAbs]"},window.SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._x2+" "+this._y2+" "+this._x+" "+this._y},window.SVGPathSegCurvetoCubicSmoothAbs.prototype.clone=function(){return new window.SVGPathSegCurvetoCubicSmoothAbs(void 0,this._x,this._y,this._x2,this._y2)},Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype,
"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype,"x2",{get:function(){return this._x2},set:function(a){this._x2=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype,
"y2",{get:function(){return this._y2},set:function(a){this._y2=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegCurvetoCubicSmoothRel=function(a,b,c,d,e){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL,"s",a);this._x=b;this._y=c;this._x2=d;this._y2=e},window.SVGPathSegCurvetoCubicSmoothRel.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegCurvetoCubicSmoothRel.prototype.toString=function(){return"[object SVGPathSegCurvetoCubicSmoothRel]"},
window.SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._x2+" "+this._y2+" "+this._x+" "+this._y},window.SVGPathSegCurvetoCubicSmoothRel.prototype.clone=function(){return new window.SVGPathSegCurvetoCubicSmoothRel(void 0,this._x,this._y,this._x2,this._y2)},Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype,
"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype,"x2",{get:function(){return this._x2},set:function(a){this._x2=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype,"y2",{get:function(){return this._y2},set:function(a){this._y2=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegCurvetoQuadraticSmoothAbs=function(a,
b,c){window.SVGPathSeg.call(this,window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS,"T",a);this._x=b;this._y=c},window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString=function(){return"[object SVGPathSegCurvetoQuadraticSmoothAbs]"},window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._x+" "+this._y},window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone=
function(){return new window.SVGPathSegCurvetoQuadraticSmoothAbs(void 0,this._x,this._y)},Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),window.SVGPathSegCurvetoQuadraticSmoothRel=function(a,b,c){window.SVGPathSeg.call(this,
window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL,"t",a);this._x=b;this._y=c},window.SVGPathSegCurvetoQuadraticSmoothRel.prototype=Object.create(window.SVGPathSeg.prototype),window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString=function(){return"[object SVGPathSegCurvetoQuadraticSmoothRel]"},window.SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString=function(){return this.pathSegTypeAsLetter+" "+this._x+" "+this._y},window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone=function(){return new window.SVGPathSegCurvetoQuadraticSmoothRel(void 0,
this._x,this._y)},Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype,"x",{get:function(){return this._x},set:function(a){this._x=a;this._segmentChanged()},enumerable:!0}),Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype,"y",{get:function(){return this._y},set:function(a){this._y=a;this._segmentChanged()},enumerable:!0}),window.SVGPathElement.prototype.createSVGPathSegClosePath=function(){return new window.SVGPathSegClosePath(void 0)},window.SVGPathElement.prototype.createSVGPathSegMovetoAbs=
function(a,b){return new window.SVGPathSegMovetoAbs(void 0,a,b)},window.SVGPathElement.prototype.createSVGPathSegMovetoRel=function(a,b){return new window.SVGPathSegMovetoRel(void 0,a,b)},window.SVGPathElement.prototype.createSVGPathSegLinetoAbs=function(a,b){return new window.SVGPathSegLinetoAbs(void 0,a,b)},window.SVGPathElement.prototype.createSVGPathSegLinetoRel=function(a,b){return new window.SVGPathSegLinetoRel(void 0,a,b)},window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs=function(a,
b,c,d,e,h){return new window.SVGPathSegCurvetoCubicAbs(void 0,a,b,c,d,e,h)},window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel=function(a,b,c,d,e,h){return new window.SVGPathSegCurvetoCubicRel(void 0,a,b,c,d,e,h)},window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs=function(a,b,c,d){return new window.SVGPathSegCurvetoQuadraticAbs(void 0,a,b,c,d)},window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel=function(a,b,c,d){return new window.SVGPathSegCurvetoQuadraticRel(void 0,
a,b,c,d)},window.SVGPathElement.prototype.createSVGPathSegArcAbs=function(a,b,c,d,e,h,l){return new window.SVGPathSegArcAbs(void 0,a,b,c,d,e,h,l)},window.SVGPathElement.prototype.createSVGPathSegArcRel=function(a,b,c,d,e,h,l){return new window.SVGPathSegArcRel(void 0,a,b,c,d,e,h,l)},window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs=function(a){return new window.SVGPathSegLinetoHorizontalAbs(void 0,a)},window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel=function(a){return new window.SVGPathSegLinetoHorizontalRel(void 0,
a)},window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs=function(a){return new window.SVGPathSegLinetoVerticalAbs(void 0,a)},window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel=function(a){return new window.SVGPathSegLinetoVerticalRel(void 0,a)},window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs=function(a,b,c,d){return new window.SVGPathSegCurvetoCubicSmoothAbs(void 0,a,b,c,d)},window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel=function(a,
b,c,d){return new window.SVGPathSegCurvetoCubicSmoothRel(void 0,a,b,c,d)},window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs=function(a,b){return new window.SVGPathSegCurvetoQuadraticSmoothAbs(void 0,a,b)},window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel=function(a,b){return new window.SVGPathSegCurvetoQuadraticSmoothRel(void 0,a,b)},"getPathSegAtLength"in window.SVGPathElement.prototype||(window.SVGPathElement.prototype.getPathSegAtLength=function(a){if(void 0===
a||!isFinite(a))throw"Invalid arguments.";var b=document.createElementNS("http://www.w3.org/2000/svg","path");b.setAttribute("d",this.getAttribute("d"));var c=b.pathSegList.numberOfItems-1;if(0>=c)return 0;do{b.pathSegList.removeItem(c);if(a>b.getTotalLength())break;c--}while(0<c);return c}));"SVGPathSegList"in window||(window.SVGPathSegList=function(a){this._pathElement=a;this._list=this._parsePath(this._pathElement.getAttribute("d"));this._mutationObserverConfig={attributes:!0,attributeFilter:["d"]};
this._pathElementMutationObserver=new MutationObserver(this._updateListFromPathMutations.bind(this));this._pathElementMutationObserver.observe(this._pathElement,this._mutationObserverConfig)},window.SVGPathSegList.prototype.classname="SVGPathSegList",Object.defineProperty(window.SVGPathSegList.prototype,"numberOfItems",{get:function(){this._checkPathSynchronizedToList();return this._list.length},enumerable:!0}),Object.defineProperty(window.SVGPathElement.prototype,"pathSegList",{get:function(){this._pathSegList||
(this._pathSegList=new window.SVGPathSegList(this));return this._pathSegList},enumerable:!0}),Object.defineProperty(window.SVGPathElement.prototype,"normalizedPathSegList",{get:function(){return this.pathSegList},enumerable:!0}),Object.defineProperty(window.SVGPathElement.prototype,"animatedPathSegList",{get:function(){return this.pathSegList},enumerable:!0}),Object.defineProperty(window.SVGPathElement.prototype,"animatedNormalizedPathSegList",{get:function(){return this.pathSegList},enumerable:!0}),
window.SVGPathSegList.prototype._checkPathSynchronizedToList=function(){this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords())},window.SVGPathSegList.prototype._updateListFromPathMutations=function(a){if(this._pathElement){var b=!1;a.forEach(function(a){"d"==a.attributeName&&(b=!0)});b&&(this._list=this._parsePath(this._pathElement.getAttribute("d")))}},window.SVGPathSegList.prototype._writeListToPath=function(){this._pathElementMutationObserver.disconnect();this._pathElement.setAttribute("d",
window.SVGPathSegList._pathSegArrayAsString(this._list));this._pathElementMutationObserver.observe(this._pathElement,this._mutationObserverConfig)},window.SVGPathSegList.prototype.segmentChanged=function(a){this._writeListToPath()},window.SVGPathSegList.prototype.clear=function(){this._checkPathSynchronizedToList();this._list.forEach(function(a){a._owningPathSegList=null});this._list=[];this._writeListToPath()},window.SVGPathSegList.prototype.initialize=function(a){this._checkPathSynchronizedToList();
this._list=[a];a._owningPathSegList=this;this._writeListToPath();return a},window.SVGPathSegList.prototype._checkValidIndex=function(a){if(isNaN(a)||0>a||a>=this.numberOfItems)throw"INDEX_SIZE_ERR";},window.SVGPathSegList.prototype.getItem=function(a){this._checkPathSynchronizedToList();this._checkValidIndex(a);return this._list[a]},window.SVGPathSegList.prototype.insertItemBefore=function(a,b){this._checkPathSynchronizedToList();b>this.numberOfItems&&(b=this.numberOfItems);a._owningPathSegList&&
(a=a.clone());this._list.splice(b,0,a);a._owningPathSegList=this;this._writeListToPath();return a},window.SVGPathSegList.prototype.replaceItem=function(a,b){this._checkPathSynchronizedToList();a._owningPathSegList&&(a=a.clone());this._checkValidIndex(b);this._list[b]=a;a._owningPathSegList=this;this._writeListToPath();return a},window.SVGPathSegList.prototype.removeItem=function(a){this._checkPathSynchronizedToList();this._checkValidIndex(a);var b=this._list[a];this._list.splice(a,1);this._writeListToPath();
return b},window.SVGPathSegList.prototype.appendItem=function(a){this._checkPathSynchronizedToList();a._owningPathSegList&&(a=a.clone());this._list.push(a);a._owningPathSegList=this;this._writeListToPath();return a},window.SVGPathSegList._pathSegArrayAsString=function(a){var b="",c=!0;a.forEach(function(a){c?(c=!1,b+=a._asPathString()):b+=" "+a._asPathString()});return b},window.SVGPathSegList.prototype._parsePath=function(a){if(!a||0==a.length)return[];var b=this,c=function(){this.pathSegList=[]};
c.prototype.appendSegment=function(a){this.pathSegList.push(a)};var d=function(a){this._string=a;this._currentIndex=0;this._endIndex=this._string.length;this._previousCommand=window.SVGPathSeg.PATHSEG_UNKNOWN;this._skipOptionalSpaces()};d.prototype._isCurrentSpace=function(){var a=this._string[this._currentIndex];return" ">=a&&(" "==a||"\n"==a||"\t"==a||"\r"==a||"\f"==a)};d.prototype._skipOptionalSpaces=function(){for(;this._currentIndex<this._endIndex&&this._isCurrentSpace();)this._currentIndex++;
return this._currentIndex<this._endIndex};d.prototype._skipOptionalSpacesOrDelimiter=function(){if(this._currentIndex<this._endIndex&&!this._isCurrentSpace()&&","!=this._string.charAt(this._currentIndex))return!1;this._skipOptionalSpaces()&&this._currentIndex<this._endIndex&&","==this._string.charAt(this._currentIndex)&&(this._currentIndex++,this._skipOptionalSpaces());return this._currentIndex<this._endIndex};d.prototype.hasMoreData=function(){return this._currentIndex<this._endIndex};d.prototype.peekSegmentType=
function(){return this._pathSegTypeFromChar(this._string[this._currentIndex])};d.prototype._pathSegTypeFromChar=function(a){switch(a){case "Z":case "z":return window.SVGPathSeg.PATHSEG_CLOSEPATH;case "M":return window.SVGPathSeg.PATHSEG_MOVETO_ABS;case "m":return window.SVGPathSeg.PATHSEG_MOVETO_REL;case "L":return window.SVGPathSeg.PATHSEG_LINETO_ABS;case "l":return window.SVGPathSeg.PATHSEG_LINETO_REL;case "C":return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;case "c":return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;
case "Q":return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;case "q":return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;case "A":return window.SVGPathSeg.PATHSEG_ARC_ABS;case "a":return window.SVGPathSeg.PATHSEG_ARC_REL;case "H":return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;case "h":return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;case "V":return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;case "v":return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;case "S":return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;
case "s":return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;case "T":return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;case "t":return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;default:return window.SVGPathSeg.PATHSEG_UNKNOWN}};d.prototype._nextCommandHelper=function(a,b){return("+"==a||"-"==a||"."==a||"0"<=a&&"9">=a)&&b!=window.SVGPathSeg.PATHSEG_CLOSEPATH?b==window.SVGPathSeg.PATHSEG_MOVETO_ABS?window.SVGPathSeg.PATHSEG_LINETO_ABS:b==window.SVGPathSeg.PATHSEG_MOVETO_REL?
window.SVGPathSeg.PATHSEG_LINETO_REL:b:window.SVGPathSeg.PATHSEG_UNKNOWN};d.prototype.initialCommandIsMoveTo=function(){if(!this.hasMoreData())return!0;var a=this.peekSegmentType();return a==window.SVGPathSeg.PATHSEG_MOVETO_ABS||a==window.SVGPathSeg.PATHSEG_MOVETO_REL};d.prototype._parseNumber=function(){var a=0,b=0,c=1,d=0,f=1,g=1,m=this._currentIndex;this._skipOptionalSpaces();this._currentIndex<this._endIndex&&"+"==this._string.charAt(this._currentIndex)?this._currentIndex++:this._currentIndex<
this._endIndex&&"-"==this._string.charAt(this._currentIndex)&&(this._currentIndex++,f=-1);if(!(this._currentIndex==this._endIndex||("0">this._string.charAt(this._currentIndex)||"9"<this._string.charAt(this._currentIndex))&&"."!=this._string.charAt(this._currentIndex))){for(var n=this._currentIndex;this._currentIndex<this._endIndex&&"0"<=this._string.charAt(this._currentIndex)&&"9">=this._string.charAt(this._currentIndex);)this._currentIndex++;if(this._currentIndex!=n)for(var p=this._currentIndex-
1,q=1;p>=n;)b+=q*(this._string.charAt(p--)-0),q*=10;if(this._currentIndex<this._endIndex&&"."==this._string.charAt(this._currentIndex)){this._currentIndex++;if(this._currentIndex>=this._endIndex||"0">this._string.charAt(this._currentIndex)||"9"<this._string.charAt(this._currentIndex))return;for(;this._currentIndex<this._endIndex&&"0"<=this._string.charAt(this._currentIndex)&&"9">=this._string.charAt(this._currentIndex);)c*=10,d+=(this._string.charAt(this._currentIndex)-0)/c,this._currentIndex+=1}if(this._currentIndex!=
m&&this._currentIndex+1<this._endIndex&&("e"==this._string.charAt(this._currentIndex)||"E"==this._string.charAt(this._currentIndex))&&"x"!=this._string.charAt(this._currentIndex+1)&&"m"!=this._string.charAt(this._currentIndex+1)){this._currentIndex++;"+"==this._string.charAt(this._currentIndex)?this._currentIndex++:"-"==this._string.charAt(this._currentIndex)&&(this._currentIndex++,g=-1);if(this._currentIndex>=this._endIndex||"0">this._string.charAt(this._currentIndex)||"9"<this._string.charAt(this._currentIndex))return;
for(;this._currentIndex<this._endIndex&&"0"<=this._string.charAt(this._currentIndex)&&"9">=this._string.charAt(this._currentIndex);)a*=10,a+=this._string.charAt(this._currentIndex)-0,this._currentIndex++}b=(b+d)*f;a&&(b*=Math.pow(10,g*a));if(m!=this._currentIndex)return this._skipOptionalSpacesOrDelimiter(),b}};d.prototype._parseArcFlag=function(){if(!(this._currentIndex>=this._endIndex)){var a=this._string.charAt(this._currentIndex++);if("0"==a)a=!1;else if("1"==a)a=!0;else return;this._skipOptionalSpacesOrDelimiter();
return a}};d.prototype.parseSegment=function(){var a=this._string[this._currentIndex];var c=this._pathSegTypeFromChar(a);if(c==window.SVGPathSeg.PATHSEG_UNKNOWN){if(this._previousCommand==window.SVGPathSeg.PATHSEG_UNKNOWN)return null;c=this._nextCommandHelper(a,this._previousCommand);if(c==window.SVGPathSeg.PATHSEG_UNKNOWN)return null}else this._currentIndex++;this._previousCommand=c;switch(c){case window.SVGPathSeg.PATHSEG_MOVETO_REL:return new window.SVGPathSegMovetoRel(b,this._parseNumber(),this._parseNumber());
case window.SVGPathSeg.PATHSEG_MOVETO_ABS:return new window.SVGPathSegMovetoAbs(b,this._parseNumber(),this._parseNumber());case window.SVGPathSeg.PATHSEG_LINETO_REL:return new window.SVGPathSegLinetoRel(b,this._parseNumber(),this._parseNumber());case window.SVGPathSeg.PATHSEG_LINETO_ABS:return new window.SVGPathSegLinetoAbs(b,this._parseNumber(),this._parseNumber());case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:return new window.SVGPathSegLinetoHorizontalRel(b,this._parseNumber());case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:return new window.SVGPathSegLinetoHorizontalAbs(b,
this._parseNumber());case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:return new window.SVGPathSegLinetoVerticalRel(b,this._parseNumber());case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:return new window.SVGPathSegLinetoVerticalAbs(b,this._parseNumber());case window.SVGPathSeg.PATHSEG_CLOSEPATH:return this._skipOptionalSpaces(),new window.SVGPathSegClosePath(b);case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:a=this._parseNumber();c=this._parseNumber();var d=this._parseNumber();var k=this._parseNumber();
var f=this._parseNumber();var g=this._parseNumber();return new window.SVGPathSegCurvetoCubicRel(b,f,g,a,c,d,k);case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:return a=this._parseNumber(),c=this._parseNumber(),d=this._parseNumber(),k=this._parseNumber(),f=this._parseNumber(),g=this._parseNumber(),new window.SVGPathSegCurvetoCubicAbs(b,f,g,a,c,d,k);case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:return d=this._parseNumber(),k=this._parseNumber(),f=this._parseNumber(),g=this._parseNumber(),
new window.SVGPathSegCurvetoCubicSmoothRel(b,f,g,d,k);case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:return d=this._parseNumber(),k=this._parseNumber(),f=this._parseNumber(),g=this._parseNumber(),new window.SVGPathSegCurvetoCubicSmoothAbs(b,f,g,d,k);case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:return a=this._parseNumber(),c=this._parseNumber(),f=this._parseNumber(),g=this._parseNumber(),new window.SVGPathSegCurvetoQuadraticRel(b,f,g,a,c);case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:return a=
this._parseNumber(),c=this._parseNumber(),f=this._parseNumber(),g=this._parseNumber(),new window.SVGPathSegCurvetoQuadraticAbs(b,f,g,a,c);case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:return new window.SVGPathSegCurvetoQuadraticSmoothRel(b,this._parseNumber(),this._parseNumber());case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:return new window.SVGPathSegCurvetoQuadraticSmoothAbs(b,this._parseNumber(),this._parseNumber());case window.SVGPathSeg.PATHSEG_ARC_REL:a=this._parseNumber();
c=this._parseNumber();d=this._parseNumber();k=this._parseArcFlag();var m=this._parseArcFlag();f=this._parseNumber();g=this._parseNumber();return new window.SVGPathSegArcRel(b,f,g,a,c,d,k,m);case window.SVGPathSeg.PATHSEG_ARC_ABS:return a=this._parseNumber(),c=this._parseNumber(),d=this._parseNumber(),k=this._parseArcFlag(),m=this._parseArcFlag(),f=this._parseNumber(),g=this._parseNumber(),new window.SVGPathSegArcAbs(b,f,g,a,c,d,k,m);default:throw"Unknown path seg type.";}};c=new c;a=new d(a);if(!a.initialCommandIsMoveTo())return[];
for(;a.hasMoreData();){d=a.parseSegment();if(!d)return[];c.appendSegment(d)}return c.pathSegList})})();
(function(N){"object"===typeof exports&&"undefined"!==typeof module?module.exports=N():"function"===typeof define&&define.amd?define([],N):("undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:this).Matter=N()})(function(){return function a(l,n,w){function k(c,e){if(!n[c]){if(!l[c]){var d="function"==typeof require&&require;if(!e&&d)return d(c,!0);if(f)return f(c,!0);d=Error("Cannot find module '"+c+"'");throw d.code="MODULE_NOT_FOUND",d;}d=n[c]={exports:{}};
l[c][0].call(d.exports,function(d){var h=l[c][1][d];return k(h?h:d)},d,d.exports,a,l,n,w)}return n[c].exports}for(var f="function"==typeof require&&require,e=0;e<w.length;e++)k(w[e]);return k}({1:[function(l,n,w){var a={};n.exports=a;var k=l("../geometry/Vertices"),f=l("../geometry/Vector"),e=l("../core/Sleeping");l("../render/Render");var c=l("../core/Common"),u=l("../geometry/Bounds"),d=l("../geometry/Axes");(function(){a._inertiaScale=4;a._nextCollidingGroupId=1;a._nextNonCollidingGroupId=-1;a._nextCategory=
1;a.create=function(h){var b={id:c.nextId(),type:"body",label:"Body",parts:[],angle:0,vertices:k.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),position:{x:0,y:0},force:{x:0,y:0},torque:0,positionImpulse:{x:0,y:0},constraintImpulse:{x:0,y:0,angle:0},totalContacts:0,speed:0,angularSpeed:0,velocity:{x:0,y:0},angularVelocity:0,isSensor:!1,isStatic:!1,isSleeping:!1,motion:0,sleepThreshold:60,density:.001,restitution:0,friction:.1,frictionStatic:.5,frictionAir:.01,collisionFilter:{category:1,mask:4294967295,
group:0},slop:.05,timeScale:1,render:{visible:!0,opacity:1,sprite:{xScale:1,yScale:1,xOffset:0,yOffset:0},lineWidth:1.5}};b=c.extend(b,h);a.set(b,{bounds:b.bounds||u.create(b.vertices),positionPrev:b.positionPrev||f.clone(b.position),anglePrev:b.anglePrev||b.angle,vertices:b.vertices,parts:b.parts||[b],isStatic:b.isStatic,isSleeping:b.isSleeping,parent:b.parent||b});k.rotate(b.vertices,b.angle,b.position);d.rotate(b.axes,b.angle);u.update(b.bounds,b.vertices,b.velocity);a.set(b,{axes:h.axes||b.axes,
area:h.area||b.area,mass:h.mass||b.mass,inertia:h.inertia||b.inertia});h=b.isStatic?"#eeeeee":c.choose(["#556270","#4ECDC4","#C7F464","#FF6B6B","#C44D58"]);var g=c.shadeColor(h,-20);b.render.fillStyle=b.render.fillStyle||h;b.render.strokeStyle=b.render.strokeStyle||g;b.render.sprite.xOffset+=-(b.bounds.min.x-b.position.x)/(b.bounds.max.x-b.bounds.min.x);b.render.sprite.yOffset+=-(b.bounds.min.y-b.position.y)/(b.bounds.max.y-b.bounds.min.y);return b};a.nextGroup=function(b){return b?a._nextNonCollidingGroupId--:
a._nextCollidingGroupId++};a.nextCategory=function(){a._nextCategory<<=1;return a._nextCategory};a.set=function(b,d,g){if("string"===typeof d){var h=d;d={};d[h]=g}for(h in d)if(g=d[h],d.hasOwnProperty(h))switch(h){case "isStatic":a.setStatic(b,g);break;case "isSleeping":e.set(b,g);break;case "mass":a.setMass(b,g);break;case "density":a.setDensity(b,g);break;case "inertia":a.setInertia(b,g);break;case "vertices":a.setVertices(b,g);break;case "position":a.setPosition(b,g);break;case "angle":a.setAngle(b,
g);break;case "velocity":a.setVelocity(b,g);break;case "angularVelocity":a.setAngularVelocity(b,g);break;case "parts":a.setParts(b,g);break;default:b[h]=g}};a.setStatic=function(b,d){for(var g=0;g<b.parts.length;g++){var h=b.parts[g];if(h.isStatic=d)h.restitution=0,h.friction=1,h.mass=h.inertia=h.density=Infinity,h.inverseMass=h.inverseInertia=0,h.positionPrev.x=h.position.x,h.positionPrev.y=h.position.y,h.anglePrev=h.angle,h.angularVelocity=0,h.speed=0,h.angularSpeed=0,h.motion=0}};a.setMass=function(b,
d){b.mass=d;b.inverseMass=1/b.mass;b.density=b.mass/b.area};a.setDensity=function(b,d){a.setMass(b,d*b.area);b.density=d};a.setInertia=function(b,d){b.inertia=d;b.inverseInertia=1/b.inertia};a.setVertices=function(b,c){b.vertices=c[0].body===b?c:k.create(c,b);b.axes=d.fromVertices(b.vertices);b.area=k.area(b.vertices);a.setMass(b,b.density*b.area);var g=k.centre(b.vertices);k.translate(b.vertices,g,-1);a.setInertia(b,a._inertiaScale*k.inertia(b.vertices,b.mass));k.translate(b.vertices,b.position);
u.update(b.bounds,b.vertices,b.velocity)};a.setParts=function(d,c,g){var h;c=c.slice(0);d.parts.length=0;d.parts.push(d);d.parent=d;for(h=0;h<c.length;h++){var m=c[h];m!==d&&(m.parent=d,d.parts.push(m))}if(1!==d.parts.length){if("undefined"!==typeof g?g:1){g=[];for(h=0;h<c.length;h++)g=g.concat(c[h].vertices);k.clockwiseSort(g);c=k.hull(g);h=k.centre(c);a.setVertices(d,c);k.translate(d.vertices,h)}c=b(d);d.area=c.area;d.parent=d;d.position.x=c.centre.x;d.position.y=c.centre.y;d.positionPrev.x=c.centre.x;
d.positionPrev.y=c.centre.y;a.setMass(d,c.mass);a.setInertia(d,c.inertia);a.setPosition(d,c.centre)}};a.setPosition=function(b,d){var g=f.sub(d,b.position);b.positionPrev.x+=g.x;b.positionPrev.y+=g.y;for(var h=0;h<b.parts.length;h++){var m=b.parts[h];m.position.x+=g.x;m.position.y+=g.y;k.translate(m.vertices,g);u.update(m.bounds,m.vertices,b.velocity)}};a.setAngle=function(b,c){var g=c-b.angle;b.anglePrev+=g;for(var h=0;h<b.parts.length;h++){var m=b.parts[h];m.angle+=g;k.rotate(m.vertices,g,b.position);
d.rotate(m.axes,g);u.update(m.bounds,m.vertices,b.velocity);0<h&&f.rotateAbout(m.position,g,b.position,m.position)}};a.setVelocity=function(b,d){b.positionPrev.x=b.position.x-d.x;b.positionPrev.y=b.position.y-d.y;b.velocity.x=d.x;b.velocity.y=d.y;b.speed=f.magnitude(b.velocity)};a.setAngularVelocity=function(b,d){b.anglePrev=b.angle-d;b.angularVelocity=d;b.angularSpeed=Math.abs(b.angularVelocity)};a.translate=function(b,d){a.setPosition(b,f.add(b.position,d))};a.rotate=function(b,d){a.setAngle(b,
b.angle+d)};a.scale=function(h,c,g,r){for(r=0;r<h.parts.length;r++){var m=h.parts[r];k.scale(m.vertices,c,g,h.position);m.axes=d.fromVertices(m.vertices);h.isStatic||(m.area=k.area(m.vertices),a.setMass(m,h.density*m.area),k.translate(m.vertices,{x:-m.position.x,y:-m.position.y}),a.setInertia(m,k.inertia(m.vertices,m.mass)),k.translate(m.vertices,{x:m.position.x,y:m.position.y}));u.update(m.bounds,m.vertices,h.velocity)}h.circleRadius&&(h.circleRadius=c===g?h.circleRadius*c:null);h.isStatic||(c=b(h),
h.area=c.area,a.setMass(h,c.mass),a.setInertia(h,c.inertia))};a.update=function(b,c,g,a){if(!b.src){c=Math.pow(c*g*b.timeScale,2);g=1-b.frictionAir*g*b.timeScale;var m=b.position.y-b.positionPrev.y;b.velocity.x=(b.position.x-b.positionPrev.x)*g*a+b.force.x/b.mass*c;b.velocity.y=m*g*a+b.force.y/b.mass*c;b.positionPrev.x=b.position.x;b.positionPrev.y=b.position.y;b.position.x+=b.velocity.x;b.position.y+=b.velocity.y;b.angularVelocity=(b.angle-b.anglePrev)*g*a+b.torque/b.inertia*c;b.anglePrev=b.angle;
b.angle+=b.angularVelocity;b.speed=f.magnitude(b.velocity);b.angularSpeed=Math.abs(b.angularVelocity)}for(a=0;a<b.parts.length;a++)c=b.parts[a],k.translate(c.vertices,b.velocity),0<a&&(c.position.x+=b.velocity.x,c.position.y+=b.velocity.y),0!==b.angularVelocity&&(k.rotate(c.vertices,b.angularVelocity,b.position),d.rotate(c.axes,b.angularVelocity),0<a&&f.rotateAbout(c.position,b.angularVelocity,b.position,c.position)),u.update(c.bounds,c.vertices,b.velocity)};a.applyForce=function(b,d,g){b.force.x+=
g.x;b.force.y+=g.y;b.torque+=(d.x-b.position.x)*g.y-(d.y-b.position.y)*g.x};var b=function(b){for(var d={mass:0,area:0,inertia:0,centre:{x:0,y:0}},g=1===b.parts.length?0:1;g<b.parts.length;g++){var c=b.parts[g];d.mass+=c.mass;d.area+=c.area;d.inertia+=c.inertia;d.centre=f.add(d.centre,f.mult(c.position,Infinity!==c.mass?c.mass:1))}d.centre=f.div(d.centre,Infinity!==d.mass?d.mass:b.parts.length);return d}})()},{"../core/Common":14,"../core/Sleeping":20,"../geometry/Axes":23,"../geometry/Bounds":24,
"../geometry/Vector":26,"../geometry/Vertices":27,"../render/Render":29}],2:[function(l,n,w){var a={};n.exports=a;var k=l("../core/Events"),f=l("../core/Common"),e=l("./Body");(function(){a.create=function(c){return f.extend({id:f.nextId(),type:"composite",parent:null,isModified:!1,bodies:[],constraints:[],composites:[],label:"Composite"},c)};a.setModified=function(c,e,d,b){c.isModified=e;d&&c.parent&&a.setModified(c.parent,e,d,b);if(b)for(var h=0;h<c.composites.length;h++)a.setModified(c.composites[h],
e,d,b)};a.add=function(c,e){var d=[].concat(e);k.trigger(c,"beforeAdd",{object:e});for(var b=0;b<d.length;b++){var h=d[b];switch(h.type){case "body":if(h.parent!==h){f.log("Composite.add: skipped adding a compound body part (you must add its parent instead)","warn");break}a.addBody(c,h);break;case "constraint":a.addConstraint(c,h);break;case "composite":a.addComposite(c,h);break;case "mouseConstraint":a.addConstraint(c,h.constraint)}}k.trigger(c,"afterAdd",{object:e});return c};a.remove=function(c,
e,d){var b=[].concat(e);k.trigger(c,"beforeRemove",{object:e});for(var h=0;h<b.length;h++){var f=b[h];switch(f.type){case "body":a.removeBody(c,f,d);break;case "constraint":a.removeConstraint(c,f,d);break;case "composite":a.removeComposite(c,f,d);break;case "mouseConstraint":a.removeConstraint(c,f.constraint)}}k.trigger(c,"afterRemove",{object:e});return c};a.addComposite=function(c,e){c.composites.push(e);e.parent=c;a.setModified(c,!0,!0,!1);return c};a.removeComposite=function(c,e,d){var b=f.indexOf(c.composites,
e);-1!==b&&(a.removeCompositeAt(c,b),a.setModified(c,!0,!0,!1));if(d)for(d=0;d<c.composites.length;d++)a.removeComposite(c.composites[d],e,!0);return c};a.removeCompositeAt=function(c,e){c.composites.splice(e,1);a.setModified(c,!0,!0,!1);return c};a.addBody=function(c,e){c.bodies.push(e);a.setModified(c,!0,!0,!1);return c};a.removeBody=function(c,e,d){var b=f.indexOf(c.bodies,e);-1!==b&&(a.removeBodyAt(c,b),a.setModified(c,!0,!0,!1));if(d)for(d=0;d<c.composites.length;d++)a.removeBody(c.composites[d],
e,!0);return c};a.removeBodyAt=function(c,e){c.bodies.splice(e,1);a.setModified(c,!0,!0,!1);return c};a.addConstraint=function(c,e){c.constraints.push(e);a.setModified(c,!0,!0,!1);return c};a.removeConstraint=function(c,e,d){var b=f.indexOf(c.constraints,e);-1!==b&&a.removeConstraintAt(c,b);if(d)for(d=0;d<c.composites.length;d++)a.removeConstraint(c.composites[d],e,!0);return c};a.removeConstraintAt=function(c,e){c.constraints.splice(e,1);a.setModified(c,!0,!0,!1);return c};a.clear=function(c,e,d){if(d)for(d=
0;d<c.composites.length;d++)a.clear(c.composites[d],e,!0);e?c.bodies=c.bodies.filter(function(b){return b.isStatic}):c.bodies.length=0;c.constraints.length=0;c.composites.length=0;a.setModified(c,!0,!0,!1);return c};a.allBodies=function(c){for(var e=[].concat(c.bodies),d=0;d<c.composites.length;d++)e=e.concat(a.allBodies(c.composites[d]));return e};a.allConstraints=function(c){for(var e=[].concat(c.constraints),d=0;d<c.composites.length;d++)e=e.concat(a.allConstraints(c.composites[d]));return e};
a.allComposites=function(c){for(var e=[].concat(c.composites),d=0;d<c.composites.length;d++)e=e.concat(a.allComposites(c.composites[d]));return e};a.get=function(c,e,d){switch(d){case "body":var b=a.allBodies(c);break;case "constraint":b=a.allConstraints(c);break;case "composite":b=a.allComposites(c).concat(c)}if(!b)return null;c=b.filter(function(b){return b.id.toString()===e.toString()});return 0===c.length?null:c[0]};a.move=function(c,e,d){a.remove(c,e);a.add(d,e);return c};a.rebase=function(c){for(var e=
a.allBodies(c).concat(a.allConstraints(c)).concat(a.allComposites(c)),d=0;d<e.length;d++)e[d].id=f.nextId();a.setModified(c,!0,!0,!1);return c};a.translate=function(c,f,d){d=d?a.allBodies(c):c.bodies;for(var b=0;b<d.length;b++)e.translate(d[b],f);a.setModified(c,!0,!0,!1);return c};a.rotate=function(c,f,d,b){var h=Math.cos(f),k=Math.sin(f);b=b?a.allBodies(c):c.bodies;for(var g=0;g<b.length;g++){var r=b[g],m=r.position.x-d.x,t=r.position.y-d.y;e.setPosition(r,{x:d.x+(m*h-t*k),y:d.y+(m*k+t*h)});e.rotate(r,
f)}a.setModified(c,!0,!0,!1);return c};a.scale=function(c,f,d,b,h){h=h?a.allBodies(c):c.bodies;for(var k=0;k<h.length;k++){var g=h[k];e.setPosition(g,{x:b.x+(g.position.x-b.x)*f,y:b.y+(g.position.y-b.y)*d});e.scale(g,f,d)}a.setModified(c,!0,!0,!1);return c}})()},{"../core/Common":14,"../core/Events":16,"./Body":1}],3:[function(l,n,w){var a={};n.exports=a;var k=l("./Composite");l("../constraint/Constraint");var f=l("../core/Common");(function(){a.create=function(a){var c=k.create();return f.extend(c,
{label:"World",gravity:{x:0,y:1,scale:.001},bounds:{min:{x:-Infinity,y:-Infinity},max:{x:Infinity,y:Infinity}}},a)}})()},{"../constraint/Constraint":12,"../core/Common":14,"./Composite":2}],4:[function(l,n,w){var a={};n.exports=a;(function(){a.create=function(k){return{id:a.id(k),vertex:k,normalImpulse:0,tangentImpulse:0}};a.id=function(a){return a.body.id+"_"+a.index}})()},{}],5:[function(l,n,w){var a={};n.exports=a;var k=l("./SAT"),f=l("./Pair"),e=l("../geometry/Bounds");(function(){a.collisions=
function(c,u,d){d=[];u=u.pairs.table;for(var b=0;b<c.length;b++){var h=c[b][0],v=c[b][1];if((!h.isStatic&&!h.isSleeping||!v.isStatic&&!v.isSleeping)&&a.canCollide(h.collisionFilter,v.collisionFilter)){if(h.name&&v.name){if(h.pass||v.pass)continue;if(/character/i.test(h.name)&&/monster/i.test(v.name))continue;if(/monster|item/i.test(h.name)&&/monster|item/i.test(v.name))continue;if(/monster|item|character|static/i.test(h.name)&&/pass/i.test(v.name))continue;if(/Pass/i.test(h.name)&&/monster|item|character|static/i.test(v.name))continue;
if(/pass/i.test(h.name)&&/pass/i.test(v.name))continue}if(e.overlaps(h.bounds,v.bounds))for(var g=1<h.parts.length?1:0;g<h.parts.length;g++)for(var r=h.parts[g],m=1<v.parts.length?1:0;m<v.parts.length;m++){var t=v.parts[m];if(r===h&&t===v||e.overlaps(r.bounds,t.bounds)){var p=f.id(r,t);p=u[p];t=k.collides(r,t,p&&p.isActive?p.collision:null);t.collided&&d.push(t)}}}}return d};a.canCollide=function(c,a){return c.group===a.group&&0!==c.group?0<c.group:0!==(c.mask&a.category)&&0!==(a.mask&c.category)}})()},
{"../geometry/Bounds":24,"./Pair":7,"./SAT":11}],6:[function(l,n,w){var a={};n.exports=a;var k=l("./Pair"),f=l("./Detector"),e=l("../core/Common");(function(){a.create=function(c){return e.extend({controller:a,detector:f.collisions,buckets:{},pairs:{},pairsList:[],bucketWidth:48,bucketHeight:48},c)};a.update=function(a,d,b,h,f){var g=b.world,r=a.buckets;var m=!1;for(b=0;b<d.length;b++){var t=d[b];if(!t.src||!/dungeon/i.test(f.map))if(!t.isSleeping||h){var p=t.bounds.max;var v=t.bounds.min;var u=g.bounds.max;
var E=g.bounds.min;if(!(p.x<E.x||v.x>u.x||p.y<E.y||v.y>u.y)&&(p=t.bounds,p=c(Math.floor(p.min.x/a.bucketWidth),Math.floor(p.max.x/a.bucketWidth),Math.floor(p.min.y/a.bucketHeight),Math.floor(p.max.y/a.bucketHeight)),!t.region||p.id!==t.region.id||h)){if(!t.region||h)t.region=p;m=t.region;u=c(Math.min(p.startCol,m.startCol),Math.max(p.endCol,m.endCol),Math.min(p.startRow,m.startRow),Math.max(p.endRow,m.endRow));for(m=u.startCol;m<=u.endCol;m++)for(v=u.startRow;v<=u.endRow;v++){var l=m+","+v;E=r[l];
var n=m>=p.startCol&&m<=p.endCol&&v>=p.startRow&&v<=p.endRow,y=m>=t.region.startCol&&m<=t.region.endCol&&v>=t.region.startRow&&v<=t.region.endRow;if(!n&&y&&y&&E){var w=a,C=E,A=t;C.splice(e.indexOf(C,A),1);for(var z=0;z<C.length;z++){var B=k.id(A,C[z]);(B=w.pairs[B])&&--B[2]}}if(t.region===p||n&&!y||h){E||(E=r[l]=[]);l=a;n=t;for(y=0;y<E.length;y++)w=E[y],n.id===w.id||n.isStatic&&w.isStatic||(C=k.id(n,w),(A=l.pairs[C])?A[2]+=1:l.pairs[C]=[n,w,1]);E.push(n)}}t.region=p;m=!0}}}if(m){f=[];d=e.keys(a.pairs);
for(b=0;b<d.length;b++)h=a.pairs[d[b]],0<h[2]?f.push(h):delete a.pairs[d[b]];a.pairsList=f}};a.clear=function(c){c.buckets={};c.pairs={};c.pairsList=[]};var c=function(c,d,b,a){return{id:c+","+d+","+b+","+a,startCol:c,endCol:d,startRow:b,endRow:a}}})()},{"../core/Common":14,"./Detector":5,"./Pair":7}],7:[function(l,n,w){var a={};n.exports=a;var k=l("./Contact");(function(){a.create=function(f,e){var c=f.bodyA,k=f.bodyB,d=f.parentA,b=f.parentB;c={id:a.id(c,k),bodyA:c,bodyB:k,contacts:{},activeContacts:[],
separation:0,isActive:!0,isSensor:c.isSensor||k.isSensor,timeCreated:e,timeUpdated:e,inverseMass:d.inverseMass+b.inverseMass,friction:Math.min(d.friction,b.friction),frictionStatic:Math.max(d.frictionStatic,b.frictionStatic),restitution:Math.max(d.restitution,b.restitution),slop:Math.max(d.slop,b.slop)};a.update(c,f,e);return c};a.update=function(f,e,c){var u=f.contacts,d=e.supports,b=f.activeContacts,h=e.parentA,v=e.parentB;f.collision=e;f.inverseMass=h.inverseMass+v.inverseMass;f.friction=Math.min(h.friction,
v.friction);f.frictionStatic=Math.max(h.frictionStatic,v.frictionStatic);f.restitution=Math.max(h.restitution,v.restitution);f.slop=Math.max(h.slop,v.slop);b.length=0;if(e.collided){for(h=0;h<d.length;h++){v=d[h];var g=k.id(v),r=u[g];r?b.push(r):b.push(u[g]=k.create(v))}f.separation=e.depth;a.setActive(f,!0,c)}else!0===f.isActive&&a.setActive(f,!1,c)};a.setActive=function(a,e,c){e?(a.isActive=!0,a.timeUpdated=c):(a.isActive=!1,a.activeContacts.length=0)};a.id=function(a,e){return a.id<e.id?a.id+"_"+
e.id:e.id+"_"+a.id}})()},{"./Contact":4}],8:[function(l,n,w){var a={};n.exports=a;var k=l("./Pair"),f=l("../core/Common");(function(){a.create=function(a){return f.extend({table:{},list:[],collisionStart:[],collisionActive:[],collisionEnd:[]},a)};a.update=function(a,c,u){var d=a.list,b=a.table,e=a.collisionStart,v=a.collisionEnd;a=a.collisionActive;var g=[],r,m;e.length=0;v.length=0;for(m=a.length=0;m<c.length;m++){var t=c[m];if(t.collided){var p=k.id(t.bodyA,t.bodyB);g.push(p);(r=b[p])?(r.isActive?
a.push(r):e.push(r),k.update(r,t,u)):(r=k.create(t,u),b[p]=r,e.push(r),d.push(r))}}for(m=0;m<d.length;m++)r=d[m],r.isActive&&-1===f.indexOf(g,r.id)&&(k.setActive(r,!1,u),v.push(r))};a.removeOld=function(a,c){var e=a.list,d=a.table,b=[],h;for(h=0;h<e.length;h++){var f=e[h];var g=f.collision;g.bodyA.isSleeping||g.bodyB.isSleeping?f.timeUpdated=c:1E3<c-f.timeUpdated&&b.push(h)}for(h=0;h<b.length;h++)g=b[h]-h,f=e[g],delete d[f.id],e.splice(g,1)};a.clear=function(a){a.table={};a.list.length=0;a.collisionStart.length=
0;a.collisionActive.length=0;a.collisionEnd.length=0;return a}})()},{"../core/Common":14,"./Pair":7}],9:[function(l,n,w){var a={};n.exports=a;var k=l("../geometry/Vector"),f=l("./SAT"),e=l("../geometry/Bounds"),c=l("../factory/Bodies"),u=l("../geometry/Vertices");(function(){a.ray=function(d,b,a,v){v=v||1E-100;var g=k.angle(b,a),h=k.magnitude(k.sub(b,a));b=c.rectangle(.5*(a.x+b.x),.5*(a.y+b.y),h,v,{angle:g});a=[];for(v=0;v<d.length;v++)if(g=d[v],e.overlaps(g.bounds,b.bounds))for(h=1===g.parts.length?
0:1;h<g.parts.length;h++){var m=g.parts[h];if(e.overlaps(m.bounds,b.bounds)&&(m=f.collides(m,b),m.collided)){m.body=m.bodyA=m.bodyB=g;a.push(m);break}}return a};a.region=function(d,b,c){for(var a=[],g=0;g<d.length;g++){var h=d[g],m=e.overlaps(h.bounds,b);(m&&!c||!m&&c)&&a.push(h)}return a};a.point=function(d,b){for(var c=[],a=0;a<d.length;a++){var g=d[a];if(e.contains(g.bounds,b))for(var f=1===g.parts.length?0:1;f<g.parts.length;f++){var m=g.parts[f];if(e.contains(m.bounds,b)&&u.contains(m.vertices,
b)){c.push(g);break}}}return c}})()},{"../factory/Bodies":21,"../geometry/Bounds":24,"../geometry/Vector":26,"../geometry/Vertices":27,"./SAT":11}],10:[function(l,n,w){var a={};n.exports=a;var k=l("../geometry/Vertices"),f=l("../geometry/Vector"),e=l("../core/Common"),c=l("../geometry/Bounds");(function(){a._restingThresh=4;a._restingThreshTangent=6;a._positionDampen=.9;a._positionWarming=.8;a._frictionNormalMultiplier=5;a.preSolvePosition=function(c){var d;for(d=0;d<c.length;d++){var b=c[d];if(b.isActive){var a=
b.activeContacts.length;b.collision.parentA.totalContacts+=a;b.collision.parentB.totalContacts+=a}}};a.solvePosition=function(c,d){var b;var e=f._temp[0];var k=f._temp[1],g=f._temp[2],r=f._temp[3];for(b=0;b<c.length;b++){var m=c[b];if(m.isActive&&!m.isSensor){var t=m.collision;var p=t.parentA;var q=t.parentB;var u=t.normal;p=f.sub(f.add(q.positionImpulse,q.position,e),f.add(p.positionImpulse,f.sub(q.position,t.penetration,k),g),r);m.separation=f.dot(u,p)}}for(b=0;b<c.length;b++)if(m=c[b],!(!m.isActive||
m.isSensor||0>m.separation)){t=m.collision;p=t.parentA;q=t.parentB;u=t.normal;e=(m.separation-m.slop)*d;if(p.isStatic||q.isStatic)e*=2;p.isStatic||p.isSleeping||(m=a._positionDampen/p.totalContacts,p.positionImpulse.x+=u.x*e*m,p.positionImpulse.y+=u.y*e*m);q.isStatic||q.isSleeping||(m=a._positionDampen/q.totalContacts,q.positionImpulse.x-=u.x*e*m,q.positionImpulse.y-=u.y*e*m)}};a.postSolvePosition=function(e){for(var d=0;d<e.length;d++){var b=e[d];b.totalContacts=0;if(0!==b.positionImpulse.x||0!==
b.positionImpulse.y){for(var h=0;h<b.parts.length;h++){var v=b.parts[h];k.translate(v.vertices,b.positionImpulse);c.update(v.bounds,v.vertices,b.velocity);v.position.x+=b.positionImpulse.x;v.position.y+=b.positionImpulse.y}b.positionPrev.x+=b.positionImpulse.x;b.positionPrev.y+=b.positionImpulse.y;0>f.dot(b.positionImpulse,b.velocity)?(b.positionImpulse.x=0,b.positionImpulse.y=0):(b.positionImpulse.x*=a._positionWarming,b.positionImpulse.y*=a._positionWarming)}}};a.preSolveVelocity=function(c){var d,
b=f._temp[0],a=f._temp[1];for(d=0;d<c.length;d++){var e=c[d];if(e.isActive&&!e.isSensor){var g=e.activeContacts;var k=e.collision;e=k.parentA;var m=k.parentB;var t=k.normal;var p=k.tangent;for(k=0;k<g.length;k++){var q=g[k];var u=q.vertex;var l=q.normalImpulse;q=q.tangentImpulse;if(0!==l||0!==q)b.x=t.x*l+p.x*q,b.y=t.y*l+p.y*q,e.isStatic||e.isSleeping||(l=f.sub(u,e.position,a),e.positionPrev.x+=b.x*e.inverseMass,e.positionPrev.y+=b.y*e.inverseMass,e.anglePrev+=f.cross(l,b)*e.inverseInertia),m.isStatic||
m.isSleeping||(l=f.sub(u,m.position,a),m.positionPrev.x-=b.x*m.inverseMass,m.positionPrev.y-=b.y*m.inverseMass,m.anglePrev-=f.cross(l,b)*m.inverseInertia)}}}};a.solveVelocity=function(c,d){for(var b=d*d,h=f._temp[0],k=f._temp[1],g=f._temp[2],r=f._temp[3],m=f._temp[4],t=f._temp[5],p=0;p<c.length;p++){var q=c[p];if(q.isActive&&!q.isSensor){var u=q.collision,l=u.parentA,x=u.parentB,n=u.normal;u=u.tangent;var y=q.activeContacts,w=1/y.length;l.velocity.x=l.position.x-l.positionPrev.x;l.velocity.y=l.position.y-
l.positionPrev.y;x.velocity.x=x.position.x-x.positionPrev.x;x.velocity.y=x.position.y-x.positionPrev.y;l.angularVelocity=l.angle-l.anglePrev;x.angularVelocity=x.angle-x.anglePrev;for(var C=0;C<y.length;C++){var A=y[C],z=A.vertex,B=f.sub(z,l.position,k);z=f.sub(z,x.position,g);var F=f.add(l.velocity,f.mult(f.perp(B),l.angularVelocity),r),I=f.add(x.velocity,f.mult(f.perp(z),x.angularVelocity),m);F=f.sub(F,I,t);var H=f.dot(n,F),K=f.dot(u,F),J=Math.abs(K),M=e.sign(K);F=(1+q.restitution)*H;var O=e.clamp(q.separation+
H,0,1)*a._frictionNormalMultiplier;I=K;var L=Infinity;J>q.friction*q.frictionStatic*O*b&&(L=J,I=e.clamp(q.friction*M*b,-L,L));J=f.cross(B,n);M=f.cross(z,n);J=w/(l.inverseMass+x.inverseMass+l.inverseInertia*J*J+x.inverseInertia*M*M);F*=J;I*=J;0>H&&H*H>a._restingThresh*b?A.normalImpulse=0:(H=A.normalImpulse,A.normalImpulse=Math.min(A.normalImpulse+F,0),F=A.normalImpulse-H);K*K>a._restingThreshTangent*b?A.tangentImpulse=0:(H=A.tangentImpulse,A.tangentImpulse=e.clamp(A.tangentImpulse+I,-L,L),I=A.tangentImpulse-
H);h.x=n.x*F+u.x*I;h.y=n.y*F+u.y*I;l.isStatic||l.isSleeping||(l.positionPrev.x+=h.x*l.inverseMass,l.positionPrev.y+=h.y*l.inverseMass,l.anglePrev+=f.cross(B,h)*l.inverseInertia);x.isStatic||x.isSleeping||(x.positionPrev.x-=h.x*x.inverseMass,x.positionPrev.y-=h.y*x.inverseMass,x.anglePrev-=f.cross(z,h)*x.inverseInertia)}}}}})()},{"../core/Common":14,"../geometry/Bounds":24,"../geometry/Vector":26,"../geometry/Vertices":27}],11:[function(l,n,w){var a={};n.exports=a;var k=l("../geometry/Vertices"),f=
l("../geometry/Vector");(function(){a.collides=function(d,b,c){var a=!1;if(c){var g=d.parent;a=b.parent;g=g.speed*g.speed+g.angularSpeed*g.angularSpeed+a.speed*a.speed+a.angularSpeed*a.angularSpeed;a=c&&c.collided&&.2>g;g=c}else g={collided:!1,bodyA:d,bodyB:b};if(c&&a){if(a=g.axisBody,c=e(a.vertices,(a===d?b:d).vertices,[a.axes[c.axisNumber]]),g.reused=!0,0>=c.overlap)return g.collided=!1,g}else{c=e(d.vertices,b.vertices,d.axes);if(0>=c.overlap)return g.collided=!1,g;a=e(b.vertices,d.vertices,b.axes);
if(0>=a.overlap)return g.collided=!1,g;c.overlap<a.overlap?g.axisBody=d:(c=a,g.axisBody=b);g.axisNumber=c.axisNumber}g.bodyA=d.id<b.id?d:b;g.bodyB=d.id<b.id?b:d;g.collided=!0;g.normal=c.axis;g.depth=c.overlap;g.parentA=g.bodyA.parent;g.parentB=g.bodyB.parent;d=g.bodyA;b=g.bodyB;0<f.dot(g.normal,f.sub(b.position,d.position))&&(g.normal=f.neg(g.normal));g.tangent=f.perp(g.normal);g.penetration={x:g.normal.x*g.depth,y:g.normal.y*g.depth};c=u(d,b,g.normal);a=g.supports||[];a.length=0;k.contains(d.vertices,
c[0])&&a.push(c[0]);k.contains(d.vertices,c[1])&&a.push(c[1]);2>a.length&&(d=u(b,d,f.neg(g.normal)),k.contains(b.vertices,d[0])&&a.push(d[0]),2>a.length&&k.contains(b.vertices,d[1])&&a.push(d[1]));1>a.length&&(a=[c[0]]);g.supports=a;return g};var e=function(d,b,a){for(var e=f._temp[0],g=f._temp[1],k={overlap:Number.MAX_VALUE},m,t,h=0;h<a.length;h++){t=a[h];c(e,d,t);c(g,b,t);m=Math.min(e.max-g.min,g.max-e.min);if(0>=m){k.overlap=m;break}m<k.overlap&&(k.overlap=m,k.axis=t,k.axisNumber=h)}return k},
c=function(d,b,c){for(var a=f.dot(b[0],c),g=a,e=1;e<b.length;e+=1){var m=f.dot(b[e],c);m>g?g=m:m<a&&(a=m)}d.min=a;d.max=g},u=function(d,b,c){var a=Number.MAX_VALUE,g=f._temp[0];b=b.vertices;d=d.position;var e;for(e=0;e<b.length;e++){var m=b[e];g.x=m.x-d.x;g.y=m.y-d.y;var k=-f.dot(c,g);if(k<a){a=k;var h=m}}m=b[0<=h.index-1?h.index-1:b.length-1];g.x=m.x-d.x;g.y=m.y-d.y;a=-f.dot(c,g);e=m;m=b[(h.index+1)%b.length];g.x=m.x-d.x;g.y=m.y-d.y;k=-f.dot(c,g);k<a&&(e=m);return[h,e]}})()},{"../geometry/Vector":26,
"../geometry/Vertices":27}],12:[function(l,n,w){var a={};n.exports=a;var k=l("../geometry/Vertices"),f=l("../geometry/Vector"),e=l("../core/Sleeping"),c=l("../geometry/Bounds"),u=l("../geometry/Axes"),d=l("../core/Common");(function(){a.create=function(b){b.bodyA&&!b.pointA&&(b.pointA={x:0,y:0});b.bodyB&&!b.pointB&&(b.pointB={x:0,y:0});var c=b.bodyA?f.add(b.bodyA.position,b.pointA):b.pointA,a=b.bodyB?f.add(b.bodyB.position,b.pointB):b.pointB;c=f.magnitude(f.sub(c,a));b.length=b.length||c||1E-6;b.render=
d.extend({visible:!0,lineWidth:2,strokeStyle:"#666"},b.render);b.id=b.id||d.nextId();b.label=b.label||"Constraint";b.type="constraint";b.stiffness=b.stiffness||1;b.angularStiffness=b.angularStiffness||0;b.angleA=b.bodyA?b.bodyA.angle:b.angleA;b.angleB=b.bodyB?b.bodyB.angle:b.angleB;return b};a.solveAll=function(b,d){for(var c=0;c<b.length;c++)a.solve(b[c],d)};a.solve=function(b,d){var c=b.bodyA,a=b.bodyB,e=b.pointA,m=b.pointB;c&&!c.isStatic&&(b.pointA=f.rotate(e,c.angle-b.angleA),b.angleA=c.angle);
a&&!a.isStatic&&(b.pointB=f.rotate(m,a.angle-b.angleB),b.angleB=a.angle);var k=e,h=m;c&&(k=f.add(c.position,e));a&&(h=f.add(a.position,m));if(k&&h){m=f.sub(k,h);var q=f.magnitude(m);0===q&&(q=1E-6);var u=(q-b.length)/q;e=f.div(m,q);m=f.mult(m,.5*u*b.stiffness*d*d);if(!(Math.abs(1-q/b.length)<.001*d)){if(c&&!c.isStatic){var l={x:k.x-c.position.x+m.x,y:k.y-c.position.y+m.y};c.velocity.x=c.position.x-c.positionPrev.x;c.velocity.y=c.position.y-c.positionPrev.y;c.angularVelocity=c.angle-c.anglePrev;k=
f.add(c.velocity,f.mult(f.perp(l),c.angularVelocity));q=f.dot(l,e);q=c.inverseMass+c.inverseInertia*q*q}else k={x:0,y:0},q=c?c.inverseMass:0;if(a&&!a.isStatic){var n={x:h.x-a.position.x-m.x,y:h.y-a.position.y-m.y};a.velocity.x=a.position.x-a.positionPrev.x;a.velocity.y=a.position.y-a.positionPrev.y;a.angularVelocity=a.angle-a.anglePrev;h=f.add(a.velocity,f.mult(f.perp(n),a.angularVelocity));u=f.dot(n,e);u=a.inverseMass+a.inverseInertia*u*u}else h={x:0,y:0},u=a?a.inverseMass:0;h=f.sub(h,k);h=f.dot(e,
h)/(q+u);0<h&&(h=0);e={x:e.x*h,y:e.y*h};c&&!c.isStatic&&(l=f.cross(l,e)*c.inverseInertia*(1-b.angularStiffness),c.constraintImpulse.x-=m.x,c.constraintImpulse.y-=m.y,c.constraintImpulse.angle+=l,c.position.x-=m.x,c.position.y-=m.y,c.angle+=l);a&&!a.isStatic&&(l=f.cross(n,e)*a.inverseInertia*(1-b.angularStiffness),a.constraintImpulse.x+=m.x,a.constraintImpulse.y+=m.y,a.constraintImpulse.angle-=l,a.position.x+=m.x,a.position.y+=m.y,a.angle-=l)}}};a.postSolveAll=function(b){for(var d=0;d<b.length;d++){var a=
b[d],g=a.constraintImpulse;if(0!==g.x||0!==g.y||0!==g.angle){e.set(a,!1);for(var r=0;r<a.parts.length;r++){var m=a.parts[r];k.translate(m.vertices,g);0<r&&(m.position.x+=g.x,m.position.y+=g.y);0!==g.angle&&(k.rotate(m.vertices,g.angle,a.position),u.rotate(m.axes,g.angle),0<r&&f.rotateAbout(m.position,g.angle,a.position,m.position));c.update(m.bounds,m.vertices,a.velocity)}g.angle=0;g.x=0;g.y=0}}}})()},{"../core/Common":14,"../core/Sleeping":20,"../geometry/Axes":23,"../geometry/Bounds":24,"../geometry/Vector":26,
"../geometry/Vertices":27}],13:[function(l,n,w){var a={};n.exports=a;var k=l("../geometry/Vertices"),f=l("../core/Sleeping"),e=l("../core/Mouse"),c=l("../core/Events"),u=l("../collision/Detector"),d=l("./Constraint"),b=l("../body/Composite"),h=l("../core/Common"),v=l("../geometry/Bounds");(function(){a.create=function(g,k){var m=(g?g.mouse:null)||(k?k.mouse:null);m||(g&&g.render&&g.render.canvas?m=e.create(g.render.canvas):k&&k.element?m=e.create(k.element):(m=e.create(),h.log("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected",
"warn")));var f=d.create({label:"Mouse Constraint",pointA:m.position,pointB:{x:0,y:0},length:.01,stiffness:.1,angularStiffness:1,render:{strokeStyle:"#90EE90",lineWidth:3}}),p=h.extend({type:"mouseConstraint",mouse:m,element:null,body:null,constraint:f,collisionFilter:{category:1,mask:4294967295,group:0}},k);c.on(g,"tick",function(){var d=b.allBodies(g.world);a.update(p,d);d=p.mouse;var m=d.sourceEvents;m.mousemove&&c.trigger(p,"mousemove",{mouse:d});m.mousedown&&c.trigger(p,"mousedown",{mouse:d});
m.mouseup&&c.trigger(p,"mouseup",{mouse:d});e.clearSourceEvents(d)});return p};a.update=function(b,d){var a=b.mouse,g=b.constraint,e=b.body;if(0===a.button)if(g.bodyB)f.set(g.bodyB,!1),g.pointA=a.position;else for(var h=0;h<d.length;h++){if(e=d[h],v.contains(e.bounds,a.position)&&u.canCollide(e.collisionFilter,b.collisionFilter))for(var r=1<e.parts.length?1:0;r<e.parts.length;r++)if(k.contains(e.parts[r].vertices,a.position)){g.pointA=a.position;g.bodyB=b.body=e;g.pointB={x:a.position.x-e.position.x,
y:a.position.y-e.position.y};g.angleB=e.angle;f.set(e,!1);c.trigger(b,"startdrag",{mouse:a,body:e});break}}else g.bodyB=b.body=null,g.pointB=null,e&&c.trigger(b,"enddrag",{mouse:a,body:e})}})()},{"../body/Composite":2,"../collision/Detector":5,"../core/Common":14,"../core/Events":16,"../core/Mouse":18,"../core/Sleeping":20,"../geometry/Bounds":24,"../geometry/Vertices":27,"./Constraint":12}],14:[function(l,n,w){var a={};n.exports=a;(function(){a._nextId=0;a._seed=0;a.extend=function(k,f){if("boolean"===
typeof f){var e=2;var c=f}else e=1,c=!0;e=Array.prototype.slice.call(arguments,e);for(var u=0;u<e.length;u++){var d=e[u];if(d)for(var b in d)c&&d[b]&&d[b].constructor===Object?k[b]&&k[b].constructor!==Object?k[b]=d[b]:(k[b]=k[b]||{},a.extend(k[b],c,d[b])):k[b]=d[b]}return k};a.clone=function(k,f){return a.extend({},f,k)};a.keys=function(a){if(Object.keys)return Object.keys(a);var k=[],e;for(e in a)k.push(e);return k};a.values=function(a){var k=[];if(Object.keys){for(var e=Object.keys(a),c=0;c<e.length;c++)k.push(a[e[c]]);
return k}for(e in a)k.push(a[e]);return k};a.shadeColor=function(a,f){var e=parseInt(a.slice(1),16),c=Math.round(2.55*f),k=(e>>16)+c,d=(e>>8&255)+c;e=(e&255)+c;return"#"+(16777216+65536*(255>k?1>k?0:k:255)+256*(255>d?1>d?0:d:255)+(255>e?1>e?0:e:255)).toString(16).slice(1)};a.shuffle=function(k){for(var f=k.length-1;0<f;f--){var e=Math.floor(a.random()*(f+1)),c=k[f];k[f]=k[e];k[e]=c}return k};a.choose=function(k){return k[Math.floor(a.random()*k.length)]};a.isElement=function(a){try{return a instanceof
HTMLElement}catch(f){return"object"===typeof a&&1===a.nodeType&&"object"===typeof a.style&&"object"===typeof a.ownerDocument}};a.isArray=function(a){return"[object Array]"===Object.prototype.toString.call(a)};a.clamp=function(a,f,e){return a<f?f:a>e?e:a};a.sign=function(a){return 0>a?-1:1};a.now=function(){var a=window.performance||{};a.now=function(){return a.now||a.webkitNow||a.msNow||a.oNow||a.mozNow||function(){return+new Date}}();return a.now()};a.random=function(k,f){k="undefined"!==typeof k?
k:0;a._seed=(9301*a._seed+49297)%233280;return k+a._seed/233280*(("undefined"!==typeof f?f:1)-k)};a.colorToNumber=function(a){a=a.replace("#","");3==a.length&&(a=a.charAt(0)+a.charAt(0)+a.charAt(1)+a.charAt(1)+a.charAt(2)+a.charAt(2));return parseInt(a,16)};a.log=function(a,f){if(console&&console.log&&console.warn)switch(f){case "warn":console.warn("Matter.js:",a);break;case "error":console.log("Matter.js:",a)}};a.nextId=function(){return a._nextId++};a.indexOf=function(a,f){if(a.indexOf)return a.indexOf(f);
for(var e=0;e<a.length;e++)if(a[e]===f)return e;return-1}})()},{}],15:[function(l,n,w){var a={};n.exports=a;var k=l("../body/World"),f=l("./Sleeping"),e=l("../collision/Resolver"),c=l("../render/Render"),u=l("../collision/Pairs");l("./Metrics");var d=l("../collision/Grid"),b=l("./Events"),h=l("../body/Composite"),v=l("../constraint/Constraint"),g=l("./Common"),r=l("../body/Body");(function(){a.create=function(b,a){a=g.isElement(b)?a:b;b=g.isElement(b)?b:null;a=a||{};(b||a.render)&&g.log("Engine.create: engine.render is deprecated (see docs)",
"warn");var e=g.extend({positionIterations:6,velocityIterations:4,constraintIterations:2,enableSleeping:!1,events:[],timing:{timestamp:0,timeScale:1},broadphase:{controller:d}},a);if(b||e.render)e.render=g.extend({element:b,controller:c},e.render);e.render&&e.render.controller&&(e.render=e.render.controller.create(e.render));e.render&&(e.render.engine=e);e.world=a.world||k.create(e.world);e.pairs=u.create();e.broadphase=e.broadphase.controller.create(e.broadphase);e.metrics=e.metrics||{extended:!1};
return e};a.update=function(a,d,c,g){d=d||1E3/60;c=c||1;var m=a.world,k=a.timing,t=a.broadphase;k.timestamp+=d*k.timeScale;var p={timestamp:k.timestamp};b.trigger(a,"beforeUpdate",p);var q=h.allBodies(m);var l=h.allConstraints(m);a.enableSleeping&&f.update(q,k.timeScale);var n=m.gravity,w="undefined"!==typeof n.scale?n.scale:.001;if((0!==n.x||0!==n.y)&&0!==w)for(var z=0;z<q.length;z++){var B=q[z];B.isStatic||B.isSleeping||(B.force.y+=B.mass*n.y*w,B.force.x+=B.mass*n.x*w)}n=k.timeScale;for(w=0;w<q.length;w++)z=
q[w],z.isStatic||z.isSleeping||r.update(z,d,n,c);for(c=0;c<a.constraintIterations;c++)v.solveAll(l,k.timeScale);v.postSolveAll(q);t.controller?(m.isModified&&t.controller.clear(t),t.controller.update(t,q,a,m.isModified,g),l=t.pairsList):l=q;m.isModified&&h.setModified(m,!1,!1,!0);m=t.detector(l,a,g);g=a.pairs;t=k.timestamp;u.update(g,m,t);u.removeOld(g,t);a.enableSleeping&&f.afterCollisions(g.list,k.timeScale);0<g.collisionStart.length&&b.trigger(a,"collisionStart",{pairs:g.collisionStart});e.preSolvePosition(g.list);
for(c=0;c<a.positionIterations;c++)e.solvePosition(g.list,k.timeScale);e.postSolvePosition(q);e.preSolveVelocity(g.list);for(c=0;c<a.velocityIterations;c++)e.solveVelocity(g.list,k.timeScale);0<g.collisionActive.length&&b.trigger(a,"collisionActive",{pairs:g.collisionActive});0<g.collisionEnd.length&&b.trigger(a,"collisionEnd",{pairs:g.collisionEnd});for(k=0;k<q.length;k++)g=q[k],g.force.x=g.force.y=g.torque=0;b.trigger(a,"afterUpdate",p);return a};a.merge=function(b,d){g.extend(b,d);if(d.world){b.world=
d.world;a.clear(b);for(var c=h.allBodies(b.world),e=0;e<c.length;e++){var m=c[e];f.set(m,!1);m.id=g.nextId()}}};a.clear=function(b){var a=b.world;u.clear(b.pairs);var d=b.broadphase;d.controller&&(a=h.allBodies(a),d.controller.clear(d),d.controller.update(d,a,b,!0))}})()},{"../body/Body":1,"../body/Composite":2,"../body/World":3,"../collision/Grid":6,"../collision/Pairs":8,"../collision/Resolver":10,"../constraint/Constraint":12,"../render/Render":29,"./Common":14,"./Events":16,"./Metrics":17,"./Sleeping":20}],
16:[function(l,n,w){var a={};n.exports=a;var k=l("./Common");(function(){a.on=function(a,e,c){e=e.split(" ");for(var k,d=0;d<e.length;d++)k=e[d],a.events=a.events||{},a.events[k]=a.events[k]||[],a.events[k].push(c);return c};a.off=function(a,e,c){if(e){"function"===typeof e&&(c=e,e=k.keys(a.events).join(" "));e=e.split(" ");for(var f=0;f<e.length;f++){var d=a.events[e[f]],b=[];if(c&&d)for(var h=0;h<d.length;h++)d[h]!==c&&b.push(d[h]);a.events[e[f]]=b}}else a.events={}};a.trigger=function(a,e,c){var f;
if(a.events){c||(c={});e=e.split(" ");for(var d=0;d<e.length;d++){var b=e[d];if(f=a.events[b]){var h=k.clone(c,!1);h.name=b;h.source=a;for(b=0;b<f.length;b++)f[b].apply(a,[h])}}}}})()},{"./Common":14}],17:[function(l,n,w){},{"../body/Composite":2,"./Common":14}],18:[function(l,n,w){var a={};n.exports=a;var k=l("../core/Common");(function(){a.create=function(e){var c={};e||k.log("Mouse.create: element was undefined, defaulting to document.body","warn");c.element=e||document.body;c.absolute={x:0,y:0};
c.position={x:0,y:0};c.mousedownPosition={x:0,y:0};c.mouseupPosition={x:0,y:0};c.offset={x:0,y:0};c.scale={x:1,y:1};c.wheelDelta=0;c.button=-1;c.pixelRatio=c.element.getAttribute("data-pixel-ratio")||1;c.sourceEvents={mousemove:null,mousedown:null,mouseup:null,mousewheel:null};c.mousemove=function(a){var d=f(a,c.element,c.pixelRatio);a.changedTouches&&(c.button=0,a.preventDefault());c.absolute.x=d.x;c.absolute.y=d.y;c.position.x=c.absolute.x*c.scale.x+c.offset.x;c.position.y=c.absolute.y*c.scale.y+
c.offset.y;c.sourceEvents.mousemove=a};c.mousedown=function(a){var d=f(a,c.element,c.pixelRatio);a.changedTouches?(c.button=0,a.preventDefault()):c.button=a.button;c.absolute.x=d.x;c.absolute.y=d.y;c.position.x=c.absolute.x*c.scale.x+c.offset.x;c.position.y=c.absolute.y*c.scale.y+c.offset.y;c.mousedownPosition.x=c.position.x;c.mousedownPosition.y=c.position.y;c.sourceEvents.mousedown=a};c.mouseup=function(a){var d=f(a,c.element,c.pixelRatio);a.changedTouches&&a.preventDefault();c.button=-1;c.absolute.x=
d.x;c.absolute.y=d.y;c.position.x=c.absolute.x*c.scale.x+c.offset.x;c.position.y=c.absolute.y*c.scale.y+c.offset.y;c.mouseupPosition.x=c.position.x;c.mouseupPosition.y=c.position.y;c.sourceEvents.mouseup=a};c.mousewheel=function(a){c.wheelDelta=Math.max(-1,Math.min(1,a.wheelDelta||-a.detail));a.preventDefault()};a.setElement(c,c.element);return c};a.setElement=function(a,c){a.element=c;c.addEventListener("mousemove",a.mousemove);c.addEventListener("mousedown",a.mousedown);c.addEventListener("mouseup",
a.mouseup);c.addEventListener("mousewheel",a.mousewheel);c.addEventListener("DOMMouseScroll",a.mousewheel);c.addEventListener("touchmove",a.mousemove);c.addEventListener("touchstart",a.mousedown);c.addEventListener("touchend",a.mouseup)};a.clearSourceEvents=function(a){a.sourceEvents.mousemove=null;a.sourceEvents.mousedown=null;a.sourceEvents.mouseup=null;a.sourceEvents.mousewheel=null;a.wheelDelta=0};a.setOffset=function(a,c){a.offset.x=c.x;a.offset.y=c.y;a.position.x=a.absolute.x*a.scale.x+a.offset.x;
a.position.y=a.absolute.y*a.scale.y+a.offset.y};a.setScale=function(a,c){a.scale.x=c.x;a.scale.y=c.y;a.position.x=a.absolute.x*a.scale.x+a.offset.x;a.position.y=a.absolute.y*a.scale.y+a.offset.y};var f=function(a,c,k){var d=c.getBoundingClientRect(),b=document.documentElement||document.body.parentNode||document.body,e=void 0!==window.pageXOffset?window.pageXOffset:b.scrollLeft;b=void 0!==window.pageYOffset?window.pageYOffset:b.scrollTop;var f=a.changedTouches;f?(e=f[0].pageX-d.left-e,a=f[0].pageY-
d.top-b):(e=a.pageX-d.left-e,a=a.pageY-d.top-b);return{x:e/(c.clientWidth/c.width*k),y:a/(c.clientHeight/c.height*k)}}})()},{"../core/Common":14}],19:[function(l,n,w){var a={};n.exports=a;var k=l("./Events"),f=l("./Engine"),e=l("./Common");(function(){if("undefined"!==typeof window){var c=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(a){window.setTimeout(function(){a(e.now())},1E3/60)};var l=window.cancelAnimationFrame||
window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame}a.create=function(a){a=e.extend({fps:60,correction:1,deltaSampleSize:60,counterTimestamp:0,frameCounter:0,deltaHistory:[],timePrev:null,timeScalePrev:1,frameRequestId:null,isFixed:!1,enabled:!0},a);a.delta=a.delta||1E3/a.fps;a.deltaMin=a.deltaMin||1E3/a.fps;a.deltaMax=a.deltaMax||1E3/(.5*a.fps);a.fps=1E3/a.delta;return a};a.run=function(d,b){"undefined"!==typeof d.positionIterations&&(b=d,d=a.create());
(function g(e){d.frameRequestId=c(g);e&&d.enabled&&a.tick(d,b,e)})();return d};a.tick=function(a,b,c,e){var d=b.timing,h=1,m={timestamp:d.timestamp};k.trigger(a,"beforeTick",m);k.trigger(b,"beforeTick",m);if(a.isFixed)var t=a.delta;else t=c-a.timePrev||a.delta,a.timePrev=c,a.deltaHistory.push(t),a.deltaHistory=a.deltaHistory.slice(-a.deltaSampleSize),t=Math.min.apply(null,a.deltaHistory),t=t<a.deltaMin?a.deltaMin:t,t=t>a.deltaMax?a.deltaMax:t,h=t/a.delta,a.delta=t;0!==a.timeScalePrev&&(h*=d.timeScale/
a.timeScalePrev);0===d.timeScale&&(h=0);a.timeScalePrev=d.timeScale;a.correction=h;a.frameCounter+=1;1E3<=c-a.counterTimestamp&&(a.fps=(c-a.counterTimestamp)/1E3*a.frameCounter,a.counterTimestamp=c,a.frameCounter=0);k.trigger(b,"tick",m);b.world.isModified&&b.render&&b.render.controller&&b.render.controller.clear&&b.render.controller.clear(b.render);f.update(b,t,h,e)};a.stop=function(a){l(a.frameRequestId)};a.start=function(c,b){a.run(c,b)}})()},{"./Common":14,"./Engine":15,"./Events":16}],20:[function(l,
n,w){var a={};n.exports=a;var k=l("./Events");(function(){a._motionWakeThreshold=.18;a._motionSleepThreshold=.08;a._minBias=.9;a.update=function(k,e){for(var c=e*e*e,f=0;f<k.length;f++){var d=k[f],b=d.speed*d.speed+d.angularSpeed*d.angularSpeed;0!==d.force.x||0!==d.force.y?a.set(d,!1):(d.motion=a._minBias*Math.min(d.motion,b)+(1-a._minBias)*Math.max(d.motion,b),0<d.sleepThreshold&&d.motion<a._motionSleepThreshold*c?(d.sleepCounter+=1,d.sleepCounter>=d.sleepThreshold&&a.set(d,!0)):0<d.sleepCounter&&
--d.sleepCounter)}};a.afterCollisions=function(k,e){for(var c=e*e*e,f=0;f<k.length;f++){var d=k[f];if(d.isActive){var b=d.collision;d=b.bodyA.parent;var h=b.bodyB.parent;d.isSleeping&&h.isSleeping||d.isStatic||h.isStatic||!d.isSleeping&&!h.isSleeping||(b=d.isSleeping&&!d.isStatic?d:h,d=b===d?h:d,!b.isStatic&&d.motion>a._motionWakeThreshold*c&&a.set(b,!1))}}};a.set=function(a,e){var c=a.isSleeping;e?(a.isSleeping=!0,a.sleepCounter=a.sleepThreshold,a.positionImpulse.x=0,a.positionImpulse.y=0,a.positionPrev.x=
a.position.x,a.positionPrev.y=a.position.y,a.anglePrev=a.angle,a.speed=0,a.angularSpeed=0,a.motion=0,c||k.trigger(a,"sleepStart")):(a.isSleeping=!1,a.sleepCounter=0,c&&k.trigger(a,"sleepEnd"))}})()},{"./Events":16}],21:[function(l,n,w){var a={};n.exports=a;var k=l("../geometry/Vertices"),f=l("../core/Common"),e=l("../body/Body"),c=l("../geometry/Bounds"),u=l("../geometry/Vector");(function(){a.rectangle=function(a,b,c,l,g){g=g||{};a={label:"Rectangle Body",position:{x:a,y:b},vertices:k.fromPath("L 0 0 L "+
c+" 0 L "+c+" "+l+" L 0 "+l)};g.chamfer&&(b=g.chamfer,a.vertices=k.chamfer(a.vertices,b.radius,b.quality,b.qualityMin,b.qualityMax),delete g.chamfer);return e.create(f.extend({},a,g))};a.trapezoid=function(a,b,c,l,g,r){r=r||{};g*=.5;var d=c*g;c=d+(1-2*g)*c;var h=c+d;a={label:"Trapezoid Body",position:{x:a,y:b},vertices:k.fromPath(.5>g?"L 0 0 L "+d+" "+-l+" L "+c+" "+-l+" L "+h+" 0":"L 0 0 L "+c+" "+-l+" L "+h+" 0")};r.chamfer&&(b=r.chamfer,a.vertices=k.chamfer(a.vertices,b.radius,b.quality,b.qualityMin,
b.qualityMax),delete r.chamfer);return e.create(f.extend({},a,r))};a.circle=function(c,b,e,k,g){k=k||{};var d={label:"Circle Body",circleRadius:e};g=Math.ceil(Math.max(10,Math.min(g||25,e)));1===g%2&&(g+=1);return a.polygon(c,b,g,e,f.extend({},d,k))};a.polygon=function(c,b,h,l,g){g=g||{};if(3>h)return a.circle(c,b,l,g);for(var d=2*Math.PI/h,m="",t=.5*d,p=0;p<h;p+=1){var q=t+p*d,u=Math.sin(q)*l;m+="L "+(Math.cos(q)*l).toFixed(3)+" "+u.toFixed(3)+" "}c={label:"Polygon Body",position:{x:c,y:b},vertices:k.fromPath(m)};
g.chamfer&&(b=g.chamfer,c.vertices=k.chamfer(c.vertices,b.radius,b.quality,b.qualityMin,b.qualityMax),delete g.chamfer);return e.create(f.extend({},c,g))};a.fromVertices=function(a,b,h,l,g,r,m){var d,p;l=l||{};var q=[];g="undefined"!==typeof g?g:!1;r="undefined"!==typeof r?r:.01;m="undefined"!==typeof m?m:10;window.decomp||f.log("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.","warn");f.isArray(h[0])||(h=[h]);for(p=0;p<h.length;p+=1){var v=h[p];
if((d=k.isConvex(v))||!window.decomp)v=d?k.clockwiseSort(v):k.hull(v),q.push({position:{x:a,y:b},vertices:v});else{var n=new decomp.Polygon;for(d=0;d<v.length;d++)n.vertices.push([v[d].x,v[d].y]);n.makeCCW();!1!==r&&n.removeCollinearPoints(r);n=n.quickDecomp();for(d=0;d<n.length;d++){var x=n[d],D=[];for(v=0;v<x.vertices.length;v++)D.push({x:x.vertices[v][0],y:x.vertices[v][1]});0<m&&k.area(D)<m||q.push({position:k.centre(D),vertices:D})}}}for(d=0;d<q.length;d++)q[d]=e.create(f.extend(q[d],l));if(g)for(d=
0;d<q.length;d++)for(r=q[d],v=d+1;v<q.length;v++)if(m=q[v],c.overlaps(r.bounds,m.bounds))for(p=r.vertices,n=m.vertices,h=0;h<r.vertices.length;h++)for(g=0;g<m.vertices.length;g++)x=u.magnitudeSquared(u.sub(p[(h+1)%p.length],n[g])),D=u.magnitudeSquared(u.sub(p[h],n[(g+1)%n.length])),5>x&&5>D&&(p[h].isInternal=!0,n[g].isInternal=!0);return 1<q.length?(l=e.create(f.extend({parts:q.slice(0)},l)),e.setPosition(l,{x:a,y:b}),l):q[0]}})()},{"../body/Body":1,"../core/Common":14,"../geometry/Bounds":24,"../geometry/Vector":26,
"../geometry/Vertices":27}],22:[function(l,n,w){var a={};n.exports=a;var k=l("../body/Composite"),f=l("../constraint/Constraint"),e=l("../core/Common"),c=l("../body/Body"),u=l("./Bodies");(function(){a.stack=function(a,b,e,f,g,r,m){for(var d=k.create({label:"Stack"}),h=a,q,l=0,u=0;u<f;u++){for(var v=0,n=0;n<e;n++){var y=m(h,b,n,u,q,l);y?(h=y.bounds.max.y-y.bounds.min.y,q=y.bounds.max.x-y.bounds.min.x,h>v&&(v=h),c.translate(y,{x:.5*q,y:.5*h}),h=y.bounds.max.x+g,k.addBody(d,y),q=y,l+=1):h+=g}b+=v+r;
h=a}return d};a.chain=function(a,b,c,l,g,r){for(var d=a.bodies,h=1;h<d.length;h++){var p=d[h-1],q=d[h];p=e.extend({bodyA:p,pointA:{x:(p.bounds.max.x-p.bounds.min.x)*b,y:(p.bounds.max.y-p.bounds.min.y)*c},bodyB:q,pointB:{x:(q.bounds.max.x-q.bounds.min.x)*l,y:(q.bounds.max.y-q.bounds.min.y)*g}},r);k.addConstraint(a,f.create(p))}a.label+=" Chain";return a};a.mesh=function(a,b,c,l,g){var d=a.bodies,m,h;for(m=0;m<c;m++){for(h=1;h<b;h++){var p=d[h-1+m*b];var q=d[h+m*b];k.addConstraint(a,f.create(e.extend({bodyA:p,
bodyB:q},g)))}if(0<m)for(h=0;h<b;h++)p=d[h+(m-1)*b],q=d[h+m*b],k.addConstraint(a,f.create(e.extend({bodyA:p,bodyB:q},g))),l&&0<h&&(p=d[h-1+(m-1)*b],k.addConstraint(a,f.create(e.extend({bodyA:p,bodyB:q},g)))),l&&h<b-1&&(p=d[h+1+(m-1)*b],k.addConstraint(a,f.create(e.extend({bodyA:p,bodyB:q},g))))}a.label+=" Mesh";return a};a.pyramid=function(d,b,e,k,g,f,m){return a.stack(d,b,e,k,g,f,function(a,b,h,f,r,l){var t=Math.min(k,Math.ceil(e/2));a=r?r.bounds.max.x-r.bounds.min.x:0;if(!(f>t||(f=t-f,t=e-1-f,h<
f||h>t)))return 1===l&&c.translate(r,{x:(h+(1===e%2?1:-1))*a,y:0}),m(d+(r?h*a:0)+h*g,b,h,f,r,l)})};a.newtonsCradle=function(a,b,c,e,g){for(var d=k.create({label:"Newtons Cradle"}),m=0;m<c;m++){var h=u.circle(a+1.9*m*e,b+g,e,{inertia:Infinity,restitution:1,friction:0,frictionAir:1E-4,slop:1}),p=f.create({pointA:{x:a+1.9*m*e,y:b},bodyB:h});k.addBody(d,h);k.addConstraint(d,p)}return d};a.car=function(a,b,e,l,g){var d=c.nextGroup(!0),m=.5*-e+-20,h=.5*e- -20,p=k.create({label:"Car"});e=u.trapezoid(a,b,
e,l,.3,{collisionFilter:{group:d},friction:.01,chamfer:{radius:10}});l=u.circle(a+m,b+0,g,{collisionFilter:{group:d},friction:.8,density:.01});a=u.circle(a+h,b+0,g,{collisionFilter:{group:d},friction:.8,density:.01});m=f.create({bodyA:e,pointA:{x:m,y:0},bodyB:l,stiffness:.2});h=f.create({bodyA:e,pointA:{x:h,y:0},bodyB:a,stiffness:.2});k.addBody(p,e);k.addBody(p,l);k.addBody(p,a);k.addConstraint(p,m);k.addConstraint(p,h);return p};a.softBody=function(c,b,k,f,g,r,m,t,p,q){p=e.extend({inertia:Infinity},
p);q=e.extend({stiffness:.4},q);c=a.stack(c,b,k,f,g,r,function(a,b){return u.circle(a,b,t,p)});a.mesh(c,k,f,m,q);c.label="Soft Body";return c}})()},{"../body/Body":1,"../body/Composite":2,"../constraint/Constraint":12,"../core/Common":14,"./Bodies":21}],23:[function(l,n,w){var a={};n.exports=a;var k=l("../geometry/Vector"),f=l("../core/Common");(function(){a.fromVertices=function(a){for(var c={},e=0;e<a.length;e++){var d=(e+1)%a.length;d=k.normalise({x:a[d].y-a[e].y,y:a[e].x-a[d].x});var b=0===d.y?
Infinity:d.x/d.y;b=b.toFixed(3).toString();c[b]=d}return f.values(c)};a.rotate=function(a,c){if(0!==c)for(var e=Math.cos(c),d=Math.sin(c),b=0;b<a.length;b++){var k=a[b];var f=k.x*e-k.y*d;k.y=k.x*d+k.y*e;k.x=f}}})()},{"../core/Common":14,"../geometry/Vector":26}],24:[function(l,n,w){var a={};n.exports=a;(function(){a.create=function(k){var f={min:{x:0,y:0},max:{x:0,y:0}};k&&a.update(f,k);return f};a.update=function(a,f,e){a.min.x=Infinity;a.max.x=-Infinity;a.min.y=Infinity;a.max.y=-Infinity;for(var c=
0;c<f.length;c++){var k=f[c];k.x>a.max.x&&(a.max.x=k.x);k.x<a.min.x&&(a.min.x=k.x);k.y>a.max.y&&(a.max.y=k.y);k.y<a.min.y&&(a.min.y=k.y)}e&&(0<e.x?a.max.x+=e.x:a.min.x+=e.x,0<e.y?a.max.y+=e.y:a.min.y+=e.y)};a.contains=function(a,f){return f.x>=a.min.x&&f.x<=a.max.x&&f.y>=a.min.y&&f.y<=a.max.y};a.overlaps=function(a,f){return a.min.x<=f.max.x&&a.max.x>=f.min.x&&a.max.y>=f.min.y&&a.min.y<=f.max.y};a.translate=function(a,f){a.min.x+=f.x;a.max.x+=f.x;a.min.y+=f.y;a.max.y+=f.y};a.shift=function(a,f){var e=
a.max.x-a.min.x,c=a.max.y-a.min.y;a.min.x=f.x;a.max.x=f.x+e;a.min.y=f.y;a.max.y=f.y+c}})()},{}],25:[function(l,n,w){var a={};n.exports=a;l("../geometry/Bounds");(function(){a.pathToVertices=function(a,e){var c,f,d,b=[],h,l,g=0,r=0,m=0;e=e||15;var t=function(a,c,g){g=1===g%2&&1<g;if(!d||a!=d.x||c!=d.y){d&&g?(h=d.x,l=d.y):l=h=0;var e={x:h+a,y:l+c};if(g||!d)d=e;b.push(e);r=h+a;m=l+c}},p=function(a){var b=a.pathSegTypeAsLetter.toUpperCase();if("Z"!==b){switch(b){case "M":case "L":case "T":case "C":case "S":case "Q":r=
a.x;m=a.y;break;case "H":r=a.x;break;case "V":m=a.y}t(r,m,a.pathSegType)}};k(a);var q=a.getTotalLength();var n=[];for(c=0;c<a.pathSegList.numberOfItems;c+=1)n.push(a.pathSegList.getItem(c));for(f=n.concat();g<q;){c=a.getPathSegAtLength(g);c=n[c];if(c!=E){for(;f.length&&f[0]!=c;)p(f.shift());var E=c}switch(c.pathSegTypeAsLetter.toUpperCase()){case "C":case "T":case "S":case "Q":case "A":c=a.getPointAtLength(g),t(c.x,c.y,0)}g+=e}c=0;for(q=f.length;c<q;++c)p(f[c]);return b};var k=function(a){for(var e,
c,k,d,b,h,f=a.pathSegList,g=0,r=0,m=f.numberOfItems,t=0;t<m;++t){var p=f.getItem(t),q=p.pathSegTypeAsLetter;if(/[MLHVCSQTA]/.test(q))"x"in p&&(g=p.x),"y"in p&&(r=p.y);else switch("x1"in p&&(k=g+p.x1),"x2"in p&&(b=g+p.x2),"y1"in p&&(d=r+p.y1),"y2"in p&&(h=r+p.y2),"x"in p&&(g+=p.x),"y"in p&&(r+=p.y),q){case "m":f.replaceItem(a.createSVGPathSegMovetoAbs(g,r),t);break;case "l":f.replaceItem(a.createSVGPathSegLinetoAbs(g,r),t);break;case "h":f.replaceItem(a.createSVGPathSegLinetoHorizontalAbs(g),t);break;
case "v":f.replaceItem(a.createSVGPathSegLinetoVerticalAbs(r),t);break;case "c":f.replaceItem(a.createSVGPathSegCurvetoCubicAbs(g,r,k,d,b,h),t);break;case "s":f.replaceItem(a.createSVGPathSegCurvetoCubicSmoothAbs(g,r,b,h),t);break;case "q":f.replaceItem(a.createSVGPathSegCurvetoQuadraticAbs(g,r,k,d),t);break;case "t":f.replaceItem(a.createSVGPathSegCurvetoQuadraticSmoothAbs(g,r),t);break;case "a":f.replaceItem(a.createSVGPathSegArcAbs(g,r,p.r1,p.r2,p.angle,p.largeArcFlag,p.sweepFlag),t);break;case "z":case "Z":g=
e,r=c}if("M"==q||"m"==q)e=g,c=r}}})()},{"../geometry/Bounds":24}],26:[function(l,n,w){var a={};n.exports=a;(function(){a.create=function(a,f){return{x:a||0,y:f||0}};a.clone=function(a){return{x:a.x,y:a.y}};a.magnitude=function(a){return Math.sqrt(a.x*a.x+a.y*a.y)};a.magnitudeSquared=function(a){return a.x*a.x+a.y*a.y};a.rotate=function(a,f){var e=Math.cos(f),c=Math.sin(f);return{x:a.x*e-a.y*c,y:a.x*c+a.y*e}};a.rotateAbout=function(a,f,e,c){var k=Math.cos(f);f=Math.sin(f);c||(c={});var d=e.x+((a.x-
e.x)*k-(a.y-e.y)*f);c.y=e.y+((a.x-e.x)*f+(a.y-e.y)*k);c.x=d;return c};a.normalise=function(k){var f=a.magnitude(k);return 0===f?{x:0,y:0}:{x:k.x/f,y:k.y/f}};a.dot=function(a,f){return a.x*f.x+a.y*f.y};a.cross=function(a,f){return a.x*f.y-a.y*f.x};a.cross3=function(a,f,e){return(f.x-a.x)*(e.y-a.y)-(f.y-a.y)*(e.x-a.x)};a.add=function(a,f,e){e||(e={});e.x=a.x+f.x;e.y=a.y+f.y;return e};a.sub=function(a,f,e){e||(e={});e.x=a.x-f.x;e.y=a.y-f.y;return e};a.mult=function(a,f){return{x:a.x*f,y:a.y*f}};a.div=
function(a,f){return{x:a.x/f,y:a.y/f}};a.perp=function(a,f){f=!0===f?-1:1;return{x:f*-a.y,y:f*a.x}};a.neg=function(a){return{x:-a.x,y:-a.y}};a.angle=function(a,f){return Math.atan2(f.y-a.y,f.x-a.x)};a._temp=[a.create(),a.create(),a.create(),a.create(),a.create(),a.create()]})()},{}],27:[function(l,n,w){var a={};n.exports=a;var k=l("../geometry/Vector"),f=l("../core/Common");(function(){a.create=function(a,c){for(var e=[],d=0;d<a.length;d++){var b=a[d];e.push({x:b.x,y:b.y,index:d,body:c,isInternal:!1})}return e};
a.fromPath=function(e,c){var f=[];e.replace(/L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/ig,function(a,b,c){f.push({x:parseFloat(b),y:parseFloat(c)})});return a.create(f,c)};a.centre=function(e){for(var c=a.area(e,!0),f={x:0,y:0},d,b,h=0;h<e.length;h++)b=(h+1)%e.length,d=k.cross(e[h],e[b]),d=k.mult(k.add(e[h],e[b]),d),f=k.add(f,d);return k.div(f,6*c)};a.mean=function(a){for(var c={x:0,y:0},e=0;e<a.length;e++)c.x+=a[e].x,c.y+=a[e].y;return k.div(c,a.length)};a.area=function(a,c){for(var e=0,d=a.length-1,
b=0;b<a.length;b++)e+=(a[d].x-a[b].x)*(a[d].y+a[b].y),d=b;return c?e/2:Math.abs(e)/2};a.inertia=function(a,c){for(var e=0,d=0,b,f,l=0;l<a.length;l++)f=(l+1)%a.length,b=Math.abs(k.cross(a[f],a[l])),e+=b*(k.dot(a[f],a[f])+k.dot(a[f],a[l])+k.dot(a[l],a[l])),d+=b;return c/6*(e/d)};a.translate=function(a,c,f){var d;if(f)for(d=0;d<a.length;d++)a[d].x+=c.x*f,a[d].y+=c.y*f;else for(d=0;d<a.length;d++)a[d].x+=c.x,a[d].y+=c.y;return a};a.rotate=function(a,c,f){if(0!==c){var d=Math.cos(c);c=Math.sin(c);for(var b=
0;b<a.length;b++){var e=a[b],k=e.x-f.x,g=e.y-f.y;e.x=f.x+(k*d-g*c);e.y=f.y+(k*c+g*d)}return a}};a.contains=function(a,c){for(var e=0;e<a.length;e++){var d=a[e],b=a[(e+1)%a.length];if(0<(c.x-d.x)*(b.y-d.y)+(c.y-d.y)*(d.x-b.x))return!1}return!0};a.scale=function(e,c,f,d){if(1===c&&1===f)return e;d=d||a.centre(e);for(var b,h=0;h<e.length;h++)b=e[h],b=k.sub(b,d),e[h].x=d.x+b.x*c,e[h].y=d.y+b.y*f;return e};a.chamfer=function(a,c,l,d,b){c=c||[8];c.length||(c=[c]);l="undefined"!==typeof l?l:-1;d=d||2;b=
b||14;for(var e=[],n=0;n<a.length;n++){var g=a[0<=n-1?n-1:a.length-1],r=a[n],m=a[(n+1)%a.length],t=c[n<c.length?n:c.length-1];if(0===t)e.push(r);else{g=k.normalise({x:r.y-g.y,y:g.x-r.x});var p=k.normalise({x:m.y-r.y,y:r.x-m.x}),q=Math.sqrt(2*Math.pow(t,2));m=k.mult(f.clone(g),t);var u=k.normalise(k.mult(k.add(g,p),.5));r=k.sub(r,k.mult(u,q));q=l;-1===l&&(q=1.75*Math.pow(t,.32));q=f.clamp(q,d,b);1===q%2&&(q+=1);t=Math.acos(k.dot(g,p))/q;for(g=0;g<q;g++)e.push(k.add(k.rotate(m,t*g),r))}}return e};a.clockwiseSort=
function(e){var c=a.mean(e);e.sort(function(a,d){return k.angle(c,a)-k.angle(c,d)});return e};a.isConvex=function(a){var c=0,e=a.length,d;if(3>e)return null;for(d=0;d<e;d++){var b=(d+1)%e;var f=(d+2)%e;var k=(a[b].x-a[d].x)*(a[f].y-a[b].y);k-=(a[b].y-a[d].y)*(a[f].x-a[b].x);0>k?c|=1:0<k&&(c|=2);if(3===c)return!1}return 0!==c?!0:null};a.hull=function(a){var c=[],e=[],d,b;a=a.slice(0);a.sort(function(a,b){var c=a.x-b.x;return 0!==c?c:a.y-b.y});for(b=0;b<a.length;b++){for(d=a[b];2<=e.length&&0>=k.cross3(e[e.length-
2],e[e.length-1],d);)e.pop();e.push(d)}for(b=a.length-1;0<=b;b--){for(d=a[b];2<=c.length&&0>=k.cross3(c[c.length-2],c[c.length-1],d);)c.pop();c.push(d)}c.pop();e.pop();return c.concat(e)}})()},{"../core/Common":14,"../geometry/Vector":26}],28:[function(l,n,w){n=n.exports={};n.version="master";n.Body=l("../body/Body");n.Composite=l("../body/Composite");n.World=l("../body/World");n.Contact=l("../collision/Contact");n.Detector=l("../collision/Detector");n.Grid=l("../collision/Grid");n.Pairs=l("../collision/Pairs");
n.Pair=l("../collision/Pair");n.Query=l("../collision/Query");n.Resolver=l("../collision/Resolver");n.SAT=l("../collision/SAT");n.Constraint=l("../constraint/Constraint");n.MouseConstraint=l("../constraint/MouseConstraint");n.Common=l("../core/Common");n.Engine=l("../core/Engine");n.Events=l("../core/Events");n.Mouse=l("../core/Mouse");n.Runner=l("../core/Runner");n.Sleeping=l("../core/Sleeping");n.Bodies=l("../factory/Bodies");n.Composites=l("../factory/Composites");n.Axes=l("../geometry/Axes");
n.Bounds=l("../geometry/Bounds");n.Svg=l("../geometry/Svg");n.Vector=l("../geometry/Vector");n.Vertices=l("../geometry/Vertices");n.Render=l("../render/Render");n.RenderPixi=l("../render/RenderPixi");n.World.add=n.Composite.add;n.World.remove=n.Composite.remove;n.World.addComposite=n.Composite.addComposite;n.World.addBody=n.Composite.addBody;n.World.addConstraint=n.Composite.addConstraint;n.World.clear=n.Composite.clear;n.Engine.run=n.Runner.run},{"../body/Body":1,"../body/Composite":2,"../body/World":3,
"../collision/Contact":4,"../collision/Detector":5,"../collision/Grid":6,"../collision/Pair":7,"../collision/Pairs":8,"../collision/Query":9,"../collision/Resolver":10,"../collision/SAT":11,"../constraint/Constraint":12,"../constraint/MouseConstraint":13,"../core/Common":14,"../core/Engine":15,"../core/Events":16,"../core/Metrics":17,"../core/Mouse":18,"../core/Runner":19,"../core/Sleeping":20,"../factory/Bodies":21,"../factory/Composites":22,"../geometry/Axes":23,"../geometry/Bounds":24,"../geometry/Svg":25,
"../geometry/Vector":26,"../geometry/Vertices":27,"../render/Render":29,"../render/RenderPixi":30}],29:[function(l,n,w){var a={};n.exports=a;var k=l("../core/Common"),f=l("../body/Composite"),e=l("../geometry/Bounds"),c=l("../core/Events"),u=l("../collision/Grid"),d=l("../geometry/Vector");(function(){if("undefined"!==typeof window){var b=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(a){window.setTimeout(function(){a(k.now())},
1E3/60)};var h=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame}a.create=function(b){var c=k.extend({controller:a,engine:null,element:null,canvas:null,mouse:null,frameRequestId:null,options:{width:800,height:600,pixelRatio:1,background:"#fafafa",wireframeBackground:"#222",hasBounds:!!b.bounds,enabled:!0,wireframes:!0,showSleeping:!0,showDebug:!1,showBroadphase:!1,showBounds:!1,showVelocity:!1,showCollisions:!1,showSeparations:!1,
showAxes:!1,showPositions:!1,showAngleIndicator:!1,showIds:!1,showShadows:!1,showVertexNumbers:!1,showConvexHulls:!1,showInternalEdges:!1,showMousePosition:!1}},b);c.canvas&&(c.canvas.width=c.options.width||c.canvas.width,c.canvas.height=c.options.height||c.canvas.height);c.mouse=b.mouse;c.engine=b.engine;c.canvas=c.canvas||l(c.options.width,c.options.height);c.context=c.canvas.getContext("2d");c.textures={};c.bounds=c.bounds||{min:{x:0,y:0},max:{x:c.canvas.width,y:c.canvas.height}};1!==c.options.pixelRatio&&
a.setPixelRatio(c,c.options.pixelRatio);k.isElement(c.element)?c.element.appendChild(c.canvas):k.log("Render.create: options.element was undefined, render.canvas was created but not appended","warn");return c};a.run=function(c){(function t(d){c.frameRequestId=b(t);a.world(c)})()};a.stop=function(a){h(a.frameRequestId)};a.setPixelRatio=function(a,b){var c=a.options,d=a.canvas;if("auto"===b){var g=d.getContext("2d");b=(window.devicePixelRatio||1)/(g.webkitBackingStorePixelRatio||g.mozBackingStorePixelRatio||
g.msBackingStorePixelRatio||g.oBackingStorePixelRatio||g.backingStorePixelRatio||1)}c.pixelRatio=b;d.setAttribute("data-pixel-ratio",b);d.width=c.width*b;d.height=c.height*b;d.style.width=c.width+"px";d.style.height=c.height+"px";a.context.scale(b,b)};a.world=function(b){var g=b.engine,m=g.world,h=b.canvas,k=b.context,l=b.options,n=f.allBodies(m);m=f.allConstraints(m);var v=l.wireframes?l.wireframeBackground:l.background,x=[],w=[],y={timestamp:g.timing.timestamp};c.trigger(b,"beforeRender",y);if(b.currentBackground!==
v){var G=v;/(jpg|gif|png)$/.test(v)&&(G="url("+v+")");b.canvas.style.background=G;b.canvas.style.backgroundSize="contain";b.currentBackground=v}k.globalCompositeOperation="source-in";k.fillStyle="transparent";k.fillRect(0,0,h.width,h.height);k.globalCompositeOperation="source-over";if(l.hasBounds){v=(b.bounds.max.x-b.bounds.min.x)/l.width;G=(b.bounds.max.y-b.bounds.min.y)/l.height;for(h=0;h<n.length;h++){var C=n[h];e.overlaps(C.bounds,b.bounds)&&x.push(C)}for(h=0;h<m.length;h++){n=m[h];C=n.bodyA;
var A=n.bodyB,z=n.pointA,B=n.pointB;C&&(z=d.add(C.position,n.pointA));A&&(B=d.add(A.position,n.pointB));z&&B&&(e.contains(b.bounds,z)||e.contains(b.bounds,B))&&w.push(n)}k.scale(1/v,1/G);k.translate(-b.bounds.min.x,-b.bounds.min.y)}else w=m,x=n;!l.wireframes||g.enableSleeping&&l.showSleeping?a.bodies(b,x,k):(l.showConvexHulls&&a.bodyConvexHulls(b,x,k),a.bodyWireframes(b,x,k));l.showBounds&&a.bodyBounds(b,x,k);(l.showAxes||l.showAngleIndicator)&&a.bodyAxes(b,x,k);l.showPositions&&a.bodyPositions(b,
x,k);l.showVelocity&&a.bodyVelocity(b,x,k);l.showIds&&a.bodyIds(b,x,k);l.showSeparations&&a.separations(b,g.pairs.list,k);l.showCollisions&&a.collisions(b,g.pairs.list,k);l.showVertexNumbers&&a.vertexNumbers(b,x,k);l.showMousePosition&&a.mousePosition(b,b.mouse,k);a.constraints(w,k);l.showBroadphase&&g.broadphase.controller===u&&a.grid(b,g.broadphase,k);l.showDebug&&a.debug(b,k);l.hasBounds&&k.setTransform(l.pixelRatio,0,0,l.pixelRatio,0,0);c.trigger(b,"afterRender",y)};a.debug=function(a,b){var c=
a.engine,d=c.metrics,g=a.options;f.allBodies(c.world);if(500<=c.timing.timestamp-(a.debugTimestamp||0)){var e="";d.timing&&(e+="fps: "+Math.round(d.timing.fps)+"    ");a.debugString=e;a.debugTimestamp=c.timing.timestamp}if(a.debugString)for(b.font="12px Arial",b.fillStyle=g.wireframes?"rgba(255,255,255,0.5)":"rgba(0,0,0,0.5)",c=a.debugString.split("\n"),d=0;d<c.length;d++)b.fillText(c[d],50,50+18*d)};a.constraints=function(a,b){for(var c=0;c<a.length;c++){var d=a[c];if(d.render.visible&&d.pointA&&
d.pointB){var e=d.bodyA,g=d.bodyB;e?(b.beginPath(),b.moveTo(e.position.x+d.pointA.x,e.position.y+d.pointA.y)):(b.beginPath(),b.moveTo(d.pointA.x,d.pointA.y));g?b.lineTo(g.position.x+d.pointB.x,g.position.y+d.pointB.y):b.lineTo(d.pointB.x,d.pointB.y);b.lineWidth=d.render.lineWidth;b.strokeStyle=d.render.strokeStyle;b.stroke()}}};a.bodyShadows=function(a,b,c){for(var d=0;d<b.length;d++){var e=b[d];if(e.render.visible){if(e.circleRadius)c.beginPath(),c.arc(e.position.x,e.position.y,e.circleRadius,0,
2*Math.PI);else{c.beginPath();c.moveTo(e.vertices[0].x,e.vertices[0].y);for(var g=1;g<e.vertices.length;g++)c.lineTo(e.vertices[g].x,e.vertices[g].y)}c.closePath();g=e.position.x-.5*a.options.width;e=e.position.y-.2*a.options.height;var m=Math.abs(g)+Math.abs(e);c.shadowColor="rgba(0,0,0,0.15)";c.shadowOffsetX=.05*g;c.shadowOffsetY=.05*e;c.shadowBlur=1+12*Math.min(1,m/1E3);c.fill();c.shadowColor=null;c.shadowOffsetX=null;c.shadowOffsetY=null;c.shadowBlur=null}}};a.bodies=function(a,b,c){var d=a.options,
e=d.showInternalEdges||!d.wireframes,g,f;for(g=0;g<b.length;g++){var m=b[g];if(m.render.visible)for(f=1<m.parts.length?1:0;f<m.parts.length;f++){var h=m.parts[f];if(h.render.visible){d.showSleeping&&m.isSleeping?c.globalAlpha=.5*h.render.opacity:1!==h.render.opacity&&(c.globalAlpha=h.render.opacity);if(h.render.sprite&&h.render.sprite.texture&&!d.wireframes){var k=h.render.sprite;var l=k.texture;var r=a.textures[l];r||(r=a.textures[l]=new Image,r.src=l);l=r;c.translate(h.position.x,h.position.y);
c.rotate(h.angle);c.drawImage(l,l.width*-k.xOffset*k.xScale,l.height*-k.yOffset*k.yScale,l.width*k.xScale,l.height*k.yScale);c.rotate(-h.angle);c.translate(-h.position.x,-h.position.y)}else{if(h.circleRadius)c.beginPath(),c.arc(h.position.x,h.position.y,h.circleRadius,0,2*Math.PI);else{c.beginPath();c.moveTo(h.vertices[0].x,h.vertices[0].y);for(k=1;k<h.vertices.length;k++)!h.vertices[k-1].isInternal||e?c.lineTo(h.vertices[k].x,h.vertices[k].y):c.moveTo(h.vertices[k].x,h.vertices[k].y),h.vertices[k].isInternal&&
!e&&c.moveTo(h.vertices[(k+1)%h.vertices.length].x,h.vertices[(k+1)%h.vertices.length].y);c.lineTo(h.vertices[0].x,h.vertices[0].y);c.closePath()}d.wireframes?(c.lineWidth=1,c.strokeStyle="#bbb"):(c.fillStyle=h.render.fillStyle,c.lineWidth=h.render.lineWidth,c.strokeStyle=h.render.strokeStyle,c.fill());c.stroke()}c.globalAlpha=1}}}};a.bodyWireframes=function(a,b,c){a=a.options.showInternalEdges;var d,e,g;c.beginPath();for(d=0;d<b.length;d++){var f=b[d];if(f.render.visible)for(g=1<f.parts.length?1:
0;g<f.parts.length;g++){var h=f.parts[g];c.moveTo(h.vertices[0].x,h.vertices[0].y);for(e=1;e<h.vertices.length;e++)!h.vertices[e-1].isInternal||a?c.lineTo(h.vertices[e].x,h.vertices[e].y):c.moveTo(h.vertices[e].x,h.vertices[e].y),h.vertices[e].isInternal&&!a&&c.moveTo(h.vertices[(e+1)%h.vertices.length].x,h.vertices[(e+1)%h.vertices.length].y);c.lineTo(h.vertices[0].x,h.vertices[0].y)}}c.lineWidth=1;c.strokeStyle="#bbb";c.stroke()};a.bodyConvexHulls=function(a,b,c){var d,e;c.beginPath();for(d=0;d<
b.length;d++)if(a=b[d],a.render.visible&&1!==a.parts.length){c.moveTo(a.vertices[0].x,a.vertices[0].y);for(e=1;e<a.vertices.length;e++)c.lineTo(a.vertices[e].x,a.vertices[e].y);c.lineTo(a.vertices[0].x,a.vertices[0].y)}c.lineWidth=1;c.strokeStyle="rgba(255,255,255,0.2)";c.stroke()};a.vertexNumbers=function(a,b,c){var d,e;for(a=0;a<b.length;a++){var g=b[a].parts;for(e=1<g.length?1:0;e<g.length;e++){var f=g[e];for(d=0;d<f.vertices.length;d++)c.fillStyle="rgba(255,255,255,0.2)",c.fillText(a+"_"+d,f.position.x+
.8*(f.vertices[d].x-f.position.x),f.position.y+.8*(f.vertices[d].y-f.position.y))}}};a.mousePosition=function(a,b,c){c.fillStyle="rgba(255,255,255,0.8)";c.fillText(b.position.x+"  "+b.position.y,b.position.x+5,b.position.y-5)};a.bodyBounds=function(a,b,c){a=a.options;c.beginPath();for(var d=0;d<b.length;d++)if(b[d].render.visible)for(var e=b[d].parts,g=1<e.length?1:0;g<e.length;g++){var f=e[g];c.rect(f.bounds.min.x,f.bounds.min.y,f.bounds.max.x-f.bounds.min.x,f.bounds.max.y-f.bounds.min.y)}c.strokeStyle=
a.wireframes?"rgba(255,255,255,0.08)":"rgba(0,0,0,0.1)";c.lineWidth=1;c.stroke()};a.bodyAxes=function(a,b,c){a=a.options;var d,e,g;c.beginPath();for(d=0;d<b.length;d++){var f=b[d];var h=f.parts;if(f.render.visible)if(a.showAxes)for(e=1<h.length?1:0;e<h.length;e++)for(f=h[e],g=0;g<f.axes.length;g++){var k=f.axes[g];c.moveTo(f.position.x,f.position.y);c.lineTo(f.position.x+20*k.x,f.position.y+20*k.y)}else for(e=1<h.length?1:0;e<h.length;e++)for(f=h[e],g=0;g<f.axes.length;g++)c.moveTo(f.position.x,f.position.y),
c.lineTo((f.vertices[0].x+f.vertices[f.vertices.length-1].x)/2,(f.vertices[0].y+f.vertices[f.vertices.length-1].y)/2)}a.wireframes?c.strokeStyle="indianred":(c.strokeStyle="rgba(0,0,0,0.8)",c.globalCompositeOperation="overlay");c.lineWidth=1;c.stroke();c.globalCompositeOperation="source-over"};a.bodyPositions=function(a,b,c){a=a.options;var d,e;c.beginPath();for(d=0;d<b.length;d++){var g=b[d];if(g.render.visible)for(e=0;e<g.parts.length;e++){var f=g.parts[e];c.arc(f.position.x,f.position.y,3,0,2*
Math.PI,!1);c.closePath()}}c.fillStyle=a.wireframes?"indianred":"rgba(0,0,0,0.5)";c.fill();c.beginPath();for(d=0;d<b.length;d++)g=b[d],g.render.visible&&(c.arc(g.positionPrev.x,g.positionPrev.y,2,0,2*Math.PI,!1),c.closePath());c.fillStyle="rgba(255,165,0,0.8)";c.fill()};a.bodyVelocity=function(a,b,c){c.beginPath();for(a=0;a<b.length;a++){var d=b[a];d.render.visible&&(c.moveTo(d.position.x,d.position.y),c.lineTo(d.position.x+2*(d.position.x-d.positionPrev.x),d.position.y+2*(d.position.y-d.positionPrev.y)))}c.lineWidth=
3;c.strokeStyle="cornflowerblue";c.stroke()};a.bodyIds=function(a,b,c){var d;for(a=0;a<b.length;a++)if(b[a].render.visible){var e=b[a].parts;for(d=1<e.length?1:0;d<e.length;d++){var g=e[d];c.font="12px Arial";c.fillStyle="rgba(255,255,255,0.5)";c.fillText(g.id,g.position.x+10,g.position.y-10)}}};a.collisions=function(a,b,c){a=a.options;var d,e;c.beginPath();for(e=0;e<b.length;e++){var g=b[e];if(g.isActive)for(d=0;d<g.activeContacts.length;d++){var f=g.activeContacts[d].vertex;c.rect(f.x-1.5,f.y-1.5,
3.5,3.5)}}c.fillStyle=a.wireframes?"rgba(255,255,255,0.7)":"orange";c.fill();c.beginPath();for(e=0;e<b.length;e++)if(g=b[e],g.isActive&&(d=g.collision,0<g.activeContacts.length)){f=g.activeContacts[0].vertex.x;var h=g.activeContacts[0].vertex.y;2===g.activeContacts.length&&(f=(g.activeContacts[0].vertex.x+g.activeContacts[1].vertex.x)/2,h=(g.activeContacts[0].vertex.y+g.activeContacts[1].vertex.y)/2);d.bodyB===d.supports[0].body||!0===d.bodyA.isStatic?c.moveTo(f-8*d.normal.x,h-8*d.normal.y):c.moveTo(f+
8*d.normal.x,h+8*d.normal.y);c.lineTo(f,h)}c.strokeStyle=a.wireframes?"rgba(255,165,0,0.7)":"orange";c.lineWidth=1;c.stroke()};a.separations=function(a,b,c){a=a.options;var d;c.beginPath();for(d=0;d<b.length;d++){var e=b[d];if(e.isActive){e=e.collision;var g=e.bodyA;var f=e.bodyB;var h=1;f.isStatic||g.isStatic||(h=.5);f.isStatic&&(h=0);c.moveTo(f.position.x,f.position.y);c.lineTo(f.position.x-e.penetration.x*h,f.position.y-e.penetration.y*h);h=1;f.isStatic||g.isStatic||(h=.5);g.isStatic&&(h=0);c.moveTo(g.position.x,
g.position.y);c.lineTo(g.position.x+e.penetration.x*h,g.position.y+e.penetration.y*h)}}c.strokeStyle=a.wireframes?"rgba(255,165,0,0.5)":"orange";c.stroke()};a.grid=function(a,b,c){c.strokeStyle=a.options.wireframes?"rgba(255,180,0,0.1)":"rgba(255,180,0,0.5)";c.beginPath();a=k.keys(b.buckets);for(var d=0;d<a.length;d++){var e=a[d];2>b.buckets[e].length||(e=e.split(","),c.rect(.5+parseInt(e[0],10)*b.bucketWidth,.5+parseInt(e[1],10)*b.bucketHeight,b.bucketWidth,b.bucketHeight))}c.lineWidth=1;c.stroke()};
a.inspector=function(a,b){var c=a.selected,d=a.render,e=d.options;e.hasBounds&&(b.scale(1/((d.bounds.max.x-d.bounds.min.x)/d.options.width),1/((d.bounds.max.y-d.bounds.min.y)/d.options.height)),b.translate(-d.bounds.min.x,-d.bounds.min.y));for(d=0;d<c.length;d++){var g=c[d].data;b.translate(.5,.5);b.lineWidth=1;b.strokeStyle="rgba(255,165,0,0.9)";b.setLineDash([1,2]);switch(g.type){case "body":g=g.bounds;b.beginPath();b.rect(Math.floor(g.min.x-3),Math.floor(g.min.y-3),Math.floor(g.max.x-g.min.x+6),
Math.floor(g.max.y-g.min.y+6));b.closePath();b.stroke();break;case "constraint":var f=g.pointA;g.bodyA&&(f=g.pointB);b.beginPath();b.arc(f.x,f.y,10,0,2*Math.PI);b.closePath();b.stroke()}b.setLineDash([]);b.translate(-.5,-.5)}null!==a.selectStart&&(b.translate(.5,.5),b.lineWidth=1,b.strokeStyle="rgba(255,165,0,0.6)",b.fillStyle="rgba(255,165,0,0.1)",g=a.selectBounds,b.beginPath(),b.rect(Math.floor(g.min.x),Math.floor(g.min.y),Math.floor(g.max.x-g.min.x),Math.floor(g.max.y-g.min.y)),b.closePath(),b.stroke(),
b.fill(),b.translate(-.5,-.5));e.hasBounds&&b.setTransform(1,0,0,1,0,0)};var l=function(a,b){var c=document.createElement("canvas");c.width=a;c.height=b;c.oncontextmenu=function(){return!1};c.onselectstart=function(){return!1};return c}})()},{"../body/Composite":2,"../collision/Grid":6,"../core/Common":14,"../core/Events":16,"../geometry/Bounds":24,"../geometry/Vector":26}],30:[function(l,n,w){var a={};n.exports=a;var k=l("../body/Composite"),f=l("../core/Common");(function(){if("undefined"!==typeof window){var e=
window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(a){window.setTimeout(function(){a(f.now())},1E3/60)};var c=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame}a.create=function(c){f.log("RenderPixi.create: Matter.RenderPixi is deprecated (see docs)","warn");var b=f.extend({controller:a,engine:null,element:null,frameRequestId:null,canvas:null,
renderer:null,container:null,spriteContainer:null,pixiOptions:null,options:{width:800,height:600,background:"#fafafa",wireframeBackground:"#222",hasBounds:!1,enabled:!0,wireframes:!0,showSleeping:!0,showDebug:!1,showBroadphase:!1,showBounds:!1,showVelocity:!1,showCollisions:!1,showAxes:!1,showPositions:!1,showAngleIndicator:!1,showIds:!1,showShadows:!1}},c),d=!b.options.wireframes&&"transparent"===b.options.background;b.pixiOptions=b.pixiOptions||{view:b.canvas,transparent:d,antialias:!0,backgroundColor:c.background};
b.mouse=c.mouse;b.engine=c.engine;b.renderer=b.renderer||new PIXI.WebGLRenderer(b.options.width,b.options.height,b.pixiOptions);b.container=b.container||new PIXI.Container;b.spriteContainer=b.spriteContainer||new PIXI.Container;b.canvas=b.canvas||b.renderer.view;b.bounds=b.bounds||{min:{x:0,y:0},max:{x:b.options.width,y:b.options.height}};b.textures={};b.sprites={};b.primitives={};b.container.addChild(b.spriteContainer);f.isElement(b.element)?b.element.appendChild(b.canvas):f.log('No "render.element" passed, "render.canvas" was not inserted into document.',
"warn");b.canvas.oncontextmenu=function(){return!1};b.canvas.onselectstart=function(){return!1};return b};a.run=function(c){(function v(d){c.frameRequestId=e(v);a.world(c)})()};a.stop=function(a){c(a.frameRequestId)};a.clear=function(a){for(var b=a.container,c=a.spriteContainer;b.children[0];)b.removeChild(b.children[0]);for(;c.children[0];)c.removeChild(c.children[0]);c=a.sprites["bg-0"];a.textures={};a.sprites={};a.primitives={};(a.sprites["bg-0"]=c)&&b.addChildAt(c,0);a.container.addChild(a.spriteContainer);
a.currentBackground=null;b.scale.set(1,1);b.position.set(0,0)};a.setBackground=function(a,b){if(a.currentBackground!==b){var c=b.indexOf&&-1!==b.indexOf("#"),d=a.sprites["bg-0"];c?(c=f.colorToNumber(b),a.renderer.backgroundColor=c,d&&a.container.removeChild(d)):d||(d=l(a,b),d=a.sprites["bg-0"]=new PIXI.Sprite(d),d.position.x=0,d.position.y=0,a.container.addChildAt(d,0));a.currentBackground=b}};a.world=function(c){var b=c.engine.world,d=c.renderer,e=c.container,g=c.options,f=k.allBodies(b);b=k.allConstraints(b);
var l=[];g.wireframes?a.setBackground(c,g.wireframeBackground):a.setBackground(c,g.background);var n=(c.bounds.max.x-c.bounds.min.x)/c.options.width,p=(c.bounds.max.y-c.bounds.min.y)/c.options.height;if(g.hasBounds){for(g=0;g<f.length;g++){var q=f[g];q.render.sprite.visible=Bounds.overlaps(q.bounds,c.bounds)}for(g=0;g<b.length;g++){q=b[g];var u=q.bodyA,w=q.bodyB,x=q.pointA,D=q.pointB;u&&(x=Vector.add(u.position,q.pointA));w&&(D=Vector.add(w.position,q.pointB));x&&D&&(Bounds.contains(c.bounds,x)||
Bounds.contains(c.bounds,D))&&l.push(q)}e.scale.set(1/n,1/p);e.position.set(1/n*-c.bounds.min.x,1/p*-c.bounds.min.y)}else l=b;for(g=0;g<f.length;g++)a.body(c,f[g]);for(g=0;g<l.length;g++)a.constraint(c,l[g]);d.render(e)};a.constraint=function(a,b){var c=b.bodyA,d=b.bodyB,e=b.pointA,k=b.pointB,l=a.container,n=b.render,p="c-"+b.id,q=a.primitives[p];q||(q=a.primitives[p]=new PIXI.Graphics);n.visible&&b.pointA&&b.pointB?(-1===f.indexOf(l.children,q)&&l.addChild(q),q.clear(),q.beginFill(0,0),q.lineStyle(n.lineWidth,
f.colorToNumber(n.strokeStyle),1),c?q.moveTo(c.position.x+e.x,c.position.y+e.y):q.moveTo(e.x,e.y),d?q.lineTo(d.position.x+k.x,d.position.y+k.y):q.lineTo(k.x,k.y),q.endFill()):q.clear()};a.body=function(a,b){var c=b.render;if(c.visible)if(c.sprite&&c.sprite.texture){var d="b-"+b.id,e=a.sprites[d],k=a.spriteContainer;if(!e){e=a.sprites;var m=l(a,b.render.sprite.texture);m=new PIXI.Sprite(m);m.anchor.x=b.render.sprite.xOffset;m.anchor.y=b.render.sprite.yOffset;e=e[d]=m}-1===f.indexOf(k.children,e)&&
k.addChild(e);e.position.x=b.position.x;e.position.y=b.position.y;e.rotation=b.angle;e.scale.x=c.sprite.xScale||1;e.scale.y=c.sprite.yScale||1}else{c="b-"+b.id;k=a.primitives[c];d=a.container;if(!k){k=a.primitives;e=b.render;m=a.options;var n=new PIXI.Graphics,p=f.colorToNumber(e.fillStyle),q=f.colorToNumber(e.strokeStyle),u=f.colorToNumber(e.strokeStyle),w=f.colorToNumber("#bbb"),x=f.colorToNumber("#CD5C5C");n.clear();for(var D=1<b.parts.length?1:0;D<b.parts.length;D++){var y=b.parts[D];m.wireframes?
(n.beginFill(0,0),n.lineStyle(1,w,1)):(n.beginFill(p,1),n.lineStyle(e.lineWidth,q,1));n.moveTo(y.vertices[0].x-b.position.x,y.vertices[0].y-b.position.y);for(var G=1;G<y.vertices.length;G++)n.lineTo(y.vertices[G].x-b.position.x,y.vertices[G].y-b.position.y);n.lineTo(y.vertices[0].x-b.position.x,y.vertices[0].y-b.position.y);n.endFill();if(m.showAngleIndicator||m.showAxes)n.beginFill(0,0),m.wireframes?n.lineStyle(1,x,1):n.lineStyle(1,u),n.moveTo(y.position.x-b.position.x,y.position.y-b.position.y),
n.lineTo((y.vertices[0].x+y.vertices[y.vertices.length-1].x)/2-b.position.x,(y.vertices[0].y+y.vertices[y.vertices.length-1].y)/2-b.position.y),n.endFill()}k=k[c]=n;k.initialAngle=b.angle}-1===f.indexOf(d.children,k)&&d.addChild(k);k.position.x=b.position.x;k.position.y=b.position.y;k.rotation=b.angle-k.initialAngle}};var l=function(a,b){var c=a.textures[b];c||(c=a.textures[b]=PIXI.Texture.fromImage(b));return c}})()},{"../body/Composite":2,"../core/Common":14}]},{},[28])(28)});
!function(a){a.owlData={lang:{lang:"en",fn:function(b,c,a){this[b][c].fn=function(a,b){return this[a][b]};return this[b][c].fn(a,this.lang)},guiInfo:{buttonMenu:{detail:{id:" Pilih menu untuk melihat informasi statistik Pahlawan, Tower atau Musuh",en:" Select information menu to look detail your hero's stat"}},chooseMap:{detail:{id:" Pilih Peta, Tiap peta memiliki karakteristik, baik lingkungan dan Jenis Tower untuk dilindungi dari serangan musuh",en:" Choose a map, each map has its own characteristic ex, environtments or towers"}},
chooseHero:{detail:{id:" Pilih Salah satu Pemimpin Pahlawan, Pahlawan yang terpilih akan menjad LEADER Kelompok",en:" Select your favorite hero on the list, a selected hero will become a leader from a party  "}},tapCharacter:{detail:{id:" Tap / Klik untuk melihat statistik dan kemampuan ( skill ) yang di miliki setiap karakter",en:" Each character has its unique stat, tap to look detail about its stat"}},tapSkill:{detail:{id:" Tap / Klik untuk melihat lebih detail salah satu skill / tingkat kesulitan dari karakter ini",
en:" Tap to look detail about infromations, skills or level of a selected character"}},randomHard:{detail:{id:" Tap / Klik untuk mengacak, musuh akan diacak berdasarkan tingkat kesulitan yang tinggi",en:" Tap to suffle, you will play hard, the emenies will generate randomly"}},randomMed:{detail:{id:" Tap / Klik untuk mengacak, musuh akan diacak berdasarkan tingkat kesulitan yang sedang",en:" Tap to suffle, you will play moderate, the emenies will generate randomly"}},randomEas:{detail:{id:" Tap / Klik untuk mengacak, musuh akan diacak berdasarkan tingkat kesulitan yang mudah",
en:" Tap to suffle, you will play easy, the emenies will generate randomly"}},chooseVillant:{detail:{id:" Tap / Klik untuk memilih musuh tertentu / Custom",en:" Tap to choose a spesific enemy on the pop-up window"}},potionHPattach:{detail:{id:" Untuk menyembuhkan HP secara otomatis, pastikan HP potion ter-isi, jika karakter tidak memiliki potion baik yang terattached atau yang ada inventori anda dapat membelinya di toko. Catatan : terdapat jenis potion yang berbeda-beda dengan penyembuhan yang berbeda juga.",
en:" To recovery character's HP automaticly, Make sure HP Potion is attached to its slot, if selected character doesnt have attached potions or no potion left on the inventory, you can buy it from the shop, note : each potion at shop it has different effect while healing a target, you can tap and hold to see its detail"}},potionMPattach:{detail:{id:" Untuk menyembuhkan MP secara otomatis, pastikan MP potion ter-isi, jika karakter tidak memiliki potion baik yang terattached atau yang ada inventori anda dapat membelinya di toko. Catatan : terdapat jenis potion yang berbeda-beda dengan penyembuhan yang berbeda juga.",
en:" To recovery character's MP automaticly, Make sure MP Potion is attached to its slot, if selected character doesnt have attached potions or no potion left on the inventory, you can buy it from the shop, note : each potion at shop it has different effect while healing a target, you can tap and hold to see its detail"}},guiMenuButton:{detail:{id:" Tap / Pilih menu untuk melihat inventori dan skill dari karakter terpilih, anda juga dapat mengatur performa game untuk meningkatkan kualitas permainan, dan juga audio suara",
en:" Select menu to look a selected character's inventory and skills, you can also choose setting and tap the game performance to increase fps of your gameplay"}},guiShopButton:{detail:{id:" Tap / Pilih Toko untuk membeli kebutuhan untuk karakter, terdapat beragam jenis item yang dapat membuat karakter anda jadi lebih kuat",en:" Select Shop to buy enquipments for your characters need, at the shop you will find many items to make your characters more strong"}},guiMiningButton:{detail:{id:" Tap / Pilih Menambang jika anda membutukan GOLD, gold dibutuhkan untuk membeli beragam jenis item yang ada di toko, catatan : anda membutuhkan koneksi internet untuk dapat menambang",
en:" Select Mining if you need more gold, GOLD is required to buy your character needs such as equpements, potions and more, note : to perform this action you will need internet connection "}},guiInfoRemainingButton:{detail:{id:" Tap / Pilih Quest untuk melihat jumlah musuh atau tower tesisa jika anda ingin melihat status permainan yang sedang berjalan",en:" Select Quest to look your quests, when you tap and you will see how many towers or enemies left, when the towers destroyed you lose and when no more enemies left you win"}},
guiAttackNavButton:{detail:{id:" Pilih musuh lalu Tap Untuk memerintakan karakter menyerang musuh secara auto",en:" Select target or enemy then tap to order to your character to auto attack"}},guiAutoSkillButton:{detail:{id:" Tap untuk memerintakan karakter menyerang secara auto dan mengkombinaksikannya dengan skill",en:" Select target or enemy then tap to order to your character to auto attack and combined with auto skill"}},guiAutoSwitchButton:{detail:{id:" Tap untuk menukar ( switch ) dengan hero lain, semua inventori dan skill akan juga ikut berubah, Catatan : Leader tetap akan memimpin parti",
en:" Tap to switch to other hero, the items at your character's inventory and skills will also change, note : party leader will remain unchanged"}},guiAutoSwitchSkillButton:{detail:{id:" Tap untuk menukar ( switch ) dengan skill lain, terkadang setiap hero memiliki lebih dari 3 tiga skill",en:" Tap to switch to hidden slots skill, sometimes a selected hero has more than three skills"}},guiVirtualControlButton:{detail:{id:" Tap dan tekan, Gunakan virtual kontrol untuk mengendalikan karakter yang dipilih",
en:" Tap and hold virtual control to control your hero  "}},guiMainCharaButton:{detail:{id:" Ini adalah karakter Pemimpin yang mempunya simbol 'L' di sisi kiri atas, semua anggota parti akan mengikuti pemimpin baik mundur, bertahan ataupun menyerang, jika pemimpin kemompok mati maka permainan akan berakhir",en:" this is your character leader, she got 'L' Simbol on the left-top, each member of party will follow the leader even though the leader want to retreat, defending or attacking, if the leader is dead the game is over"}},
guiSupportCharaButton:{detail:{id:" Ini adalah karakter pendukung, salah satu hero yang akan membantu karakter utama, anda juga dapat mengendalikan / memainkan karakter pendukung dengan men-tap '...' ganti-karakter di bagian  pojok kanan bawah",en:" This is your support character,' this hero who will support your main character, you can also control this character by tap  '...' button ( switch button )"}}},gui:{charaGUI:{magicDef:{id:" Pertahanan Magic ",en:" Magic Defense "},physicalDef:{id:" Pertahanan Fisik ",
en:" Physcal Resistance"},rangeDmg:{id:" Serangan Jauh ",en:" Range Damage"},meleeDmg:{id:" Serangan Dekat ",en:" Melee Damage "},name:{id:" Nama ",en:" Name "},ability:{id:" Kemampuan Permanen ",en:" Permanent Abilities"},mpReq:{id:" MP yang dibutuhkan ",en:" Required Magic Points "},atkRange:{id:" Jarak Serangan ",en:" Attack Range"},hp:{id:" HP ",en:" HP "},mp:{id:" MP ",en:" MP "},skillTalent:{id:" Skill Dimiliki ",en:" Acquired Skills"},difficultyLevel:{id:"Tingkat Kesulitan",en:"Enemy Level"},
criticalChance:{id:"Peluang Kritikal",en:"Critical Chance"},critical:{id:" Kritikal",en:" Critical Hit"},block:{id:" Blok",en:" Block Chance"},avoidance:{id:" Hindaran",en:" Avoidance"},stun:{id:" Stun",en:" Stun"}},htmlGUI:{textInfoSuccess:{id:"Semua informasi yang berhubungan dengan game telah ditampilkan, anda dapat mengulangi informasi ini kembali pada menu setting dan pilih 'Ulangi Informasi Game'.",en:"All the informations which releated with this game have already displayed, you could repeat the informations again with clicking the setting menu and choose ' Repeat Game Information'"},
closeInfo:{id:" OK, Lewati ",en:" OK, Next"},towText:{id:" TOWER TERSISA",en:" TOWERS REMAINING"},enemyText:{id:" PARTI MUSUH TERSISA",en:" ENEMIES REMAINING"},exitAlertText:{id:" Apa kamu yakin, kamu ingin keluar dari permainan",en:" Are you sure, you want to exit the game "},appAlertText:{id:" Apa kamu yakin, kamu ingin keluar dari Aplikasi",en:" Are you sure, you want to exit from the Aplication "},itemAlertText:{id:" MENGEKSTRAK ITEM, ",en:"EXTRACTING ITEM"},itemAlertText2:{id:" ITEM INI AKAN DIGUNAKAN, APAKAH ANDA YAKIN ? ",
en:" ARE YOU SURE, THIS ITEM WILL BE USED,"},adsTitle:{id:" MEMUAT KONEKSI ",en:" CREATE CONNECTION"},miningTitle:{id:" MENAMBANG EMAS ",en:" GOLD MINING"},adsMining:{id:" Menambang emas dengan maksimum durasi 20 detik,jika kamu mencapai maksimun durasi 10000 EMAS yang akan didapatkan ( advertise ) ",en:" Maximum duration for mining is about 20 Second, if you reach maximum limit, you will get 10000 gold ( advertise )"},adsMiningB:{id:" Menambang emas dengan maksimum durasi 10 detik,jika kamu mencapai maksimun durasi 2000 EMAS yang akan didapatkan ( advertise ) ",
en:" Maximum duration for mining is about 10 Second, if you reach maximum limit, you will get 2000 gold ( advertise )"},facebookMining:{id:" Bantu Developer mengenalkan Game ini ke teman-teman Anda, 50000 EMAS yang akan didapatkan ",en:" Help game developer to introduce this game to your friends, 50000 gold you'll be rewarded"},buyButtonConfirm:{id:" BELI ",en:" BUY"},shopTitle:{id:" TOKO ",en:" SHOP"},itemDiscardText:{id:" APA KAMU YAKIN INGIN MEMBUANG ITEM YANG TELAH KAMU PILIH ? ",en:" Are you sure you want to discard this item "},
inventoryText:{id:" INVENTORI ",en:" INVENTORY "},statText:{id:" STAT KARAKTER ",en:" CHARACTER STAT"},itemInfoText:{id:" RINCIAN ITEM ",en:" ITEM DETAIL "},charaInfoText:{id:" KETERANGAN ",en:" INFORMATION "},controlChooseText:{id:" PILIH ",en:" SELECT"},controlMenuText:{id:" MENU ",en:" MENU "},performText:{id:" Performa Permainan ",en:" Performance "},soundText:{id:" Volume Suara ",en:" Sound "},tutorialText:{id:" Tutorial Bermain ",en:" Tutorial "},contributionText:{id:" Kontribusi ",en:" Contribution"},
exitGameText:{id:" Keluar Permainan ",en:" Exit Game"},infoMenuText:{id:" INFOMASI MENU ",en:" INFORMATION  MENU"},volumeHeadText:{id:" Volume Aksi ",en:" SOUND ACTION"},volumeContentText:{id:" Suara interaksi ketika NPC melakukan aksi, pilih off untuk menghentikan suara ",en:" The Sound Interaction while NPC Doing Actions, Set it off to mute the sounds "},volumeHeadText2:{id:" Volume Latar ",en:" Sound Background"},volumeContentText2:{id:" Suara latar, pilih off untuk menghentikan suara ",en:" Sound Background, Set it off to mute the sounds"},
infoHeadText:{id:" Informasi Permainan ",en:" Information Gameplay"},infoContentText:{id:" Untuk Pemain yang ingin mengulangi tutorial informasi game, Pilih ON, tutorial permainan akan diulangi setelah permainan yang sedang berjalan berakhir.",en:" For Player who want to repeat previous tutorial information of gameplay, set it ON, tutorial information will be repeated after player play a new game "},performHeadText:{id:" Ramuan Potion ",en:" Magic Potion"},performContentText:{id:" Membatasi Penyembuh pada tingkat tertentu untuk menghemat Potion ",
en:" When you drag and set it, it will be used as a restriction healing to save more your healing potions,"},performHeadText2:{id:" Performa Permainan ",en:" Performance Gameplay"},performContentText2:{id:" 'Pilih OFF' Meningkatkan Performa permainan atau mengurangi penggunaan memori dan CPU dengan mengurangi efek partikel dan audio ",en:" 'set it OFF', it will increase gameplay performance or reducing memory and cpu usage especially when player using too much particles and audio"},playGameText:{id:" MAINKAN GIM ",
en:" NEW GAME"},selectHeroText:{id:" PILIH PAHLAWAN ",en:" SELECT HERO"},selectMapText:{id:" PILIH PETA ",en:" SELECT MAP"},selectEnemyText:{id:" PILIH MUSUH ",en:" SELECT ENEMY"},mpNeed:{id:"Membutuhkan MP",en:"MP Required"},characterSkillText:{id:"SKILL KARAKTER",en:"CHARACTER SKILLS"},characterSkillText2:{id:" SKILL TERSEDIA ",en:" AVAILABLE SKILL"},nextMining:{id:"Menambang Dalam: ",en:"Next mining :"},waitMining:{id:"Kamu bisa menunggu sampai waktu loading selesai",en:"You have to wait till the loading time finished"}},
bgPop:{win:{id:"you-win",en:"you-win-en"},lose:{id:"you-lose",en:"you-lose-en"},towersLeft:{id:"eliminated-tower",en:"eliminated-tower-en"},enemiesLeft:{id:"eliminated-enemy",en:"eliminated-enemy-en"},bg:{id:"game-cover-id",en:"game-cover-en"}},internetConnection:{loss:{id:" Ops, Device tidak terhubung ke internet",en:" Ops, Device doesnt have internet connection"},serverFail:{id:" Ops maaf, Connection time out, silahkan coba lagi",en:" Ops sorry, the connection has timed out, please try again"},
adsFail:{id:" Iklan tidak tampil dikarenakan jaringan sibuk atau operator / apk tertentu memblokir iklan",en:" Ops sorry,  we find an error while retrieving the ads from server"},internetCheck:{id:" Mehubungi Server",en:" Connecting to server"}},goldMining:{addGold:{id:" Sisa emas berhasil di tambahkan pada inventori ",en:" gold has successfully been added to inventory "},detail:{id:" emas berhasil di tambahkan pada inventori ",en:" gold has successfully been added to inventory "},title:{id:"  MEMUAT IKLAN",
en:" LOADING ADS"},interruptA:{id:"  GOLD berhasil ditambang dalam durasi ",en:" GOLD  has successfully been mined and it takes "},interruptB:{id:"  Detik, ditambahkan ke inventori ",en:" Second, and has successfully been added to inventory "},second:{id:"  Detik ",en:" Second "}},addItemToInvt:{detail:{id:" Telah ditambahkan ke Inventori ",en:" has successfully been added to inventory"}},notEnoughGold:{detail:{id:"Gold, Tidak mencukupi untuk membeli item yang dipilih",en:"Not enough gold to buy a selected item "}},
itemRanger:{detail:{id:"Item ini hanya untuk karakter dengan tipe serangan jarak jauh",en:"Item can be equiped by a character which has a long-range attack type"}},itemLeader:{detail:{id:"Item ini hanya untuk pemimpin parti",en:"Item can be equiped by a leader from a party "}},pawnLimit:{detail:{id:"Jumlah parti telah melebihi batas",en:"Member Party has reached a limit"}},btnEndgame:{detail:{id:"Akhiri Permainan",en:"Exit Game"}},leaderDied:{detail:{id:"anda kalah, HERO LEADER telah mati",en:"you lose, Your leader party has been slain"}},
tapSkill:{detail:{id:"Tap musuh untuk mengaktifkan aksi skill",en:"Tap an enemy to active a selected skill"}},questAlert:{detail:{id:"Lindungi tower dari serangan invasi musuh",en:"Defend the towers from invaders"}},questAlertB:{detail:{id:"musuh tingkat ",en:" Enemy Level "}},questAlertC:{detail:{id:" telah mencoba menginvasi ",en:" has been spawned"}},attackAlert:{detail:{id:"Tidak ada musuh disekitar",en:"There is no enemy found nearby"}},accuredItem:{detail:{id:" mendapatkan ",en:" accured "}},
accuredItemB:{detail:{id:", dari ",en:", from "}},towerDied:{detail:{id:" 1 Tower telah hancur ",en:" A tower has destroyed "}}},items:{manaStrongPotion:{displayName:{id:"Ramuan mp tipe kuat",en:"Strong Magic Potion"},detail:{id:"Memulihkan MP 350 point, Cooldown 3.5s ",en:"Restore MP 350 Points, Cooldown 3.5s"}},manaMediumPotion:{displayName:{id:"Ramuan mp tipe sedang",en:"Medium Magic Potion"},detail:{id:"Memulihkan HP 200 point, Cooldown 3s  ",en:"Restore HP 200 Points, Cooldown 3s"}},manaPotion:{displayName:{id:"Ramuan mp tipe kecil",
en:"Small Magic Potion"},detail:{id:"Memulihkan MP 100 point, Cooldown 2s ",en:"Restore MP 100 Points, Cooldown 2s"}},healthStrongPotion:{displayName:{id:"Ramuan hp tipe kuat",en:"Strong Health Potions"},detail:{id:"Memulihkan MP 750 point, Cooldown 3.5s ",en:"Restore MP 750 points, cooldown 3.5s"}},healthMediumPotion:{displayName:{id:"Ramuan hp tipe sedang",en:"Medium Health Potions"},detail:{id:"Memulihkan HP 450 point, Cooldown 2.5s  ",en:"Restore MP 450 points, cooldown 3.5s"}},healthPotion:{displayName:{id:"Ramuan hp tipe kecil",
en:"Small Health Potions"},detail:{id:"Memulihkan HP 300 point, Cooldown 2s  ",en:"Restore MP 300 points, cooldown 3.5s"}},explosionRedBoom:{displayName:{id:"Boom ledakan merah",en:"Explosion Red Boom"},detail:{id:'Tipe boom ledakan yang menyebar, memberikan efek terbakar pada target, hanya dapat digunakan oleh ranger yang memiliki skill "throw boom"',en:" Explosion Red Boom is spreading boom, each of explosion boom will generate randomly debuff 'burning' to target, this skill can only be used by a character that has a skill 'throw boom'  "}},
explosionBlueBoom:{displayName:{id:"Boom Ledakan Biru",en:"Explosion Blue Boom"},detail:{id:'Tipe boom ledakan yang menyebar, memberikan efek stun hingga 10 ~ 15% pada target, hanya dapat digunakan oleh ranger yang memiliki skill "throw boom"',en:"Explosion Blue Boom is spreading boom, each of explosion boom will generate randomly stun effect to target , this skill can only be used by a character that has a skill 'throw boom'"}},blueJewel:{displayName:{id:"Gem anting biru",en:"Blue Jewel Earring"},
detail:{id:"Meningkatkan semua serangan 15% kepada target",en:"Character gain +15% all attack increased while wearing this item"}},redJewel:{displayName:{id:"Gem anting merah",en:"Red Jewel Earring"},detail:{id:"Meningkatkan hindaran 15% kepada target",en:"Character gain +15% avoidance increased while wearing this item"}},greenJewel:{displayName:{id:"Gem anting hijau",en:"Green Jewel Earring"},detail:{id:"Meningkatkan pertahanan 15% dan semua serangan meningkat 20% kepada seluruh parti, item hanya dapat digunakan untuk pemimpin",
en:"Character gain +15% all defense increased and all attack rise 20% to all member party, this item can only be used by a leader"}},ornamentGreen:{displayName:{id:"Batu Ornamen Bersinar",en:"Shiny stone ornament"},detail:{id:"Ornament dengan hiasan batu berwarna hijau dengan efek Meningkatkan blok 15% kepada target",en:"Shiny stone ornament is a light green stone, character gain +15% block chance increased"}},ornamentPurple:{displayName:{id:"Batu Ornamen Bersinar",en:"Shiny stone ornament"},detail:{id:"Ornament dengan hiasan batu berwarna ungu dengan efek Meningkatkan stun 15% kepada target",
en:"Shiny stone ornament is a light purple stone, it will give stun chance +15% increased to character"}},greenLightNecklace:{displayName:{id:"Gem kalung hijau terang",en:"Green Light Necklace"},detail:{id:"Mingkatkan Peluang Kritikal 15%",en:"While it is equiped the Character gain +15% critical chance increased"}},goldGemStone:{displayName:{id:"Batu mulia berwarna kuning",en:"Gold Gem Stone"},detail:{id:"Mingkatkan Pukulan Kritikal 34%",en:"While it's equiped the character gain  +15% critical hit"}},
redGemStone:{displayName:{id:"Batu mulia berwarna merah",en:"Red Gem Stone"},detail:{id:"Mingkatkan kesempatan pukulan kritikal 15%, dan pertahanan fisik 20% untuk semua anggota parti, item hanya dapat digunakan untuk pemimpin",en:"character gain critical chance 15% increased and all defense rise 20% to all member party, this item can only be used by a leader"}},golemSummoner:{displayName:{id:"Pemanggil Golem",en:"Golem Caller"},detail:{id:"Memanggil Familiar Tingkat C, GOLEM",en:"Summon a familiar level C, Golem"}},
sekletonSummoner:{displayName:{id:"Pemanggil Sekleton",en:" Sekleton Caller"},detail:{id:"Memanggil Familiar Tingkat C, SEKLETON",en:" Summon a familiar level C , SEKLETON"}}},skill:{powerAgility:{detail:{id:" memberikan buff 'AGIL TINGKAT I' kepada diri sendiri dengan efek mingkatkan pertahanan magic hingga 20%, dan kesempatan menghindar dari serangan hingga 10%, MP yang dibutuhkan 118 Poin dengan durasi 20s, cooldown 40s.",en:" Skill that added buff 'AGIL LEVEL I' to caster, it increases Magic Defense +20%, and also increases Avoidance +10%MP cost 118 points, skill duration 20s, Cooldown 40s"},
displayName:{id:" AGIL TINGKAT I",en:" AGIL LEVEL I"}},powerAgilityII:{detail:{id:" memberikan buff 'AGIL TINGKAT II' kepada diri sendiri dengan efek meningkatkan pertahanan magic hingga 25%, dan kesempatan menghindar dari serangan hingga 15%, kritikal terhadap target meningkat 65% ~ 101%, kesempatan kritikal 10% ~ 15% MP yang dibutuhkan 201 Poin dengan durasi 20s, cooldown 40s.",en:"Add a buff skill 'AGIL LEVEL II' to character, it increases +25% Magic Defense and avoidance +15%  and also increases both of critical Hit 65% ~ 101%, and Critical Chance 10% ~15%, MP Cost 201 points, buff duration 20s, cooldown 40s"},
displayName:{id:" AGIL TINGKAT II",en:" AGIL LEVEL III"}},powerAgilityIII:{detail:{id:" memberikan buff 'AGIL TINGKAT III' kepada diri sendiri dengan efek meningkatkan pertahanan magic hingga 25%, dan kesempatan menghindar dari serangan hingga 15%, kritikal terhadap target meningkat 192% ~ 225%, kesempatan kritikal 15% ~ 25% MP yang dibutuhkan 258 Poin dengan durasi 20s, cooldown 40s.",en:"Added buff 'AGIL LEVEL III' to caster, it increases +25% Magic Defense and avoidance +15%and also increases both of critical Hit 192% ~ 225% and critical Chance 15% ~ 25% , MP Cost 258 points, buff duration 20s, cooldown 40s"},
displayName:{id:" AGIL TINGKAT III",en:" AGIL LEVEL III"}},teleportation:{detail:{id:" Menteleportasi diri sendiri kepada target, MP yang dibutuhkan 91 Poin, cooldown 8.3s.",en:" Teleporting a Character to a selected target, MP Cost 91 points, cooldown 8.3s"},displayName:{id:" Teleportasi",en:" Teleportation"}},teleport:{detail:{id:" Menteleportasi diri sendiri kepada target, MP yang dibutuhkan 91 Poin, cooldown 8.3s.",en:" Teleporting Character to a selected target, MP Cost 91 points, cooldown 8.3s"},
displayName:{id:" Teleportasi",en:" Teleportation"}},mindControl:{detail:{id:" Memberikan debuff 'KONTROL PIKIRAN', memberikan efek memaksa Sekutu atau party untuk menyerang target tertentu, membutuhkan 200 MP,  cooldown 33s",en:" Skill That will give a debuff 'Mind Control',it will force allies or party member to attack spesific target, MP Cost 200 points, coolown 33s"},displayName:{id:" KONTROL PIKIRAN",en:" MIND CONTROL"}},sekletonSummoner:{detail:{id:" Memanggil familiar sekleton tingkat C, maximum memanggil 4 Familiar, 232 MP Dibutuhkan, cooldown 33s.",
en:" Summon a familiar Sekleton level C , Maximum summoing 4 Familiars, MP cost 232 points, cooldown 33s"},displayName:{id:" PEMANGIL GOLEM",en:" GOLEM CALLER"}},earthShake:{detail:{id:" Pukulan ledakan ke tanah di sertai gelombang kejut dengan radius 200, damage 350 ~ 420, Membutukan 211 Point MP, cooldown 20s ",en:" Explosion Punch to the ground, it will give a shock wave in 200 radius, Damage increased per-punch 350 ~ 450, MP Cost 211, cooldown 20s"},displayName:{id:" PUKULAN LEDAKAN",en:" EXPLOSION PUNCH"}},
earthQuake:{detail:{id:" Pukulan Beruntun ke tanah di sertai gelombang kejut dengan radius 200, damage 323 ~ 450, Membutukan 143 Point MP, cooldown 20s ",en:" Streak Punch to the ground it will give a shock wave in 200 radius, Damage increased 323 ~ 450 per-punch, MP cost 143 points, coolown 20s "},displayName:{id:" PUKULAN KEJUT",en:" STREAK PUNCH"}},golemSummoner:{detail:{id:" Memanggil familiar golem tingkat C, maximum memanggil 4 Familiar, 232 MP Dibutuhkan, cooldown 33s.",en:" Summoning familiar Golem Level C , Summon maximum 4 familiars, MP cost 232 points, cooldown 33s"},
displayName:{id:" PEMANGIL GOLEM",en:" GOLEM CALLER"}},bloodDrain:{detail:{id:" Memberikan debuff 'penghisap-darah' kepada musuh dengan lingkup luas, damage 520 ~ 570 per 1s,  mengkonversi hp musuh menjadi hp sendiri hingga 100%, dengan durasi 30s, 115 HP yang dibutuhkan cooldown 13.3s.",en:" it will give a debuff 'Bloodsukcer' to caster,  debuff will take effect to target in 150 radius, damage to target 520 - 570 per 1s. conversion damage to HP till 100%, buff duration to caster 30s, debuff duration to target 30s, cooldown 13.3s"},
displayName:{id:" PENGHISAP DARAH",en:" BLOODSUCKER"}},arrowRain:{detail:{id:" Serangan hujan panah pada area target dalam radius 150, damage rata-rata 76 - 132, Membutuhkan 315 MP, cooldown 30s.",en:" Rain of arrows skill that fires a number of arrows in the air to a selected target, damage per-arrow from 76 to 132 in 150 radius, HP cost 315 points, cooldown 30s"},displayName:{id:" HUJAN PANAH",en:" RAIN OF ARROWS"}},piercingShoot:{detail:{id:" Tembakan beruntun akurasi tinggi, damage rata-rata 355 - 538, 144 MP yang dibutuhkan, cooldown 5s.",
en:" A Powerfull shot it increases amount of ammos in a single shot, each ammo will take damage 355 ~ 538, MP cost 144 points, cooldown 5s"},displayName:{id:" TEMBAKAN MENUSUK",en:" PIERCHING SHOOT"}},piercingSpeed:{detail:{id:" Tusukan Pedang / tombak akurasi tinggi, damage rata-rata 565 - 820, 121 MP yang dibutuhkan, cooldown 13s.",en:" It increases the attack power of piercing sword, Damage from 565 to 820, MP cost 121 points, cooldown 13s, "},displayName:{id:" TUSUKAN CEPAT",en:" PIERCHING SWORD"}},
piercingSpear:{detail:{id:" Tusukan Tombak akurasi tinggi, damage rata-rata 750 - 1100, kritikal terhadap target meningkat 45% ~ 70%, kesempatan kritikal 15% ~ 25%, 211 MP yang dibutuhkan, cooldown 40s.",en:" It increases the attack power of piercing spear, Damage from 750 to 1100, critical chance to target 45% ~ 70% increased, MP cost 121 points, cooldown 13s. "},displayName:{id:" TUSUKAN TOMBAK",en:" PIERCHING SPEAR"}},growHowl:{detail:{id:" Memberikan buff 'Beresek-Aura' kepada party dan sekutu dengan efek meningkatkan semua serangan 40% ~ 60%  kepada target dengan durasi 30s, 253 MP yang dibutuhkan, cooldown 13.3s.",
en:" A buff will be affected to caster and allies that make all attack 40% ~ 60% increased and the aura also will be affected to allies in 200 radius, buff duration 30s, 253 MP Cost, cooldown 13.3s,"},displayName:{id:" BERESEK AURA",en:" BERESEK AURA"}},powerDefeneseIII:{detail:{id:" memberikan buff 'DEFENSE TINGKAT III' kepada diri sendiri dengan efek mingkatkan pertahanan fisik hingga 25%, dan kesempatan block dari serangan hingga 15%, kritikal terhadap target meningkat 152% ~ 245%, kesempatan kritikal 15% ~ 25% MP yang dibutuhkan 258 Poin dengan durasi 20s, cooldown 40s.",
en:" Add a buff to caster 'DEFENSE LEVEL III',it increases +25% physical resistance, and block chance to deal damage +15% increased, and also critical hit to enemy 152% ~ 245% increased, required MP 258 pointsbuff duration 20s, cooldown 40s"},displayName:{id:" DEFENSE TINGKAT III",en:" DEFENSE LEVEL III"}},powerDefeneseII:{detail:{id:" memberikan buff 'AGIL TINGKAT II' kepada diri sendiri dengan efek meningkatkan pertahanan fisik hingga 20%, dan kesempatan memblok dari serangan hingga 15%, kritikal terhadap target meningkat 77% ~ 113%, kesempatan kritikal 10% ~ 15% MP yang dibutuhkan 201 Poin dengan durasi 20s, cooldown 40s.",
en:" add a buff to caster 'DEFENSE LEVEL II', it increases 15 ~ 20% physical resistance,  and block chance to deal damage 15 ~ 20% increased, and also critical hit to enemy 77% ~ 113% increased, required MP 201 pointsbuff duration 20s, cooldown 40s"},displayName:{id:" DEFENSE TINGKAT II",en:" DEFENSE LEVEL II"}},powerDefenese:{detail:{id:" memberikan buff 'DEFENSE TINGKAT I' kepada diri sendiri dengan efek mingkatkan pertahanan fisik hingga 25%, dan kesempatan Blok dari serangan hingga 20%, MP yang dibutuhkan 118 Poin dengan durasi 20s, cooldown 40s.",
en:" add a buff to caster 'DEFENSE LEVEL I', it increases 10 ~ 15% physical resistance, and block chance to deal damage 10 ~ 15% increased, and also critical hit to enemy  77% ~ 113% increased, required MP 201 pointsbuff duration 20s, cooldown 40s"},displayName:{id:" DEFENSE TINGKAT I",en:" DEFENSE LEVEL I"}},bindingRoot:{detail:{id:" memberikan debuff 'AKAR IKAT' dengan memberikan efek membatasi gerakan para target durasi 30s, 188 MP dibutuhkan, cooldown 25s",en:" Binding Root is skill that reduce speed of movement until 75%, it affected to target 30s, 188 MP Cost, cooldown 25s"},
displayName:{id:" AKAR IKAT",en:" Binding Root"}},massHealing:{detail:{id:" memberikan buff 'PENYEMBUH MASAL' dengan memberikan efek menyembuhkan party dan sekutu pada area lingkup yang luas, merestorasi HP 185 ~ 251 per 1.6s, 279 MP dibutuhkan, cooldown 20s",en:" Add a buff 'Mass Healing' it will be affected to member party, and restore each target's HP  185 ~ 251 per 1.6s, 279 MP Cost, Cooldown 20s "},displayName:{id:" Penyembuh Masal",en:" Mass Healing"}},healing:{detail:{id:" Memberikan debuff 'PENYEMBUH' dengan memberikan efek Menyembuhkan diri sendiri, merestorasi HP 264 ~ 321 per 1.6s, 220 MP dibutuhkan, cooldown 20s",
en:" Add a buff 'Healing' to caster it affected restoring hp 264 ~ 321 per 1.6s, 220 MP cost, cooldown 20s "},displayName:{id:" Penyembuh",en:" Healing"}},abilitiesSteal:{detail:{id:" memberikan debuff 'PENCURI KEMAMPUAN' kepada target efek menurunkan kemampuan hindaran dan blok hingga 8% ~ 15%, cooldown 20s",en:" Add debuff 'Ability Steal', Target's abilities will be reduced significantly it will be affected for both of avoidance and block chance until 8% ~ 15%, cooldown 20s"},displayName:{id:" PENCURI KEMAMPUAN",
en:" ABILITY STEAL"}},bodyCharge:{detail:{id:" Amukan monster, dengan menyeruduk target, damage 440 ~ 670, 244 MP dibutuhkan, cooldown 13s",en:" Angry Monster, Butting Head to target, it takes deal damage 440 ~ 670, 240 MP Cost , cooldown 13s "},displayName:{id:" AMUKAN MONSTER",en:"  Butting Head "}},throwBoom:{detail:{id:" Serangan dengan lemparan boom pada target, ledakan mencapai 250 radius, besar luka dan debuff yang dihasilkan berdasarkan jenis boom yang dilempar, membutuhkan 235 MP, cooldown 8s",
en:" Throwing a boom to target, explosion will be spreading in 250 radius, deal damage and debuff are based on the types of boom, 235 MP cost, cooldown 8s"},displayName:{id:" PELEMPAR BOOM",en:"  Throw Boom "}},defenseSteal:{detail:{id:" memberikan debuff 'PENCURI PERTAHANAN' kepada target memberikan efek menurunkan pertahanan fisik dan pertahan magic hingga 20 ~ 25, 124 MP yang dibutuhkan, cooldown 20s",en:" Add a buff 'Defense Steal' to target, will reduce both physical defense and magic defense 20% ~ 25%, 124 MP Cost, cooldown 20s "},
displayName:{id:" PENCURI PERTAHANAN",en:"  Defense Steal "}},intimidation:{detail:{id:" memberikan debuff 'INTIMIDASI' kepada diri sendiri dan musuh memberikan efek memaksa musuh  untuk menyerang karakter pemain dengan jangkawan 400 radius, meningkatkan 25% blok dan 25% semua  pertahanan meningkat pada karakter, 150 MP yang dibutuhkan, durasi 33s, cooldown 60s",en:"  Add debuff 'intimidation' to caster and enemy, it forced the enemy to attack caster,  this buff also increased 25% both block chance and  defense to caster, it required 150 MP, buff duration 33s, cooldown 60s "},
displayName:{id:" INTIMIDASI",en:" INTIMDATION"}},rollingAttack:{detail:{id:" Putaran cepat memutar dengan jangakawan 150 radius, damage 280 ~ 332, 200 MP yang dibutuhkan, cooldown 8s",en:" Caster leaps and rotates in the air before striking the ground , deal damage to target increased 280 ~ 332, 200 MP cost, cooldown 8s"},displayName:{id:" PUTARAN CEPAT",en:" ROLLING ATTACK"}},upperAttack:{detail:{id:" Serangan pedang cepat dari atas dengan jangakawan 150 radius, damage 240 ~ 372, 172 MP yang dibutuhkan, cooldown 5s",
en:" Striking Sword from upper to the ground in 150 radius, 240 ~ 370 Deal Damage increased, 172 MP Cost, coolown 5s"},displayName:{id:" SERANGAN ATAS",en:" UPPER ATTACK"}},sliceAttack:{detail:{id:" Serangan pedang cepat menghantam tanah dan menimbulkan ledakan dengan jangakawan 150 radius, damage 940 ~ 1212, 150 MP yang dibutuhkan, cooldown 5s",en:" Striking sword hitting the ground with a shock wave in 300 radius, deal damage increased 940 ~ 1212, 150 MP Cost, Cooldown 5s "},displayName:{id:" SERANGAN BERPUSAT",
en:" Explosion Sword Attack"}},createBlue:{detail:{id:" Serangan pelindung berupa bola api biru yang menimbulkan ledakan pada target dengan jangakawan 250 radius, damage 1100 ~ 1505",en:" A shield of blue fire ball, a skill to protect a tower from invaders, attack range in 350 radius, deal damage increased 1100 ~ 1505 "},displayName:{id:" PELINDUNG API BIRU ",en:" Shiled Blue Fire "}},createRed:{detail:{id:" Serangan pelindung berupa bola api merah yang menimbulkan ledakan pada target dengan jangakawan 250 radius, damage 800 ~ 900",
en:" A shield of red fire ball, a skill to protect a tower from invaders, attack range in 350 radius, deal damage increased 800 ~ 900 "},displayName:{id:" PELINDUNG API MERAH ",en:" Shiled Red Fire "}},beresekYeti:{detail:{id:" Memberikan buff 'berserker aura' kepada diri sendiri dengan efek meningkatakan serangan fisik hingga 20% ~ 25%, dan kecepatan / gerakan meningkat 5.5, durasi 20s, cooldown 40s ",en:" Add a buff 'berserk aura' to caster, it increased Melee Damage 20% ~ 25 %, and 5.5 move speed increased, buff duration 20s, cooldown 40s "},
displayName:{id:" BERSERK YETI ",en:" BERSERK YETI "}}}},frame:{data:{vampire:["monstersVampireSpawn","vampire",40,40,80,{walk:{totalOfFrames:8,speed:1.5},idle:{totalOfFrames:8,speed:3},attack:{totalOfFrames:13,speed:3},teleportation:{totalOfFrames:12,speed:2},die:{totalOfFrames:12,speed:2}}],sekletonArcher:["monstersSekletonArcherSpawn","sekletonArcher",55,10,65,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],sekletonArmored:["monstersSekletonArmoredSpawn",
"sekletonArmored",55,20,45,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],sekletonSpear:["monstersSekletonSpearSpawn","sekletonSpear",55,-10,65,{summon:{totalOfFrames:10,speed:3},walk:{totalOfFrames:8,speed:2},idle:{totalOfFrames:6,speed:3},attack:{totalOfFrames:8,speed:3},die:{totalOfFrames:8,speed:2}}],bugGreenTail:["monstersBugGreenTailSpawn","bugGreenTail",30,0,90,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,
speed:3},attack:{totalOfFrames:9,speed:1},bodyCharge:{totalOfFrames:9,speed:1},die:{totalOfFrames:9,speed:2}}],bugGreen:["monstersBugGreenSpawn","bugGreen",0,0,110,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],bugRedTail:["monstersBugRedTailSpawn","bugRedTail",30,0,90,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:1},bodyCharge:{totalOfFrames:9,speed:1},die:{totalOfFrames:9,
speed:2}}],bugRed:["monstersBugRedSpawn","bugRed",0,0,110,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],boarBrown:["monstersBoarBrownSpawn","boarBrown",-5,0,125,{walk:{totalOfFrames:9,speed:1},idle:{totalOfFrames:9,speed:2},attack:{totalOfFrames:9,speed:2},bodyCharge:{totalOfFrames:9,speed:1},die:{totalOfFrames:9,speed:2}}],boarBlack:["monstersBoarBlackSpawn","boarBlack",-5,0,125,{walk:{totalOfFrames:9,speed:1},idle:{totalOfFrames:9,
speed:2},attack:{totalOfFrames:9,speed:2},bodyCharge:{totalOfFrames:9,speed:1},die:{totalOfFrames:9,speed:2}}],whiteBoar:["monstersWhiteBoarSpawn","whiteBoar",-20,0,145,{walk:{totalOfFrames:9,speed:1},idle:{totalOfFrames:9,speed:2},attack:{totalOfFrames:9,speed:1},die:{totalOfFrames:9,speed:2}}],whiteBoarJr:["monstersWhiteBoarJrSpawn","whiteBoarJr",-20,0,145,{walk:{totalOfFrames:9,speed:1},idle:{totalOfFrames:9,speed:2},attack:{totalOfFrames:9,speed:1},die:{totalOfFrames:9,speed:2}}],beastArmor:["monstersBeastArmorSpawn",
"beastArmor",100,10,-10,{walk:{totalOfFrames:9,speed:3},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},growHowl:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:3}}],beastSpear:["monstersBeastSpearSpawn","beastSpear",95,40,20,{walk:{totalOfFrames:9,speed:3},idle:{totalOfFrames:9,speed:3},attackA:{totalOfFrames:9,speed:2},piercingSpear:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:3}}],humanMage:["monstersHumanMageSpawn","humanMage",60,-10,70,{walk:{totalOfFrames:9,speed:1.5},
idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2},skill:{totalOfFrames:9,speed:3}}],humanArmored:["monstersHumanArmoredSpawn","humanArmored",60,15,30,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],humanArcher:["monstersHumanArcherSpawn","humanArcher",60,-20,70,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},bindingRoot:{totalOfFrames:9,
speed:3},die:{totalOfFrames:9,speed:2}}],sekletonWarriorBoomber:["monstersSekletonWarriorBoomberSpawn","sekletonWarriorBoomber",60,0,60,{walk:{totalOfFrames:9,speed:1},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],sekletonWarriorMage:["monstersSekletonWarriorMageSpawn","sekletonWarriorMage",50,-10,75,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],sekletonWarriorArmored:["monstersSekletonWarriorArmoredSpawn",
"sekletonWarriorArmored",30,-10,100,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},skill:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],sekletonWarriorArcher:["monstersSekletonWarriorArcherSpawn","sekletonWarriorArcher",30,-20,100,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},attackB:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],elementalArmored:["monstersElementalArmoredSpawn",
"elementalArmored",70,15,60,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],elemental:["monstersElementalSpawn","elemental",85,15,45,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],golem:["monstersGolemSpawn","golem",45,15,30,{summon:{totalOfFrames:15,speed:3},walk:{totalOfFrames:6,speed:3},idle:{totalOfFrames:6,speed:3},attack:{totalOfFrames:6,
speed:3},die:{totalOfFrames:7,speed:2}}],elfSpear:["monstersElfSpearSpawn","elfSpear",70,10,0,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],elfMage:["monstersElfMageSpawn","elfMage",70,-20,55,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},skill:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],elfArmored:["monstersElfArmoredSpawn","elfArmored",70,0,40,{walk:{totalOfFrames:9,
speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],elfArcher:["monstersElfArcherSpawn","elfArcher",70,-20,50,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],wolfArcher:["monstersWolfArcherSpawn","wolfArcher",45,0,80,{walk:{totalOfFrames:9,speed:3,speedAttack:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:3}}],wolfSpear:["monstersWolfSpearSpawn",
"wolfSpear",45,0,20,{walk:{totalOfFrames:9,speed:3,speedAttack:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:3}}],wolfMage:["monstersWolfMageSpawn","wolfMage",45,0,80,{walk:{totalOfFrames:9,speed:3,speedAttack:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:3}}],wolfWhite:["monstersWolfWhiteSpawn","wolfWhite",25,-10,80,{walk:{totalOfFrames:9,speed:3,speedAttack:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,
speed:2},die:{totalOfFrames:9,speed:3}}],wolfHummer:["monstersWolfHummerSpawn","wolfHummer",40,20,40,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},attackB:{totalOfFrames:17,speed:2},die:{totalOfFrames:9,speed:2}}],yetiAlpha:["monstersYetiAlphaSpawn","yetiAlpha",60,-30,60,{walk:{totalOfFrames:9,speed:1.5},run:{totalOfFrames:9,speed:1},skill:{totalOfFrames:9,speed:3},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,
speed:2}}],yeti:["monstersYetiSpawn","yeti",60,-30,60,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],goblinSpear:["monstersGoblinSpearSpawn","goblinSpear",35,13,90,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],goblinMage:["monstersGoblinMageSpawn","goblinMage",35,10,90,{skill:{totalOfFrames:9,speed:3},walk:{totalOfFrames:9,speed:1.5},
idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],goblinArmored:["monstersGoblinArmoredSpawn","goblinArmored",35,-10,90,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],goblinArcher:["monstersGoblinArcherSpawn","goblinArcher",35,-10,90,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],goblinWarriorSpear:["monstersGoblinWarriorSpearSpawn",
"goblinWarriorSpear",55,5,63,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},attackB:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],goblinWarriorMage:["monstersGoblinWarriorMageSpawn","goblinWarriorMage",55,20,58,{skill:{totalOfFrames:9,speed:1.5},walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:1.5},die:{totalOfFrames:9,speed:2}}],goblinWarriorArmored:["monstersGoblinWarriorArmoredSpawn","goblinWarriorArmored",
65,-5,30,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:1.5},die:{totalOfFrames:9,speed:2}}],goblinWarriorArcher:["monstersGoblinWarriorArcherSpawn","goblinWarriorArcher",60,0,50,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],humanRoyalArmor:["monstersHumanRoyalArmorSpawn","humanRoyalArmor",65,5,35,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,
speed:1},attackB:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],humanRoyalSpear:["monstersHumanRoyalSpearSpawn","humanRoyalSpear",60,-20,60,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],humanRoyalArcher:["monstersHumanRoyalArcherSpawn","humanRoyalArcher",60,-20,60,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],minatourDoubleSpear:["monstersMinatourDoubleSpearSpawn",
"minatourDoubleSpear",55,25,30,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2.5},die:{totalOfFrames:9,speed:2}}],minatourMage:["monstersMinatourMageSpawn","minatourMage",60,10,50,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},attackB:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],minatourSpear:["monstersMinatourSpearSpawn","minatourSpear",70,10,40,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,
speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],minatourArcher:["monstersMinatourArcherSpawn","minatourArcher",60,-10,50,{walk:{totalOfFrames:9,speed:1.5},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],elementalLight:["monstersElementalLightSpawn","elementalLight",40,0,85,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],fireElemental:["monstersFireElementalSpawn",
"fireElemental",40,0,85,{walk:{totalOfFrames:9,speed:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:2}}],bugQueen:["monstersBugQueenSpawn","bugQueen",-5,0,125,{walk:{totalOfFrames:9,speed:1},idle:{totalOfFrames:9,speed:2},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],bug:["monstersBugSpawn","bug",-20,0,145,{walk:{totalOfFrames:9,speed:1},idle:{totalOfFrames:9,speed:2},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:2}}],
heroArcher:["monstersHeroArcherSpawn","heroArcher",20,0,84,{walk:{totalOfFrames:15,speed:1},idle:{totalOfFrames:9,speed:3},throwBoom:{totalOfFrames:9,speed:2},arrowRain:{totalOfFrames:9,speed:3},attack3:{totalOfFrames:15,speed:1},attack2:{totalOfFrames:9,speed:2},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:3}}],heroArmor:["monstersHeroArmorSpawn","heroArmor",22,0,61,{walk:{totalOfFrames:15,speed:1},idle:{totalOfFrames:9,speed:3},die:{totalOfFrames:9,speed:3},upperAttack:{totalOfFrames:9,
speed:3},massiveAttack:{totalOfFrames:9,speed:2},rollingAttack:{totalOfFrames:25,speed:1},attack2:{totalOfFrames:9,speed:2},attack3:{totalOfFrames:9,speed:2},attack4:{totalOfFrames:9,speed:2},attack5:{totalOfFrames:9,speed:2},attack6:{totalOfFrames:15,speed:3},attack7:{totalOfFrames:9,speed:2},attack8:{totalOfFrames:9,speed:2}}],towerBlue:["monstersTowerBlueSpawn","towerBlue",165,0,-20,{}],towerRed:["monstersTowerRedSpawn","towerRed",165,0,-20,{}],towerRedb:["monstersTowerRedbSpawn","towerRedb",165,
0,-20,{}]},mapA:[["heroArcherSpawn","heroArcher",70,25,45,{walk:{totalOfFrames:9,speed:3,speedAttack:2},idle:{totalOfFrames:9,speed:3},attack:{totalOfFrames:9,speed:2},die:{totalOfFrames:9,speed:3}}]]},NPC:{monsterHeroArcher:{initArhcer:{avatarClass:"girl-archer",avatar:"ava-hero-archer.png",name:"Debby",level:26,gold:0,npcType:"character",aggresive:"yeti white vampire sekleton minatour human wolf golem elemental fire beast boar goblin bug elf".split(" "),temporaryObjectSpawn:!1,trajectoryProp:{posX:20,
posY:15,weaponEquip:"none",weaponName:"boom",weaponWidth:16,weaponHeight:20,angleSpeed:4.3},attackRange:500,attackRangeMax:751,attackRangeMin:696,attackMax:168,attackMin:122,defenseMax:459,defenseMin:418,magicDefenseMax:358,magicDefenseMin:315,maxHealth:12500,moveSpeedAttack:5.5,moveSpeedNormal:5.5,initialSpeedNormal:"extra-fast",initialSpeedAttack:15,initialAttackDelay:5,mp:1500,hpBar:"medium",buffSkill:{},abilitySkill:{throwBoom:!0,piercingShoot:!0,arrowRain:!0},modifierAbilities:{block:-100,stun:15,
avoid:20,critical:45,criticalChance:15},item:[],inventory:[{item:"explosionRedBoom",quantity:10},{item:"explosionBlueBoom",quantity:10},{item:"manaMediumPotion",quantity:99},{item:"manaMediumPotion",quantity:99},{item:"manaPotion",quantity:99},{item:"manaPotion",quantity:99},{item:"healthMediumPotion",quantity:99},{item:"healthPotion",quantity:99},{item:"healthPotion",quantity:99}],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[11],audioEnd:["arrow-fly-2"]},{frameExtend:["attack2"],
frame:[11,14],audioEnd:["arrow-fly-2","arrow-fly-2"]}],chance:100,delay:0},piercingShoot:{frameContent:[{frameExtend:["attack3"],frame:[9,11,13,14],audioEnd:["arrow-fly-2","arrow-fly-2","arrow-fly-2","arrow-fly-2"]}],chance:100,delay:0,unique:!0},throwBoom:{frameContent:[{frameExtend:["throwBoom"],frame:[]}],chance:100,delay:0,unique:!0},arrowRain:{frameContent:[{frameExtend:["arrowRain"],frame:[5]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersHeroArcherSpawn:{mapDungeonD:[{monsters:[],
objectSpawn:"staticOriDngDPassSpawnA",spawnTotal:1,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterHeroArmor:1}}],mapDungeonG:[{monsters:[],objectSpawn:"staticOriDngGPassStA",spawnTotal:1,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterHeroArmor:1}}],mapDungeonH:[{monsters:[],objectSpawn:"staticOriDngHPassSpawnC",spawnTotal:1,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterHeroArmor:1}}],
mapDungeonF:[{monsters:[],objectSpawn:"staticOriDngFPassSpawnC",spawnTotal:1,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterHeroArmor:1}}]}}}},monsterHeroArmor:{initSpear:{avatarClass:"girl-armored",avatar:"ava-hero-armor.png",name:"Liliyana",npcType:"character",level:26,gold:0,aggresive:"yeti white vampire sekleton minatour human wolf golem elemental fire beast boar bug goblin elf".split(" "),temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:211,attackRangeMin:177,
attackMax:515,attackMin:468,defenseMax:582,defenseMin:528,magicDefenseMax:468,magicDefenseMin:445,moveSpeedAttack:5.5,moveSpeedNormal:5.5,maxHealth:23830,initialSpeedNormal:"extra-fast",initialSpeedAttack:0,initialAttackDelay:5,mp:1500,hpBar:"medium",buffSkill:{},modifierAbilities:{block:20,critical:45,criticalChance:15},abilitySkill:{rollingAttack:!0,upperAttack:!0,sliceAttack:!0,intimidation:!0},item:[],inventory:[{item:"manaMediumPotion",quantity:99},{item:"manaMediumPotion",quantity:99},{item:"manaPotion",
quantity:99},{item:"manaPotion",quantity:99},{item:"healthMediumPotion",quantity:99},{item:"healthPotion",quantity:99},{item:"healthPotion",quantity:99}],attackFrame:{normal:{frameContent:[{frameExtend:["attack5"],frame:[8],audioStart:["grunt-7"],audioEnd:[["swing","swing2","swing3"]]},{frameExtend:["attack3"],frame:[13],audioStart:["grunt-7"],audioEnd:[["swing","swing2","swing3"]]}],chance:100,delay:0},skill1:{frameContent:[{frameExtend:["attack5","attack2","attack5","attack3","attack6"],frame:[8,
24,32,45,63,86,94,112],audioStart:["grunt-7"],audioEnd:[["swing","swing2","swing3"],["swing","swing2","swing3"],["swing","swing2","swing3"],["swing","swing2","swing3"],["swing","swing2","swing3"],["swing","swing2","swing3"],["swing","swing2","swing3"],["swing","swing2","swing3"],["swing","swing2","swing3"]]}],chance:100,delay:0},skill2:{frameContent:[{frameExtend:["attack7","attack3","attack8"],frame:[8,14,32,45],audioStart:["grunt-7"],audioEnd:[["swing","swing2","swing3"],["swing","swing2","swing3"],
["swing","swing2","swing3"],["swing","swing2","swing3"],["swing","swing2","swing3"]]}],chance:100,delay:0},sliceAttack:{frameContent:[{frameExtend:["massiveAttack"],frame:[],audioStart:["grunt-7"]}],chance:100,delay:0,unique:!0},rollingAttack:{frameContent:[{frameExtend:["rollingAttack"],frame:[]}],chance:100,delay:0,unique:!0},upperAttack:{frameContent:[{frameExtend:["upperAttack"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersHeroArmorSpawn:{mapDungeonD:[{monsters:[],objectSpawn:"staticOriDngDPassStB",
spawnTotal:1,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterHeroArcher:1}}],mapDungeonG:[{monsters:[],objectSpawn:"staticOriDngGPassStA",spawnTotal:1,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterHeroArcher:1}}],mapDungeonH:[{monsters:[],objectSpawn:"staticOriDngHPassSpawnC",spawnTotal:1,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterHeroArcher:1}}],mapDungeonF:[{monsters:[],objectSpawn:"staticOriDngFPassSpawnC",
spawnTotal:1,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterHeroArcher:1}}]}}}},monsterTowerBlue:{initStatic:{avatarClass:"tower-blue",name:"Blue Tower",level:26,npcType:"tower",aggresive:"yeti white vampire sekleton minatour human wolf golem elemental fire beast boar bug goblin elf".split(" "),temporaryObjectSpawn:!0,attackRange:500,attackRangeMax:1505,attackRangeMin:1100,attackMax:305,attackMin:262,defenseMax:475,defenseMin:333,magicDefenseMax:408,magicDefenseMin:345,
maxHealth:176250,moveSpeedAttack:4.5,moveSpeedNormal:4.5,initialSpeedNormal:"extra-fast",initialSpeedAttack:25,initialAttackDelay:30,mp:11500,hpBar:"medium",buffSkill:{},abilitySkill:{createBlue:!0},item:[],inventory:[],attackFrame:{},audioDie:[],spawn:{monstersTowerBlueSpawn:{mapDungeonD:[{monsters:[],objectSpawn:"staticOriDngDPassStC",spawnTotal:1,respawnLimit:1,reSpawnTick:500,reSpawnTickFixed:500,position:"fixed",install:!1,location:"mapDungeonD"}],mapDungeonG:[{monsters:[],objectSpawn:"staticOriDngGPassStA",
spawnTotal:1,respawnLimit:1,reSpawnTick:500,reSpawnTickFixed:500,position:"fixed",install:!1,location:"mapDungeonG"}],mapDungeonH:[{monsters:[],objectSpawn:"staticOriDngHPassStC",spawnTotal:1,respawnLimit:1,reSpawnTick:500,reSpawnTickFixed:500,position:"fixed",install:!1,location:"mapDungeonG"}]}}}},monsterTowerRedb:{initStatic:{avatarClass:"tower-redb",name:"Red Tower Med",level:26,npcType:"tower",aggresive:"yeti white vampire sekleton minatour human wolf golem elemental fire beast boar bug goblin elf".split(" "),
temporaryObjectSpawn:!0,attackRange:500,attackRangeMax:1200,attackRangeMin:1E3,attackMax:305,attackMin:262,defenseMax:445,defenseMin:387,magicDefenseMax:408,magicDefenseMin:345,maxHealth:126250,moveSpeedAttack:4.5,moveSpeedNormal:4.5,initialSpeedNormal:"extra-fast",initialSpeedAttack:25,initialAttackDelay:30,mp:11500,hpBar:"medium",buffSkill:{},abilitySkill:{createRed:!0},item:[],inventory:[],attackFrame:{},audioDie:[],spawn:{monstersTowerRedbSpawn:{mapDungeonH:[{monsters:[],objectSpawn:"staticOriDngHPassStB",
spawnTotal:1,respawnLimit:1,reSpawnTick:500,reSpawnTickFixed:500,position:"fixed",install:!1,location:"mapDungeonG"}],mapDungeonF:[{monsters:[],objectSpawn:"staticOriDngFPassStA",spawnTotal:1,respawnLimit:1,reSpawnTick:500,reSpawnTickFixed:500,position:"fixed",install:!1,location:"mapDungeonG"},{monsters:[],objectSpawn:"staticOriDngFPassStB",spawnTotal:1,respawnLimit:1,reSpawnTick:500,reSpawnTickFixed:500,position:"fixed",install:!1,location:"mapDungeonG"}]}}}},monsterTowerRed:{initStatic:{avatarClass:"tower-red",
name:"Red Tower",level:26,npcType:"tower",aggresive:"yeti white vampire sekleton minatour human wolf golem elemental fire beast boar bug goblin elf".split(" "),temporaryObjectSpawn:!0,attackRange:500,attackRangeMax:800,attackRangeMin:850,attackMax:305,attackMin:262,defenseMax:315,defenseMin:243,magicDefenseMax:408,magicDefenseMin:345,maxHealth:76250,moveSpeedAttack:4.5,moveSpeedNormal:4.5,initialSpeedNormal:"extra-fast",initialSpeedAttack:25,initialAttackDelay:30,mp:11500,hpBar:"medium",buffSkill:{},
abilitySkill:{createRed:!0},item:[],inventory:[],attackFrame:{},audioDie:[],spawn:{monstersTowerRedSpawn:{mapDungeonD:[{monsters:[],objectSpawn:"staticOriDngDPassStB",spawnTotal:1,respawnLimit:1,reSpawnTick:500,reSpawnTickFixed:500,position:"fixed",install:!1,location:"mapDungeonD"},{monsters:[],objectSpawn:"staticOriDngDPassStD",spawnTotal:1,respawnLimit:1,reSpawnTick:500,reSpawnTickFixed:500,position:"fixed",install:!1,location:"mapDungeonD"}],mapDungeonH:[{monsters:[],objectSpawn:"staticOriDngHPassStD",
spawnTotal:1,respawnLimit:1,reSpawnTick:500,reSpawnTickFixed:500,position:"fixed",install:!1,location:"mapDungeonG"}]}}}},monsterSekletonSpear:{initSpear:{avatarClass:"sekleton-spear",name:"Sekleton ( Dual-Handed Sword )",level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:70,attackRangeMax:141,attackRangeMin:127,attackMax:893,attackMin:832,defenseMax:386,defenseMin:348,magicDefenseMax:434,magicDefenseMin:484,maxHealth:31300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,
initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:13218,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[15,19],audioEnd:[]}],chance:100,delay:0},summon:{frameContent:[{frameExtend:["summon"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersSekletonSpearSpawn:[]}}},monsterSekletonArmored:{initArmored:{avatarClass:"sekleton-armor",name:"Sekleton ( Armor )",level:26,monsterLevel:"D",
aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:70,attackRangeMax:141,attackRangeMin:127,attackMax:843,attackMin:782,defenseMax:482,defenseMin:438,magicDefenseMax:434,magicDefenseMin:484,maxHealth:24300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:12118,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[10],audioEnd:[]}],chance:100,delay:0}},
audioDie:[],spawn:{monstersSekletonArmoredSpawn:[]}}},monsterSekletonArcher:{initArhcer:{avatarClass:"sekleton-archer",name:"Sekleton ( Archer )",level:26,monsterLevel:"D",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:30,posY:45,weaponEquip:"trajectory",weaponName:"arrowRotate",weaponWidth:44,weaponHeight:44,angleSpeed:1.3},attackRange:500,attackRangeMax:843,attackRangeMin:781,attackMax:250,attackMin:214,defenseMax:411,defenseMin:363,magicDefenseMax:419,magicDefenseMin:385,
maxHealth:22740,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:13118,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[15],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersSekletonArcherSpawn:[]}}},monsterVampire:{initSpear:{avatarClass:"vampire",name:"Vampire",level:26,monsterLevel:"S",npcType:"monster-leader",aggresive:["tower","hero"],
temporaryObjectSpawn:!1,attackRange:160,attackRangeMax:349,attackRangeMin:313,attackMax:942,attackMin:881,defenseMax:512,defenseMin:471,magicDefenseMax:535,magicDefenseMin:473,maxHealth:51990,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:15E3,hpBar:"medium",buffSkill:{},abilitySkill:{teleportation:!0,bloodDrain:!0,sekletonSummoner:!0,powerAgilityIII:!0},modifierAbilities:{avoid:20,criticalChance:10},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],
frame:[14,16,18,20,22,24,26],audioEnd:[]}],chance:100,delay:0},teleportation:{frameContent:[{frameExtend:["teleportation"],frame:[]}],chance:100,delay:0,unique:!0},powerAgilityIII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0},sekletonSummoner:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersVampireSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,
install:!1,location:"mapDungeonD",pions:{monsterSekletonArmored:1,monsterSekletonArcher:1}}]}}},monsterBeastSpear:{initSpear:{avatarClass:"beast",name:"Titan Beast ( Spear )",level:26,monsterLevel:"A",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:170,attackRangeMax:349,attackRangeMin:313,attackMax:1302,attackMin:1256,defenseMax:442,defenseMin:401,magicDefenseMax:565,magicDefenseMin:523,maxHealth:49990,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,
initialAttackDelay:30,mp:13818,hpBar:"medium",buffSkill:{},abilitySkill:{piercingSpear:!0,powerAgilityIII:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attackA"],frame:[12],audioEnd:[]}],chance:100,delay:0},piercingSpear:{frameContent:[{frameExtend:["piercingSpear"],frame:[]}],chance:100,delay:0,unique:!0},powerAgilityIII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersBeastSpearSpawn:[]}}},monsterBeastArmor:{initArmored:{avatarClass:"beast-armor",
name:"Mount Titan Beast ( Armor )",level:26,monsterLevel:"S",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:170,attackRangeMax:349,attackRangeMin:313,attackMax:1121,attackMin:1066,defenseMax:519,defenseMin:458,magicDefenseMax:565,magicDefenseMin:523,maxHealth:56990,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:15218,hpBar:"medium",buffSkill:{},abilitySkill:{growHowl:!0,powerDefeneseIII:!0,
golemSummoner:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[12],audioEnd:[]}],chance:100,delay:0},growHowl:{frameContent:[{frameExtend:["growHowl"],frame:[]}],chance:100,delay:0,unique:!0},powerDefeneseIII:{frameContent:[{frameExtend:["growHowl"],frame:[]}],chance:100,delay:0,unique:!0},golemSummoner:{frameContent:[{frameExtend:["growHowl"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersBeastArmorSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",
spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterBeastSpear:1}}]}}},monsterHumanArcher:{initArhcer:{avatarClass:"human-archer",name:"Hunter ( Archer )",level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:30,posY:55,weaponEquip:"trajectory",weaponName:"arrowB",weaponWidth:44,weaponHeight:44,angleSpeed:1.3},attackRange:500,attackRangeMax:943,attackRangeMin:881,attackMax:290,attackMin:254,defenseMax:331,
defenseMin:313,magicDefenseMax:339,magicDefenseMin:285,maxHealth:23330,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:13321,hpBar:"medium",buffSkill:{},abilitySkill:{bindingRoot:!0,powerAgility:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[21],audioEnd:[]}],chance:100,delay:0},bindingRoot:{frameContent:[{frameExtend:["bindingRoot"],frame:[]}],chance:100,delay:0,unique:!0},powerAgility:{frameContent:[{frameExtend:["idle"],
frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersHumanArcherSpawn:[]}}},monsterHumanArmored:{initArmored:{avatarClass:"human-armor",name:"Hunter ( Armor )",level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:120,attackRangeMax:141,attackRangeMin:127,attackMax:1043,attackMin:982,defenseMax:382,defenseMin:338,magicDefenseMax:434,magicDefenseMin:484,maxHealth:25300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,
initialAttackDelay:30,mp:13190,hpBar:"medium",buffSkill:{},abilitySkill:{powerDefenese:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[14],audioEnd:[]}],chance:100,delay:0},powerDefenese:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersHumanArmoredSpawn:[]}}},monsterHumanMage:{initMage:{avatarClass:"human-mage",name:"Hunter ( Mage )",level:26,monsterLevel:"C",npcType:"monster-leader",aggresive:["tower",
"hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:0,posY:0,weaponEquip:"none",weaponName:"",weaponWidth:0,weaponHeight:0,angleSpeed:0},attackRange:500,attackRangeMax:960,attackRangeMin:916,attackMax:349,attackMin:313,defenseMax:459,defenseMin:408,magicDefenseMax:635,magicDefenseMin:574,maxHealth:27391,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:15218,hpBar:"medium",buffSkill:{},abilitySkill:{massHealing:!0,abilitiesSteal:!0},
item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[14],audioEnd:[]}],chance:100,delay:0},massHealing:{frameContent:[{frameExtend:["skill"],frame:[]}],chance:100,delay:0,unique:!0},abilitiesSteal:{frameContent:[{frameExtend:["skill"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersHumanMageSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",
pions:{monsterHumanArcher:2,monsterHumanArmored:1}}]}}},monsterBugRed:{initSpear:{avatarClass:"bug-red",name:"Bomphet Red",level:26,monsterLevel:"D",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:753,attackMin:713,defenseMax:381,defenseMin:333,magicDefenseMax:414,magicDefenseMin:374,maxHealth:22300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:13518,hpBar:"medium",
buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[17],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersBugRedSpawn:[]}}},monsterBugRedTail:{initSpear:{avatarClass:"bug-red",name:"Bomphet Red Tail",level:26,monsterLevel:"B",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:110,attackRangeMax:141,attackRangeMin:127,attackMax:923,attackMin:844,defenseMax:491,defenseMin:353,magicDefenseMax:394,
magicDefenseMin:364,maxHealth:47300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:13551,hpBar:"medium",buffSkill:{},abilitySkill:{bodyCharge:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[8],audioEnd:[]}],chance:100,delay:0},bodyCharge:{frameContent:[{frameExtend:["bodyCharge"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersBugRedTailSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",
spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterBugRed:3}}]}}},monsterBugGreen:{initSpear:{avatarClass:"bug-green",name:"Bomphet Green",level:26,monsterLevel:"D",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:753,attackMin:713,defenseMax:381,defenseMin:333,magicDefenseMax:414,magicDefenseMin:374,maxHealth:22300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",
initialSpeedAttack:25,initialAttackDelay:30,mp:1218,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[17],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersBugGreenSpawn:[]}}},monsterBugGreenTail:{initSpear:{avatarClass:"bug-green",name:"Bomphet Green Tail",level:26,monsterLevel:"B",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:110,attackRangeMax:141,attackRangeMin:127,
attackMax:833,attackMin:774,defenseMax:491,defenseMin:353,magicDefenseMax:394,magicDefenseMin:364,maxHealth:47300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:15948,hpBar:"medium",buffSkill:{},abilitySkill:{bodyCharge:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[8],audioEnd:[]}],chance:100,delay:0},bodyCharge:{frameContent:[{frameExtend:["bodyCharge"],frame:[]}],chance:100,delay:0,unique:!0}},
audioDie:[],spawn:{monstersBugGreenTailSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterBugGreen:3}}]}}},monsterSekletonWarriorArcher:{initArhcer:{avatarClass:"sekleton-warrior-archer",name:"Sekleton Warrior ( Archer )",level:26,monsterLevel:"B",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:25,posY:20,weaponEquip:"trajectory",weaponName:"arrowDrotate",
weaponWidth:37,weaponHeight:37,angleSpeed:1.3},attackRange:500,attackRangeMax:843,attackRangeMin:781,attackMax:250,attackMin:214,defenseMax:411,defenseMin:363,magicDefenseMax:419,magicDefenseMin:385,maxHealth:28740,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:14431,hpBar:"medium",buffSkill:{},abilitySkill:{powerAgilityII:!0,bindingRoot:!0},modifierAbilities:{avoid:25},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],
frame:[8,15],audioEnd:[]},{frameExtend:["attackB"],frame:[16],audioEnd:[]}],chance:100,delay:0},powerAgilityII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0},bindingRoot:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersSekletonWarriorArcherSpawn:[]}}},monsterSekletonWarriorArmored:{initArmored:{avatarClass:"sekleton-warrior-archer",name:"Sekleton Warrior ( Armor )",level:26,monsterLevel:"B",aggresive:["tower",
"hero"],temporaryObjectSpawn:!1,attackRange:70,attackRangeMax:141,attackRangeMin:127,attackMax:843,attackMin:782,defenseMax:512,defenseMin:448,magicDefenseMax:434,magicDefenseMin:484,maxHealth:33300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:13699,hpBar:"medium",buffSkill:{},abilitySkill:{powerDefeneseII:!0},item:[],inventory:[],modifierAbilities:{block:25},attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[17],
audioEnd:[]}],chance:100,delay:0},powerDefeneseII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersSekletonWarriorArmoredSpawn:[]}}},monsterSekletonWarriorBoomber:{initArhcer:{avatarClass:"sekleton-warrior-boomber",name:"Sekleton Warrior Boomber",level:26,monsterLevel:"S",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:15,posY:70,weaponEquip:"trajectory",weaponName:"boom",weaponWidth:16,weaponHeight:20,
angleSpeed:4.3},attackRange:500,attackRangeMax:1182,attackRangeMin:1130,attackMax:430,attackMin:214,defenseMax:541,defenseMin:473,magicDefenseMax:419,magicDefenseMin:385,maxHealth:50310,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:30,initialAttackDelay:30,mp:17208,hpBar:"medium",buffSkill:{},modifierAbilities:{avoid:30,critical:37,criticalChance:15},abilitySkill:{powerAgilityIII:!0,throwBoom:!0},item:[],inventory:[{item:"explosionRedBoom",quantity:99}],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],
frame:[11],audioEnd:["arrow-fly-2"]}],chance:100,delay:0},powerAgilityIII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0},throwBoom:{frameContent:[{frameExtend:["attack"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersSekletonWarriorBoomberSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterSekletonWarriorMage:1,monsterSekletonWarriorArmored:1,
monsterSekletonWarriorArcher:1}}]}}},monsterSekletonWarriorMage:{initMage:{avatarClass:"sekleton-warrior-mage",name:"Wraith ( Mage )",level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:0,posY:0,weaponEquip:"none",weaponName:"",weaponWidth:0,weaponHeight:0,angleSpeed:0},attackRange:500,attackRangeMax:911,attackRangeMin:871,attackMax:349,attackMin:313,defenseMax:421,defenseMin:468,magicDefenseMax:635,magicDefenseMin:544,maxHealth:27588,moveSpeedAttack:3.5,
moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:14590,hpBar:"medium",buffSkill:{},abilitySkill:{defenseSteal:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[14],audioEnd:[]}],chance:100,delay:0},defenseSteal:{frameContent:[{frameExtend:["attack"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersSekletonWarriorMageSpawn:[]}}},monsterWolfArcher:{initArhcer:{avatarClass:"wolf-archer",name:" Desert Grey Wolf ( Archer )",
level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:80,posY:30,weaponEquip:"trajectory",weaponName:"boom",weaponWidth:16,weaponHeight:20,angleSpeed:4.3},attackRange:500,attackRangeMax:843,attackRangeMin:781,attackMax:250,attackMin:214,defenseMax:411,defenseMin:363,magicDefenseMax:419,magicDefenseMin:385,maxHealth:26740,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:13313,hpBar:"medium",
buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[11],audioEnd:["arrow-fly-2"]}],chance:100,delay:0}},audioDie:[],spawn:{monstersWolfArcherSpawn:[]}}},monsterWolfSpear:{initSpear:{avatarClass:"wolf-spear",name:" Desert Grey Wolf ( Spear )",level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:933,attackMin:842,defenseMax:411,defenseMin:363,magicDefenseMax:394,
magicDefenseMin:354,maxHealth:25300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:13356,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[15],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersWolfSpearSpawn:[]}}},monsterWolfMage:{initMage:{avatarClass:"wolf-mage",name:" Desert White Wolf ( Mage )",level:26,monsterLevel:"C",aggresive:["tower",
"hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:0,posY:0,weaponEquip:"none",weaponName:"",weaponWidth:0,weaponHeight:0,angleSpeed:0},attackRange:500,attackRangeMax:953,attackRangeMin:918,attackMax:369,attackMin:353,defenseMax:469,defenseMin:458,magicDefenseMax:575,magicDefenseMin:534,maxHealth:33319,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:14473,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],
frame:[16],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersWolfMageSpawn:[]}}},monsterWolfWhite:{initSpear:{avatarClass:"wolf-white",name:" Desert White Wolf",level:26,monsterLevel:"D",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:743,attackMin:694,defenseMax:391,defenseMin:363,magicDefenseMax:354,magicDefenseMin:314,maxHealth:22300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,
initialAttackDelay:30,mp:12455,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[12],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersWolfWhiteSpawn:[]}}},monsterWolfHummer:{initSpear:{avatarClass:"wolf-hummer",name:"Desert Wolf ( Hero )",level:26,monsterLevel:"A",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:349,attackRangeMin:313,attackMax:1302,
attackMin:1256,defenseMax:539,defenseMin:488,magicDefenseMax:515,magicDefenseMin:474,maxHealth:51390,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:14881,hpBar:"medium",buffSkill:{},abilitySkill:{powerAgilityIII:!0,earthShake:!0},modifierAbilities:{critical:37,criticalChance:20},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[15],audioEnd:[]}],chance:100,delay:0},earthShake:{frameContent:[{frameExtend:["attackB"],
frame:[]}],chance:100,delay:0,unique:!0},powerAgilityIII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersWolfHummerSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterWolfMage:1,monsterWolfSpear:1,monsterWolfArcher:1,monsterWolfWhite:1}}]}}},monsterElemental:{initMage:{avatarClass:"elemental",name:"Eddga Golem ( Mage )",level:26,
monsterLevel:"B",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:30,posY:30,weaponEquip:"none",weaponName:"",weaponWidth:0,weaponHeight:0,angleSpeed:.3},attackRange:500,attackRangeMax:1371,attackRangeMin:1271,attackMax:349,attackMin:313,defenseMax:421,defenseMin:468,magicDefenseMax:675,magicDefenseMin:614,maxHealth:35588,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:11218,hpBar:"medium",buffSkill:{},modifierAbilities:{criticalChance:15},
abilitySkill:{powerAgilityII:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[14],audioEnd:[]}],chance:100,delay:0},powerAgilityII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersElementalSpawn:[]}}},monsterElementalArmored:{initMage:{avatarClass:"elemental-armor",name:"Galatic Golem ( Mage )",level:26,monsterLevel:"B",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:30,
posY:30,weaponEquip:"none",weaponName:"",weaponWidth:0,weaponHeight:0,angleSpeed:.3},attackRange:500,attackRangeMax:1402,attackRangeMin:1356,attackMax:349,attackMin:313,defenseMax:479,defenseMin:428,magicDefenseMax:675,magicDefenseMin:634,maxHealth:35588,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:14250,hpBar:"medium",buffSkill:{},modifierAbilities:{criticalChance:15},abilitySkill:{powerAgilityIII:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],
frame:[14],audioEnd:[]}],chance:100,delay:0},powerAgilityIII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersElementalArmoredSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterElemental:1}}]}}},monsterYeti:{initSpear:{avatarClass:"yeti",name:"Yeti",level:26,monsterLevel:"B",aggresive:["tower","hero"],temporaryObjectSpawn:!1,
attackRange:110,attackRangeMax:349,attackRangeMin:313,attackMax:1202,attackMin:1106,defenseMax:559,defenseMin:518,magicDefenseMax:515,magicDefenseMin:474,maxHealth:37190,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:14332,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[8],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersYetiSpawn:[]}}},
monsterYetiAlpha:{initSpear:{avatarClass:"yeti-alpha",name:"Yeti Alpha",level:26,monsterLevel:"A",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:110,attackRangeMax:349,attackRangeMin:313,attackMax:1302,attackMin:1256,defenseMax:619,defenseMin:558,magicDefenseMax:565,magicDefenseMin:523,maxHealth:43990,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:14111,hpBar:"medium",buffSkill:{},abilitySkill:{beresekYeti:!0,
earthQuake:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[16],audioEnd:[]}],chance:100,delay:0},beresekYeti:{frameContent:[{frameExtend:["skill"],frame:[]}],chance:100,delay:0,unique:!0},earthQuake:{frameContent:[{frameExtend:["attack"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersYetiAlphaSpawn:[{monsters:[],objectSpawn:"staticOriDngGPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonG",
pions:{monsterYeti:1}}]}}},monsterElfArcher:{initArhcer:{avatarClass:"elf-archer",name:"Elf Giearth ( Archer )",level:26,monsterLevel:"D",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:30,posY:60,weaponEquip:"trajectory",weaponName:"arrowB",weaponWidth:44,weaponHeight:44,angleSpeed:1.3},attackRange:500,attackRangeMax:943,attackRangeMin:881,attackMax:290,attackMin:254,defenseMax:371,defenseMin:323,magicDefenseMax:339,magicDefenseMin:285,maxHealth:21900,moveSpeedAttack:3.5,
moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:11218,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[21],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersElfArcherSpawn:[]}}},monsterElfArmored:{initArmored:{avatarClass:"elf-armor",name:"Elf Giearth ( Armor )",level:26,monsterLevel:"D",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,
attackRangeMin:127,attackMax:943,attackMin:982,defenseMax:482,defenseMin:438,magicDefenseMax:434,magicDefenseMin:484,maxHealth:24300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:11218,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[18],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersElfArmoredSpawn:[]}}},monsterElfMage:{initMage:{avatarClass:"elf-mage",
name:"Elf Giearth ( Mage )",level:26,monsterLevel:"B",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:0,posY:0,weaponEquip:"none",weaponName:"",weaponWidth:0,weaponHeight:0,angleSpeed:0},attackRange:500,attackRangeMax:1202,attackRangeMin:1156,attackMax:349,attackMin:313,defenseMax:459,defenseMin:408,magicDefenseMax:635,magicDefenseMin:574,maxHealth:35391,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,
mp:19661,hpBar:"medium",buffSkill:{},abilitySkill:{healing:!0,massHealing:!0,golemSummoner:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[14],audioEnd:[]}],chance:100,delay:0},massHealing:{frameContent:[{frameExtend:["skill"],frame:[]}],chance:100,delay:0,unique:!0},healing:{frameContent:[{frameExtend:["skill"],frame:[]}],chance:100,delay:0,unique:!0},golemSummoner:{frameContent:[{frameExtend:["skill"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],
spawn:{monstersElfMageSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterElfArcher:1,monsterElfArmored:1,monsterElfSpear:1}}]}}},monsterElfSpear:{initSpear:{avatarClass:"elf-spear",name:"Elf Giearth ( Spear )",level:26,monsterLevel:"D",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:970,attackMin:932,defenseMax:462,
defenseMin:418,magicDefenseMax:394,magicDefenseMin:354,maxHealth:23300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:14118,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[8,17],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersElfSpearSpawn:[]}}},monsterGoblinWarriorArcher:{initArhcer:{avatarClass:"goblin-warrior-archer",name:"Goblin Warrior ( Archer )",
level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:30,posY:60,weaponEquip:"trajectory",weaponName:"arrowDrotate",weaponWidth:37,weaponHeight:37,angleSpeed:1.3},attackRange:500,attackRangeMax:743,attackRangeMin:681,attackMax:290,attackMin:254,defenseMax:371,defenseMin:323,magicDefenseMax:339,magicDefenseMin:285,maxHealth:23510,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:35,initialAttackDelay:30,mp:12140,hpBar:"medium",
buffSkill:{},abilitySkill:{powerAgilityII:!0},item:[],inventory:[],modifierAbilities:{avoid:30},attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[14],audioEnd:[]}],chance:100,delay:0},powerAgilityII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersGoblinWarriorArcherSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD"}]}}},monsterGoblinWarriorArmored:{initArmored:{avatarClass:"goblin-warrior-armor",
name:"Goblin Warrior ( Armor )",level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:70,attackRangeMax:141,attackRangeMin:127,attackMax:843,attackMin:782,defenseMax:482,defenseMin:438,magicDefenseMax:434,magicDefenseMin:484,maxHealth:27300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:12613,hpBar:"medium",buffSkill:{},abilitySkill:{powerDefeneseII:!0},item:[],inventory:[],modifierAbilities:{block:30},
attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[14],audioEnd:[]}],chance:100,delay:0},powerDefeneseII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersGoblinWarriorArmoredSpawn:[]}}},monsterGoblinWarriorMage:{initMage:{avatarClass:"goblin-warrior-mage",name:"Goblin Warrior ( Mage )",level:26,monsterLevel:"B",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:0,posY:0,weaponEquip:"none",
weaponName:"",weaponWidth:0,weaponHeight:0,angleSpeed:0},attackRange:500,attackRangeMax:1002,attackRangeMin:956,attackMax:349,attackMin:313,defenseMax:459,defenseMin:408,magicDefenseMax:635,magicDefenseMin:574,maxHealth:33860,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:15218,hpBar:"medium",buffSkill:{},abilitySkill:{healing:!0,mindControl:!0,defenseSteal:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],
frame:[14],audioEnd:[]}],chance:100,delay:0},healing:{frameContent:[{frameExtend:["skill"],frame:[]}],chance:100,delay:0,unique:!0},mindControl:{frameContent:[{frameExtend:["skill"],frame:[]}],chance:100,delay:0,unique:!0},defenseSteal:{frameContent:[{frameExtend:["attack"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersGoblinWarriorMageSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",
pions:{monsterGoblinWarriorArcher:2,monsterGoblinWarriorArmored:1,monsterGoblinWarriorSpear:1}}]}}},monsterGoblinWarriorSpear:{initSpear:{avatarClass:"goblin-warrior-spear",name:"Goblin Warrior ( Spear )",level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:70,attackRangeMax:141,attackRangeMin:127,attackMax:870,attackMin:832,defenseMax:462,defenseMin:418,magicDefenseMax:394,magicDefenseMin:354,maxHealth:23300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",
initialSpeedAttack:25,initialAttackDelay:30,mp:14218,hpBar:"medium",buffSkill:{},abilitySkill:{piercingSpeed:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[12],audioEnd:[]},{frameExtend:["attackB"],frame:[12],audioEnd:[]}],chance:100,delay:0},piercingSpeed:{frameContent:[{frameExtend:["attackB"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersGoblinWarriorSpearSpawn:[]}}},monsterGoblinArcher:{initArhcer:{avatarClass:"goblin-archer",
name:"Goblin ( Archer )",level:26,monsterLevel:"D",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:30,posY:10,weaponEquip:"trajectory",weaponName:"arrow",weaponWidth:44,weaponHeight:44,angleSpeed:1.3},attackRange:500,attackRangeMax:884,attackRangeMin:733,attackMax:236,attackMin:193,defenseMax:382,defenseMin:298,magicDefenseMax:384,magicDefenseMin:378,maxHealth:22410,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:35,initialAttackDelay:30,
mp:12500,hpBar:"medium",buffSkill:{},abilitySkill:{powerAgility:!0},modifierAbilities:{avoid:25},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[16],audioEnd:[]}],chance:100,delay:0},powerAgility:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersGoblinArcherSpawn:[]}}},monsterGoblinArmored:{initArmored:{avatarClass:"goblin-armor",name:"Goblin ( Armor )",level:26,monsterLevel:"D",aggresive:["tower","hero"],
temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:793,attackMin:742,defenseMax:392,defenseMin:358,magicDefenseMax:324,magicDefenseMin:284,maxHealth:25300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:13878,hpBar:"medium",buffSkill:{},abilitySkill:{powerDefenese:!0},modifierAbilities:{block:25},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[18],audioEnd:[]}],
chance:100,delay:0},powerDefenese:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersGoblinArmoredSpawn:[]}}},monsterGoblinMage:{initMage:{avatarClass:"goblin-mage",name:"Goblin ( Mage )",level:26,monsterLevel:"C",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:0,posY:0,weaponEquip:"none",weaponName:"",weaponWidth:0,weaponHeight:0,angleSpeed:0},attackRange:500,attackRangeMax:1034,attackRangeMin:953,
attackMax:334,attackMin:263,defenseMax:382,defenseMin:298,magicDefenseMax:484,magicDefenseMin:438,maxHealth:30410,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:14100,hpBar:"medium",buffSkill:{},abilitySkill:{mindControl:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[14],audioEnd:[]}],chance:100,delay:0},mindControl:{frameContent:[{frameExtend:["skill"],frame:[]}],chance:100,delay:0,unique:!0}},
audioDie:[],spawn:{monstersGoblinMageSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterGoblinArcher:2,monsterGoblinArmored:1,monsterGoblinSpear:1}}]}}},monsterGoblinSpear:{initSpear:{avatarClass:"goblin-spear",name:"Goblin ( Spear )",level:26,monsterLevel:"D",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:849,attackMin:796,
defenseMax:372,defenseMin:328,magicDefenseMax:325,magicDefenseMin:298,maxHealth:22300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:11218,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[12],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersGoblinSpearSpawn:[]}}},monsterHumanRoyalArcher:{initArhcer:{avatarClass:"human-royal-archer",name:"Ymir Warrior ( Archer )",
level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:30,posY:60,weaponEquip:"trajectory",weaponName:"arrowC",weaponWidth:48,weaponHeight:48,angleSpeed:1.3},attackRange:500,attackRangeMax:911,attackRangeMin:837,attackMax:327,attackMin:258,defenseMax:389,defenseMin:348,magicDefenseMax:335,magicDefenseMin:364,maxHealth:22800,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:12235,hpBar:"medium",
buffSkill:{},abilitySkill:{powerAgility:!0},modifierAbilities:{avoid:25},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[23],audioEnd:[]}],chance:100,delay:0},powerAgility:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersHumanRoyalArcherSpawn:[]}}},monsterHumanRoyalSpear:{initSpear:{avatarClass:"human-royal-spear",name:"Ymir Warrior ( Spear )",level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,
attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:1033,attackMin:942,defenseMax:412,defenseMin:398,magicDefenseMax:394,magicDefenseMin:354,maxHealth:23300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:12331,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[12],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersHumanRoyalSpearSpawn:[]}}},
monsterHumanRoyalArmor:{initArmored:{avatarClass:"human-royal-armor",name:"Ymir Warrior ( Armor )",level:26,monsterLevel:"C",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:893,attackMin:742,defenseMax:562,defenseMin:498,magicDefenseMax:394,magicDefenseMin:354,maxHealth:23300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:12412,hpBar:"medium",
buffSkill:{},abilitySkill:{piercingSpeed:!0,powerDefenese:!0},item:[],inventory:[],modifierAbilities:{block:30},attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[8],audioEnd:[]},{frameExtend:["attackB"],frame:[4],audioEnd:[]}],chance:100,delay:0},piercingSpeed:{frameContent:[{frameExtend:["attack"],frame:[]}],chance:100,delay:0,unique:!0},powerDefenese:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersHumanRoyalArmorSpawn:[{monsters:[],
objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterHumanRoyalArcher:2,monsterHumanRoyalSpear:2}}]}}},monsterMinatourArcher:{initArhcer:{avatarClass:"minatour-archer",name:"Minotaurus ( Archer )",level:26,monsterLevel:"B",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:30,posY:75,weaponEquip:"trajectory",weaponName:"arrowC",weaponWidth:48,weaponHeight:48,angleSpeed:1.3},attackRange:500,
attackRangeMax:991,attackRangeMin:817,attackMax:357,attackMin:238,defenseMax:469,defenseMin:418,magicDefenseMax:515,magicDefenseMin:464,maxHealth:27130,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"fast",initialSpeedAttack:25,initialAttackDelay:30,mp:15218,hpBar:"medium",buffSkill:{},abilitySkill:{powerAgilityIII:!0},item:[],inventory:[],modifierAbilities:{avoid:15,critical:15,criticalChance:35},attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[23],audioEnd:[]}],chance:100,
delay:0},powerAgilityIII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersMinatourArcherSpawn:[]}}},monsterMinatourSpear:{initSpear:{avatarClass:"minatour-armor",name:"Minotaurus ( Armor )",level:26,monsterLevel:"B",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:993,attackMin:842,defenseMax:562,defenseMin:498,magicDefenseMax:394,magicDefenseMin:354,maxHealth:26300,moveSpeedAttack:3.5,
moveSpeedNormal:2.5,initialSpeedNormal:"fast",initialSpeedAttack:25,initialAttackDelay:30,mp:13318,hpBar:"medium",buffSkill:{},modifierAbilities:{block:25},abilitySkill:{powerDefeneseIII:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[16],audioEnd:[]}],chance:100,delay:0},powerDefeneseIII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersMinatourSpearSpawn:[]}}},monsterMinatourMage:{initMage:{avatarClass:"minatour-mage",
name:"Minotaurus ( Mage )",level:26,monsterLevel:"B",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:0,posY:0,weaponEquip:"none",weaponName:"",weaponWidth:0,weaponHeight:0,angleSpeed:0},attackRange:500,attackRangeMax:1187,attackRangeMin:1146,attackMax:377,attackMin:356,defenseMax:469,defenseMin:418,magicDefenseMax:615,magicDefenseMin:564,maxHealth:33510,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"fast",initialSpeedAttack:25,initialAttackDelay:30,
mp:15218,hpBar:"medium",buffSkill:{},modifierAbilities:{avoid:25},abilitySkill:{abilitiesSteal:!0,bindingRoot:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[14],audioEnd:[]},{frameExtend:["attackB"],frame:[14],audioEnd:[]}],chance:100,delay:0},abilitiesSteal:{frameContent:[{frameExtend:["attack"],frame:[]}],chance:100,delay:0,unique:!0},bindingRoot:{frameContent:[{frameExtend:["attack"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersMinatourMageSpawn:[{monsters:[],
objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterMinatourArcher:1,monsterMinatourSpear:1,monsterMinatourDoubleSpear:1}}]}}},monsterMinatourDoubleSpear:{initSpear:{avatarClass:"minatour-spear",name:"Minotaurus ( Dual Sword )",level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:713,attackMin:672,defenseMax:302,
defenseMin:258,magicDefenseMax:294,magicDefenseMin:254,maxHealth:23500,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"fast",initialSpeedAttack:25,initialAttackDelay:30,mp:12008,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[20,22],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersMinatourDoubleSpearSpawn:[]}}},monsterBoarBlack:{initSpear:{avatarClass:"boar-black",name:"Angry Kobo",level:26,
monsterLevel:"B",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:783,attackMin:744,defenseMax:431,defenseMin:383,magicDefenseMax:394,magicDefenseMin:364,maxHealth:32300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:15543,hpBar:"medium",buffSkill:{},abilitySkill:{bodyCharge:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],
frame:[8],audioEnd:[]}],chance:100,delay:0},bodyCharge:{frameContent:[{frameExtend:["bodyCharge"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersBoarBlackSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterBoarBrown:1}}]}}},monsterBoarBrown:{initSpear:{avatarClass:"boar-brown",name:"Angry Kobo",level:26,monsterLevel:"B",aggresive:["tower","hero"],temporaryObjectSpawn:!1,
attackRange:100,attackRangeMax:141,attackRangeMin:127,attackMax:743,attackMin:694,defenseMax:391,defenseMin:363,magicDefenseMax:354,magicDefenseMin:314,maxHealth:29E3,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:15294,hpBar:"medium",buffSkill:{},abilitySkill:{bodyCharge:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[8],audioEnd:[]}],chance:100,delay:0},bodyCharge:{frameContent:[{frameExtend:["bodyCharge"],
frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersBoarBrownSpawn:[]}}},monsterWhiteBoarJr:{initSpear:{avatarClass:"white-boar-jr",name:"Wild Kobo",level:26,monsterLevel:"E",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:70,attackRangeMax:141,attackRangeMin:127,attackMax:793,attackMin:722,defenseMax:302,defenseMin:258,magicDefenseMax:294,magicDefenseMin:254,maxHealth:24300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",
initialSpeedAttack:25,initialAttackDelay:30,mp:11218,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[8],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersWhiteBoarJrSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:4,respawnLimit:3,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD"}]}}},monsterWhiteBoar:{initSpear:{avatarClass:"white-boar",name:"Wild Kobo",level:26,
monsterLevel:"E",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:70,attackRangeMax:141,attackRangeMin:127,attackMax:793,attackMin:722,defenseMax:302,defenseMin:258,magicDefenseMax:294,magicDefenseMin:254,maxHealth:24300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"fast",initialSpeedAttack:25,initialAttackDelay:30,mp:11218,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],
frame:[8],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersWhiteBoarSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:4,respawnLimit:3,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD"}]}}},monsterBugQueen:{initSpear:{avatarClass:"bug-queen",name:"Gaby Queen",level:26,monsterLevel:"D",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:80,attackRangeMax:181,attackRangeMin:137,attackMax:883,attackMin:772,defenseMax:382,
defenseMin:298,magicDefenseMax:348,magicDefenseMin:314,maxHealth:29250,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:11218,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[8],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersBugQueenSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:3,reSpawnTick:500,reSpawnTickFixed:500,
install:!1,location:"mapDungeonD",pions:{monsterBug:5}}]}}},monsterBug:{initSpear:{avatarClass:"bug",name:"Gaby soldier",level:26,monsterLevel:"E",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:70,attackRangeMax:141,attackRangeMin:127,attackMax:793,attackMin:722,defenseMax:302,defenseMin:258,magicDefenseMax:294,magicDefenseMin:254,maxHealth:23300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:11218,hpBar:"medium",
buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[8],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersBugSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD"}]}}},monsterGolem:{initSpear:{avatarClass:"golem",name:"Golem",level:26,monsterLevel:"C",npcType:"monster-leader",aggresive:["tower","hero"],temporaryObjectSpawn:!1,attackRange:100,
attackRangeMax:271,attackRangeMin:257,attackMax:1074,attackMin:1023,defenseMax:412,defenseMin:368,magicDefenseMax:348,magicDefenseMin:314,maxHealth:27510,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:13218,hpBar:"medium",buffSkill:{},abilitySkill:{teleport:!0,powerAgilityII:!0},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[12],audioEnd:[]}],chance:100,delay:0},summon:{frameContent:[{frameExtend:["summon"],
frame:[]}],chance:100,delay:0,unique:!0},teleport:{frameContent:[{frameExtend:["die"],frame:[]}],chance:100,delay:0,unique:!0},powerAgilityII:{frameContent:[{frameExtend:["idle"],frame:[]}],chance:100,delay:0,unique:!0}},audioDie:[],spawn:{monstersGolemSpawn:[{monsters:[],objectSpawn:"staticOriDngDPassSpawnE",spawnTotal:1,respawnLimit:2,reSpawnTick:500,reSpawnTickFixed:500,install:!1,location:"mapDungeonD",pions:{monsterFireElemental:2,monsterElementalLight:2}}]}}},monsterFireElemental:{initMage:{avatarClass:"fire-elemental",
name:"Fire Elemental",level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:0,posY:0,weaponEquip:"none",weaponName:"",weaponWidth:0,weaponHeight:0,angleSpeed:0},attackRange:500,attackRangeMax:961,attackRangeMin:917,attackMax:357,attackMin:238,defenseMax:369,defenseMin:318,magicDefenseMax:515,magicDefenseMin:464,maxHealth:23300,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:11251,hpBar:"medium",
buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[14],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersFireElementalSpawn:[]}}},monsterElementalLight:{initMage:{avatarClass:"light-elemental",name:"Earth Elemental",level:26,monsterLevel:"C",aggresive:["tower","hero"],temporaryObjectSpawn:!1,trajectoryProp:{posX:0,posY:0,weaponEquip:"none",weaponName:"",weaponWidth:0,weaponHeight:0,angleSpeed:0},attackRange:500,attackRangeMax:961,
attackRangeMin:917,attackMax:357,attackMin:238,defenseMax:399,defenseMin:358,magicDefenseMax:515,magicDefenseMin:464,maxHealth:23610,moveSpeedAttack:3.5,moveSpeedNormal:2.5,initialSpeedNormal:"normal",initialSpeedAttack:25,initialAttackDelay:30,mp:11241,hpBar:"medium",buffSkill:{},abilitySkill:{},item:[],inventory:[],attackFrame:{normal:{frameContent:[{frameExtend:["attack"],frame:[14],audioEnd:[]}],chance:100,delay:0}},audioDie:[],spawn:{monstersElementalLightSpawn:[]}}}},shop:{healthStrongPotion:{root:"magic",
price:28,max:99,available:"~"},healthMediumPotion:{root:"magic",price:13,max:99,available:"~"},healthPotion:{root:"magic",price:5,max:99,available:"~"},manaStrongPotion:{root:"magic",price:28,max:99,available:"~"},manaMediumPotion:{root:"magic",price:13,max:99,available:"~"},manaPotion:{root:"magic",price:5,max:99,available:"~"},explosionRedBoom:{root:"magic",price:55,max:99,available:"~"},explosionBlueBoom:{root:"magic",price:55,max:99,available:"~"},blueJewel:{root:"magic",price:12500,max:1,available:2},
redJewel:{root:"magic",price:12500,max:1,available:2},greenJewel:{root:"magic",price:22500,max:1,available:1},ornamentPurple:{root:"magic",price:5E3,max:1,available:2},ornamentGreen:{root:"magic",price:7500,max:1,available:1},greenLightNecklace:{root:"magic",price:3500,max:1,available:1},goldGemStone:{root:"magic",price:2500,max:1,available:4},redGemStone:{root:"magic",price:22500,max:1,available:1},golemSummoner:{root:"magic",price:2500,max:1,available:10},sekletonSummoner:{root:"magic",price:3500,
max:1,available:10}},assets:{imgOnload:"ornament-green.png green-jewel.png cross-line.png disable-skill.png quest.png skill.png speaker-off.png speaker-on.png transparentDark48.png cog.png you-win-before.png ornament-purple.png BagWhite.png attack-icon.png auto-off.png auto-on.png backpack.png green-cycrle.png purple-cycrle-ring.png neutral-icon.png you-lose.png you-win.png eliminated-enemy.png eliminated-tower.png upper-attack.png sekleton-summoner.png golem-summoner.png red-gem-stone.png red-jewel.png slice-attack.png shop.png switch-loading.png switch-ready.png throw-boom.png mana-medium-potion.png manaPosition.png mana-strong-potion.png mana-strong-potion-bg.png health-strong-potion.png health-strong-potion-bg.png health-medium-potion.png healthPotion.png arrow-rain.png rolling-attack.png piercing-shoot.png protection.png explosion-blue.png explosion-red.png blue-jewel.png Gems_03.png gold-mine.png gold-stack.png green-light-necklace.png elemental.png elemental-armor.png elf-archer.png elf-armor.png elf-mage.png elf-spear.png fire-elemental.png goblin-archer.png goblin-armor.png goblin-mage.png goblin-spear.png goblin-warrior-archer.png goblin-warrior-armor.png goblin-warrior-mage.png goblin-warrior-spear.png human-archer.png human-armor.png human-mage.png human-royal-archer.png human-royal-armor.png human-royal-spear.png light-elemental.png minatour-archer.png minatour-armor.png minatour-mage.png minatour-spear.png minotaur.png next.png play.png previous.png rolling-dices-green.png rolling-dices-orange.png rolling-dices-red.png sekleton-archer.png sekleton-armor.png sekleton-spear.png sekleton-warrior-archer.png sekleton-warrior-boomber.png sekleton-warrior-mage.png vampire.png white-boar.png white-boar-jr.png wolf-archer.png wolf-hummer.png wolf-mage.png wolf-spear.png wolf-white.png yeti.png yeti-alpha.png ava-hero-archer.png ava-hero-armor.png golem.png tower-red.png tower-redb.png tower-blue.png beast.png beast-armor.png bug-red.png bug-green.png boar-black.png boar-brown.png bug.png bug-queen.png close-b.png cover-en.png cover-id.png treasure-map.png".split(" "),
img:"dot-orange.png dot-red.png arrow-map.png arrow-map-hit.png abilities-steal-small.png beresek-shield.png beresek-small.png binding-root-small.png black-cycrle.png black-cycrle-ring.png block.png bloodDrainSmall.png blue-boom-small.png blue-cycle.png blue-cycle-inner.png blue-cycle-outter.png cycle.png blue-ring.png boom.png burningEffectSmall.png cycrle-hit.png cycrle-hit-2.png cycrle-hit-3.png cycrle-skill.png cycrle-skill-2.png cycrle-skill-3.png defense-steal-small.png grey-cycrle.png grow-howl-small.png healingSmall.png healing-small.png hp-medium-bar.png hp-medium-cover.png intimidationSmall.png mind-control-small.png miss.png power-agility-iii-small.png power-agility-ii-small.png power-agility-small.png power-defense-iii-small.png power-defense-ii-small.png power-defense-small.png protectionSmall.png protection-shield.png red-cyrcle.png red-ring.png red-ring-cyrcle.png red-rings.png stun.png tower-icon.png tower-red-ring.png tower-red-cyrcle.png hit-num-color.png hit-num-color-bold.png hit-num-color-heal.png info.png help.png dot-blue.png dot-purple.png".split(" "),
audio:"bg-2.ogg bg-3.ogg bg-start.ogg bg-start-2.ogg bg-end.ogg bg-epic.ogg bg-critical.ogg arrow-fly-2.ogg Bassy_swoosh.ogg evil-swish.ogg explosion.ogg footstep.ogg grunt-2.ogg grunt-3.ogg grunt-7.ogg grunt-9.ogg heat-impact.ogg Inventory_Open_01.ogg inventory-close.ogg item-drop.ogg item-pick.ogg Pickup_Gold_04.ogg shiled-blocking.ogg stab.ogg swing.ogg swing2.ogg swing3.ogg tab-selected.ogg".split(" ")}}}(this||window);
!function(e,n,t){function r(e,n){return typeof e===n}function o(){var e,n,t,o,i,a,s;for(var l in h)if(h.hasOwnProperty(l)){if(e=[],n=h[l],n.name&&(e.push(n.name.toLowerCase()),n.options&&n.options.aliases&&n.options.aliases.length))for(t=0;t<n.options.aliases.length;t++)e.push(n.options.aliases[t].toLowerCase());for(o=r(n.fn,"function")?n.fn():n.fn,i=0;i<e.length;i++)a=e[i],s=a.split("."),1===s.length?Modernizr[s[0]]=o:(!Modernizr[s[0]]||Modernizr[s[0]]instanceof Boolean||(Modernizr[s[0]]=new Boolean(Modernizr[s[0]])),Modernizr[s[0]][s[1]]=o),w.push((o?"":"no-")+s.join("-"))}}function i(e){var n=S.className,t=Modernizr._config.classPrefix||"";if(x&&(n=n.baseVal),Modernizr._config.enableJSClass){var r=new RegExp("(^|\\s)"+t+"no-js(\\s|$)");n=n.replace(r,"$1"+t+"js$2")}Modernizr._config.enableClasses&&(n+=" "+t+e.join(" "+t),x?S.className.baseVal=n:S.className=n)}function a(){return"function"!=typeof n.createElement?n.createElement(arguments[0]):x?n.createElementNS.call(n,"http://www.w3.org/2000/svg",arguments[0]):n.createElement.apply(n,arguments)}function s(e,n){return!!~(""+e).indexOf(n)}function l(){var e=n.body;return e||(e=a(x?"svg":"body"),e.fake=!0),e}function u(e,t,r,o){var i,s,u,f,c="modernizr",p=a("div"),d=l();if(parseInt(r,10))for(;r--;)u=a("div"),u.id=o?o[r]:c+(r+1),p.appendChild(u);return i=a("style"),i.type="text/css",i.id="s"+c,(d.fake?d:p).appendChild(i),d.appendChild(p),i.styleSheet?i.styleSheet.cssText=e:i.appendChild(n.createTextNode(e)),p.id=c,d.fake&&(d.style.background="",d.style.overflow="hidden",f=S.style.overflow,S.style.overflow="hidden",S.appendChild(d)),s=t(p,e),d.fake?(d.parentNode.removeChild(d),S.style.overflow=f,S.offsetHeight):p.parentNode.removeChild(p),!!s}function f(e){return e.replace(/([A-Z])/g,function(e,n){return"-"+n.toLowerCase()}).replace(/^ms-/,"-ms-")}function c(n,t,r){var o;if("getComputedStyle"in e){o=getComputedStyle.call(e,n,t);var i=e.console;if(null!==o)r&&(o=o.getPropertyValue(r));else if(i){var a=i.error?"error":"log";i[a].call(i,"getComputedStyle returning null, its possible modernizr test results are inaccurate")}}else o=!t&&n.currentStyle&&n.currentStyle[r];return o}function p(n,r){var o=n.length;if("CSS"in e&&"supports"in e.CSS){for(;o--;)if(e.CSS.supports(f(n[o]),r))return!0;return!1}if("CSSSupportsRule"in e){for(var i=[];o--;)i.push("("+f(n[o])+":"+r+")");return i=i.join(" or "),u("@supports ("+i+") { #modernizr { position: absolute; } }",function(e){return"absolute"==c(e,null,"position")})}return t}function d(e){return e.replace(/([a-z])-([a-z])/g,function(e,n,t){return n+t.toUpperCase()}).replace(/^-/,"")}function y(e,n,o,i){function l(){f&&(delete E.style,delete E.modElem)}if(i=r(i,"undefined")?!1:i,!r(o,"undefined")){var u=p(e,o);if(!r(u,"undefined"))return u}for(var f,c,y,m,v,g=["modernizr","tspan","samp"];!E.style&&g.length;)f=!0,E.modElem=a(g.shift()),E.style=E.modElem.style;for(y=e.length,c=0;y>c;c++)if(m=e[c],v=E.style[m],s(m,"-")&&(m=d(m)),E.style[m]!==t){if(i||r(o,"undefined"))return l(),"pfx"==n?m:!0;try{E.style[m]=o}catch(h){}if(E.style[m]!=v)return l(),"pfx"==n?m:!0}return l(),!1}function m(e,n){return function(){return e.apply(n,arguments)}}function v(e,n,t){var o;for(var i in e)if(e[i]in n)return t===!1?e[i]:(o=n[e[i]],r(o,"function")?m(o,t||n):o);return!1}function g(e,n,t,o,i){var a=e.charAt(0).toUpperCase()+e.slice(1),s=(e+" "+P.join(a+" ")+a).split(" ");return r(n,"string")||r(n,"undefined")?y(s,n,o,i):(s=(e+" "+z.join(a+" ")+a).split(" "),v(s,n,t))}var h=[],C={_version:"3.5.0",_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,n){var t=this;setTimeout(function(){n(t[e])},0)},addTest:function(e,n,t){h.push({name:e,fn:n,options:t})},addAsyncTest:function(e){h.push({name:null,fn:e})}},Modernizr=function(){};Modernizr.prototype=C,Modernizr=new Modernizr;var w=[],S=n.documentElement,x="svg"===S.nodeName.toLowerCase(),_=function(){function e(e,n){var o;return e?(n&&"string"!=typeof n||(n=a(n||"div")),e="on"+e,o=e in n,!o&&r&&(n.setAttribute||(n=a("div")),n.setAttribute(e,""),o="function"==typeof n[e],n[e]!==t&&(n[e]=t),n.removeAttribute(e)),o):!1}var r=!("onblur"in n.documentElement);return e}();C.hasEvent=_;var b="Moz O ms Webkit",P=C._config.usePrefixes?b.split(" "):[];C._cssomPrefixes=P;var T={elem:a("modernizr")};Modernizr._q.push(function(){delete T.elem});var E={style:T.elem.style};Modernizr._q.unshift(function(){delete E.style});var z=C._config.usePrefixes?b.toLowerCase().split(" "):[];C._domPrefixes=z,C.testAllProps=g;var N=function(n){var r,o=prefixes.length,i=e.CSSRule;if("undefined"==typeof i)return t;if(!n)return!1;if(n=n.replace(/^@/,""),r=n.replace(/-/g,"_").toUpperCase()+"_RULE",r in i)return"@"+n;for(var a=0;o>a;a++){var s=prefixes[a],l=s.toUpperCase()+"_"+r;if(l in i)return"@-"+s.toLowerCase()+"-"+n}return!1};C.atRule=N;C.prefixed=function(e,n,t){return 0===e.indexOf("@")?N(e):(-1!=e.indexOf("-")&&(e=d(e)),n?g(e,n,t):g(e,"pfx"))};Modernizr.addTest("audio",function(){var e=a("audio"),n=!1;try{n=!!e.canPlayType,n&&(n=new Boolean(n),n.ogg=e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),n.mp3=e.canPlayType('audio/mpeg; codecs="mp3"').replace(/^no$/,""),n.opus=e.canPlayType('audio/ogg; codecs="opus"')||e.canPlayType('audio/webm; codecs="opus"').replace(/^no$/,""),n.wav=e.canPlayType('audio/wav; codecs="1"').replace(/^no$/,""),n.m4a=(e.canPlayType("audio/x-m4a;")||e.canPlayType("audio/aac;")).replace(/^no$/,""))}catch(t){}return n}),o(),i(w),delete C.addTest,delete C.addAsyncTest;for(var A=0;A<Modernizr._q.length;A++)Modernizr._q[A]();e.Modernizr=Modernizr}(window,document)
;window.owlData.isDeviceread = false; document.addEventListener("deviceready",function(){screen.orientation.lock("landscape");window.owlData.isDeviceread=!0},!1);T(window,window.owlData)}( 
 
 function( global, owlData ){
		

	var transformProp = Modernizr.prefixed('transform');
	var translateProp = Modernizr.prefixed('transition') ;
	var transEndEventNames = {
		'WebkitTransition' : 'webkitTransitionEnd', 
		'MozTransition'    : 'transitionend',   
		'transition'       : 'transitionend'   
	}
	var translateEndProp = transEndEventNames[ translateProp ];

	var _owlBird = _owlBird || {};
	_owlBird.register = _owlBird.register || {};
	_owlBird.namespace = _owlBird.namespace || {};
	_owlBird.namespace['__namespace__'] = []
	_owlBird.args = _owlBird.args || [];

	_owlBird.utils = function( )
	{
		var scope = this, self = function(){};

		self.prototype = {

			slice : function(args, index){
				return index && Array.prototype.slice.call(args, index)[0] || Array.prototype.slice.call(args)
			},

			objToString : function(obj){
				return Object.prototype.toString.call(obj);
			},

			hasClassName : function(element,a){ return new RegExp("(?:^|\\s+)" + a + "(?:\\s+|$)").test(element.className) },

			delayFire : function(){
			  var timer = setTimeout(function(){});
			  return function(firecallback, ms){
				clearTimeout (timer);
				timer = setTimeout(firecallback, ms);
			  };
			}(),
			

			delay : (function(){
			 var temp = _owlBird.args, args, prop, self, F;

			  return function(){
					args  = arguments,
					F = function(){
						for(var ii in args) this[ii] = args[ii];
						this['populate']()
					};

					prop = Object.create( F.prototype = {
						populate : function(){
							self = Object.create( this )
							if(temp.length > 0){
								for(var ii = 0, jj = temp, kk = 0; ii < jj.length; ii++){
									if(jj[ii]['0'] === this['0'] )
										kk++;

									if(!kk && ii === (jj.length - 1)){
										temp.push( self )
										break;
									}
								}
							}else{
								temp.push( self )
							}

						},

						fire : function(){
							if(temp.length > 0)
							{
								for(var ii in temp){
									setTimeout(function(fnn,ms){
										fnn.call(null)
									}.bind(this, temp[ii]['0']),temp[ii]['1'])
								}

								temp.length = 0;
							}
						}
					})

					new F && this.delayFire && this.delayFire(function(){
						prop.fire()
					},100)
				}
			}()),

			attachListener : function( el, listener, callback ){

				function _parentAttach( el, lstn, callback ){

					function _attach( el, lstn ){
						if(el !== window){
							el.addEventListener(lstn, callback, false);
						}else{
							el.attachEvent && el.attachEvent('on'+lstn, callback) ||
								el.addEventListener(lstn, callback, false)
						}
						
						if( lstn === 'mousedown' ){
							el.addEventListener( 'touchstart', callback, false)
						}
						else if( lstn === 'mousemove'){
							el.addEventListener( 'touchmove', callback, false)
						}
						else if( lstn === 'mouseup'){
							el.addEventListener( 'touchend', callback, false)
						}
						else if( lstn === 'mouseout'){
							el.addEventListener( 'touchleave', callback, false)
						}

					}

					lstn = lstn.indexOf(' ')  === -1 ? lstn : lstn.split(' ');
					lstn = lstn.length <= 1 ? lstn.join('') : lstn;

					if(lstn instanceof Array)
					{
						while(lstn.length)
							_attach( el, lstn.pop() );
					}else
						_attach( el, lstn );
				}

				if( this.objToString &&
					'[object Array]' === this.objToString( el ))
					{
						while(el.length)
						{
							_parentAttach( el.pop(), listener, callback);
						}
				}else{

					_parentAttach( el, listener, callback )

				}
			},

			inArray : function (a, b){
				while(b.length)
					if(b.pop() === a) return true;
				return false;
			},

			removeClassFn : function (el, className) {
				if(-1 !== className.indexOf(' ') && className.split(' ').length > 1){
					var test = el.className.toLowerCase().split(' ');
					for (var ii = test.length - 1; ii >= 0 ; ii--){
						if(this.inArray(test[ii], className.split(' ')))
							delete test[ii];
					}

					el.className = test.join(' ');
				}else if(this.hasClassName(el, className)) {
					var a = el.className;
					el.className = a.replace(new RegExp("(?:^|\\s+)" + className + "(?:\\s+|$)", "g"), " ");
				}
			},

			addClassFn : function (el, className) {
				if (!this.hasClassName(el, className)) {
					el.className = [el.className, className].join(" ");
				}
			},

			isTwoDimensional : function(el){
				return /([object Array])/i.test(this.objToString(el))
					&& this.slice(el,0).length ? true : false
			}
		}

		for(var ii in (new self))
			this[ii] = (new self)[ii];
		
		this.isMobile = function(){
			return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
		}
		
		this.encodeStr = function(rawStr){
			return encodedStr = rawStr.replace(/[\u00A0-\u9999<>\&]/gim, function(i) {
			   return '&#'+i.charCodeAt(0)+';';
			})
		}

		this.normalizingMousewheel = function(evt){
			//http://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers
			//http://phrogz.net/JS/wheeldelta.html
			 if (!evt) evt = event;
			  var w=evt.wheelDelta, d = evt.detail;
			  if (d){
				if (w) return w/d/40*d>0?1:-1; // Opera
				else return -d/3;              // Firefox;         TODO: do not /3 for OS X
			  } else return w/120;             // IE/Safari/Chrome TODO: /3 for Chrome OS X
		}

		this.random = function(max,min){
			return Math.floor(Math.random()* (max - min +1) + min);
		}

		this.randomFloat = function(min,max){
			return (Math.random() * (min - max) + max);//.toFixed(2);
		}
		
		this.randomArray = function( array ){
			
			for (var i = array.length - 1; i > 0; i--) {
				var j = Math.floor(Math.random() * (i + 1));
				var temp = array[i];
				array[i] = array[j];
				array[j] = temp;
			}
			
			return array;
		}
		
		this.uniqueString = function() {
			return Math.random().toString(36).slice(-8)
		};
		
		this.uniqueId = function() {
			return this.random(999,100)+'-'+Math.random().toString(36).slice(-8)
		};
		
		this.uniqueArray = function( dupArray ){
		
			dupArray.slice() // slice makes copy of array before sorting it
			  .sort(function(a,b){
				return a > b;
			  })
			  .reduce(function(a,b){
				if (a.slice(-1)[0] !== b) a.push(b); // slice(-1)[0] means last item in array without removing it (like .pop())
				return a;
			  },[]);
			  
			return dupArray;
		}
		
		this.detectLeftButton = function(event){
			if ('buttons' in event) {
				return event.buttons === 1;
			} else if ('which' in event) {
				return event.which === 1;
			} else {
				return event.button === 1;
			}
		}

		this.detectRightButton = function(event){
			var isRightMB,
			event = event || window.event;
			if ("which" in event)  // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
				return event.which == 3;
			else if ("button" in e)  // IE, Opera
				return event.button == 2;

		}

		this.cancelBubble = function(evt){
				var evt = this ? evt:window.event;
				if (evt.stopPropagation)    evt.stopPropagation();
				if (evt.cancelBubble!=null) evt.cancelBubble = true;
				evt.preventDefault()
		}
		
		
		this.nthParent = function(element, n) {
		  while(n-- && element)  
			element = element.parentNode;
		  return element;
		}
		
		this.runFirst =	(function(){

		  var timer = 0, temp = true;

		  return function(callback, ms){

			this.delay(function(){
				temp = true;
			},100)

			if(temp){
				setTimeout(callback.bind(this), ms);
				temp = false;
			}

		  };

		})()

		this.parentLastchild = function(el){

			var temp = [];
			do {
				 el =  el.nextSibling;

				 if(el.nodeType == 1){
					temp.push(el)
				 }
			}

			while (el.nextSibling);


			return temp[temp.length - 1];
		}

		this.parentFirstchild = function(el){

			var temp = [];
			do {
				 el =  el.previousSibling;

				 if(el.nodeType == 1){
					temp.push(el)
				 }
			}

			while (el.previousSibling);

			return temp[temp.length - 1];
		}
		
		this.getLastChild = function(el){
			var temp = [],
			firstChild = scope.getFirstChild( el );
			
			do {
				 var firstChild =  firstChild.nextSibling;

				 if( firstChild.nodeType == 1 ){
					temp.push( firstChild )
				 }
			}

			while ( firstChild.nextSibling);
			

			return temp[temp.length - 1];
		}
		
		this.getFirstChild = function(el){
			  var f = el.firstChild;
			  while( f && f.nodeType == 3 ){
					f = f.nextSibling;
			  }
			  return  f === null ? false : f;

		}

		this.sibling = function (el,prev) {

			do {
				el = prev == 'previous' ?
					 el.previousSibling :
					 el.nextSibling;
			}

			while (el && el.nodeType != 1);

			return el === null ? false : el;
		}

		this.qsAll = function(idClass, activeEl){
			var idClass = idClass.indexOf('.') === -1 ? '.'+idClass : idClass;
			return !!activeEl && activeEl.querySelectorAll(idClass) || document.querySelectorAll(idClass)
		}

		this.qs = function(idClass, activeEl){

			var idClass = idClass.indexOf('.') === -1 ? '.'+idClass : idClass;

			return !!activeEl && activeEl.querySelector(idClass) || document.querySelector(idClass)

		}

		this.id = function id(idName){
			return document.getElementById(idName)
		}

		this.addClass = function (el, className) {
			
			 if(this.isTwoDimensional(el)){
				for(var ii = el.length - 1; ii >= 0; ii--){
					this.addClassFn(
						el[ii][0],el[ii][1])
				}
			 }else{
				this.addClassFn(el,className)
			 }
		}

		this.removeClass = function (el, className) {
			if(this.isTwoDimensional(el)){
				for(var ii = el.length - 1; ii >= 0; ii--){
					this.removeClassFn(
						el[ii ][0],el[ii][1])
				}
			 }else{
				this.removeClassFn(el,className)
			 }
		}

		this.css = function (element, obj, trans) {
			var scope = this, objContent, objContentTranslate;
			function fn(el)
			{
				for (var key in obj) if (key in obj)
				{
					objContent = obj[key];
					switch(key)
					{
					//transform translate3d
					case 'transform':
						objContent = obj[key].split(','),
						x = objContent[0],
						y = objContent[1],
						z = objContent[2],
						objContentTranslate = "translate3d("+x+","+y+","+z+")";
						el.style[transformProp] = objContentTranslate;

						break;


					//transitions
					case 'transition':
							objContent = obj[key];
							objContentTranslate = objContent;
							el.style[ translateProp ] = objContentTranslate
						break;

					//default
					default :
						el.style[ key ] = objContent;
					}
				}
			}

			//el always return an empty object to know that it is an array or not need dirty hack
			if(!!element.nodeName){
				//node element
				fn(element)
			}else{
				for(var ii = element.length; ii > 0; ii--){
					fn(element[ii - 1])
				}
			}
		}

		this.text = function (el, text) {
			
			el.innerText = text ;
			
			//el.innerText ? el.innerText = text : el.textContent = text;
		};
		
		this.ucFirst = function (string) {
			return string.charAt(0).toUpperCase() + string.slice(1);
		}
		
		this.intersectsCircle = function(x, y, cx, cy, r){
			//http://stackoverflow.com/questions/2212604/javascript-check-mouse-clicked-inside-the-circle-or-polygon/2212851#2212851
			var dx = x-cx,
				dy = y-cy
			//collision between cricle and pointer but it is useless to apply to poly
			return dx * dx + dy * dy <= r * r
		}
	 
		this.extend = function(obj, _obj, deep){
			if(deep === true){
				for(var ii in _obj) if(ii in _obj) obj[ii] = _obj[ii];
			}else{
				state: for(var ii in _obj) if(ii in _obj)
				{
					for(var jj in obj) {
						if(jj in obj
							&& ii.toLowerCase() === jj.toLowerCase()
							&& ii.toLowerCase().indexOf('strict') !== -1){
								continue state;
						}
					}

					if('function' === typeof _obj[ii]){
						obj[ii] = _obj[ii]
						obj[ii]()
					}else{
						obj[ii] = _obj[ii]
					}
				}
			}
			
			return obj;
		}

		this.requestAnimFrame = function(){
			return (
				window.requestAnimationFrame       ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame    ||
				window.oRequestAnimationFrame      ||
				window.msRequestAnimationFrame     ||
				function(/* function */ callback){
					window.setTimeout(callback, 1000 / 60);
				}
			);
		}();
		
		this.objCount = function( obj ){
			var count = 0;
			for( var ii in obj ) count++;
			return count;
		}

		var isTangible = !!('createTouch' in document)
		//Touch and mouse Events
		this.CursorStartEvent = isTangible ? 'touchstart' : 'mousedown';//mousedown
		this.CursorMoveEvent = isTangible ? 'touchmove' : 'mousemove';//mousemove
		this.CursorEndEvent = isTangible ? 'touchend' : 'mouseup';//mouseup
		this.CursorLeaveEvent = isTangible ? 'touchleave' : 'mouseout';//mouseout

		this.accessor = function( __obj )
		{
			var namespace = __obj.namespace
			var registeredNamespace = namespace['__namespace__'];
			var global = __obj.global,  accessorName = __obj.accessorName;
			O = Object.create( new function()
			{
				return  Object.defineProperty( __obj, accessorName,
				{
					set : function ()
					{
						scope.slice(arguments).forEach( function(_obj)
						{
							!!namespace[ '_initialize'+accessorName ] ?
								namespace[ '_initialize'+accessorName ].push( _obj ):
								namespace[ '_initialize'+accessorName ] = [ _obj ];

							for(var ii = 0, jj = registeredNamespace; ii < jj.length ; ii++)
							{
								for(var kk in global) if (kk in global){

									jj[ii][kk] = Object.defineProperty({ invoke : kk }, 'value',
									{
										get: function ()
										{
											return global[this.invoke];
										},
										set: function (value)
										{
											for(var jj in this) if( jj in this){

												if(!(jj ===  'value'))
												{
													global[this[jj]] = value;
													for(var ll = registeredNamespace , kk = ll.length; kk--;)
													{
														if(!(ll[kk] === _obj) && this[jj] in ll[kk])
														ll[kk][this[jj]] = this;
													}
												}
											}
										},
										enumerable: true
									})
								}
							}
						})
					}
				})
			})

			O[ accessorName ] = this;

			namespace[ '_revoke'+accessorName ] = O;
		}
		
 
		this.cloneImg = function( url ){
			var sourceImage = document.createElement('img');
			sourceImage.src = url;
			return sourceImage.cloneNode(true);
		}
 
		this.createTexture = function( url ){
			var gl = scope.context;
			var tex = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, tex);
			// Fill the texture with a 1x1 blue pixel.
			
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
						  new Uint8Array([0, 0, 255, 255]));

			// let's assume all images are not a power of 2
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			
			
			urlFilter = url.split("//").join("/")
			var textureInfo = {
			  width: 1,   // we don't know the size until it loads
			  height: 1,
			  texture: tex,
			  complete : false,
			  url : urlFilter
			};
			
			 
			var img = scope.globalImage.get( urlFilter );
			if( !img  ){
				
				//prevent an error when img.src return undefined
				if( urlFilter && !/undefined/i.test( urlFilter ) ){
					 
					var img = new Image();
					img.src = urlFilter;
					scope.globalImage.set( urlFilter, img );
 
					img.addEventListener('load', function() {
					
					  textureInfo.width = img.width;
					  textureInfo.height = img.height;
					  gl.bindTexture(gl.TEXTURE_2D, textureInfo.texture);
					  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
					  textureInfo.complete = true
					});
				
				}
				
			}else if( img.complete ){
				textureInfo.width = img.width;
				textureInfo.height = img.height;
				gl.bindTexture( gl.TEXTURE_2D, textureInfo.texture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img );
				
				
			}
			
			
			

			return textureInfo;
			
		}
		
		this.setTextureNpc =  function( initialName, textures ){
			
			scope.globalImagePair.set( initialName, textures )
			
			return textures;
			
		}
		
		this.removeTextureNpc = function( gl, object ){
			
			var monsterControl = scope.monsterControl,
			glStorage = scope.globalImagePair.storage,
			initialRemove = object.initialName.toLowerCase(),
			fn = function( pairTextures ){
				for(var ii in pairTextures )
				{ 
					for( var jj in pairTextures[ii] )
					{//left / right
						var behaveRig = pairTextures[ii][ jj ];
						
						for( var kk in behaveRig )
						{ // remove gl texture content
							var texture = behaveRig[kk].texture;
							gl.deleteTexture( texture );
						}
						
					}
				}
			},
			initRemove = true;
			
			for(var ii = 0, jj = monsterControl.objSpawnMonster; ii < jj.length; ii++ ){
				
				var  spawnObj = jj[ii];
				spawnObj.forEach(function( objSpawn ){
					
					objSpawn.monsters.forEach(function( objMonster ){
						
						if( objMonster.object.initialName.toLowerCase() === initialRemove && 
							!objMonster.object.rigBody.remove ){
							 
							initRemove = false
							
						}
						
					})
					    
				})
			}
			
			 
			if( initRemove ){
				
				glStorage.forEach(function( obj ){
				
					if( initialRemove.toLowerCase() === obj.name ){
						  
						fn( obj.status ) //remove pairTexture from glStorage
						fn( object.render.textures ) //remove pairTexture from render object
						 
					}
					
				}) 
				
				scope.globalImagePair.remove( initialRemove );
				 
			}
			
			
		}
		 
		this.setTextureNonNpc = function( initialName, render, src ){
			var getTexture = scope.glTest[ render.uniqueString ];
			
			if( !getTexture || getTexture.deleted ){
				
				var test = scope.glTest, isReg = true;
				for(var ii in test ){
					var tex = test[ ii ];
					if( tex.initialName === initialName ){
						
						if( tex.deleted ){
							tex.texture =  this.createTexture( src );
							tex.deleted = false;
						}
						
						render.uniqueString = test[ ii ].uniqueString;
						getTexture = test[ ii ];
						isReg = false;
						break
					}
				}
				
				if( isReg ){
					
					var uStr = scope.uniqueString(),
					getTexture =  {
						deleted : false,
						initialName : initialName,
						uniqueString : uStr,
						texture : this.createTexture( src )
					};
					render.uniqueString = uStr
					scope.glTest[ uStr ] = getTexture
			
				}
			}
			
			return getTexture.texture
		}
		
		this.registerTextureNonNpc = function( gl, image, parentRender ){
			
			var regList = scope.intervalList[ parentRender.uniqueString ]
			
			if( regList ){
				
				regList.tick = 10;
				
			}else{
			
				scope.intervalList[ parentRender.uniqueString ] = {
					tick : 10,
					always : true,
					alreadyExecuted : false,
					fn : function(){
						if( !this.alreadyExecuted ){
							
							gl.deleteTexture( image.texture );
							gl.deleteTexture( parentRender.textures.texture );
							scope.glTest[ parentRender.uniqueString ].deleted = true;
							
							this.alreadyExecuted =  true;
							this.always = false;
						}
					}
				}
			}
		}
		
		this.getTexture = function( render, imagePath, state, initialName ) {
			
			var image = render.textures, getTexture;
			 
			if( !image && ( imagePath.indexOf('left') !== -1 || imagePath.indexOf('right') !== -1 ) ){
				
				//npc only
				getTexture = scope.globalImagePair.get( initialName ); 
				
				if( !getTexture ){
					
					var src = imagePath.split( initialName )[0].split("//").join("/"), imgPairRight = {}, imgPairLeft = {};
					for( var ii = 0, jj = render.behave; ii < jj.length ; ii++ ){
						imgPairRight[ jj[ii] ] = this.createTexture(  src + initialName +"-"+ jj[ii] +"-right.png" );
						imgPairLeft[ jj[ii] ] = this.createTexture(  src + initialName +"-"+ jj[ii] +"-left.png" );
					}
					
					render.textures = this.setTextureNpc( initialName, {
						pairTextures : {
							left : imgPairLeft,
							right : imgPairRight
						}
					});
				}else{
					render.textures = getTexture;
				}
				 
				render.latest = /left/i.test( imagePath ) ? 'left' : 'right'; 
				render.initialName = initialName;
				
				//npc texture
				
				return /left/i.test( imagePath ) ? render.textures.pairTextures.left : render.textures.pairTextures.right
				
			}
			
			
			if( state  && /textureNeedChange/i.test( state ) ){
				
				//npc only
				var getSrc = state.split('|')[1], pairSrc;
				
				render.latest = /left/i.test( getSrc ) ? 'left' : 'right';
				
				return /left/i.test( getSrc ) ? image.pairTextures.left : image.pairTextures.right
			}
			
			
			if (image){
				
				if ( image.pairTextures ){
					
					//npc only
					
					var getPairImg = render.latest.indexOf('left') !== -1 ? image.pairTextures.left : image.pairTextures.right;
					getTexture = scope.globalImagePair.get( initialName );
					
					return  getPairImg;
				}
				 
				
				if( imagePath.indexOf('ornaments') !== -1 ){
					var  getTexture = scope.setTextureNonNpc( imagePath, render, imagePath );
					
					scope.registerTextureNonNpc(  scope.context, getTexture , render );
					image = render.textures = getTexture;
				
					
				}
				
				
				
				return image;
			}
			
			
			var src = imagePath,
			getTexture = scope.setTextureNonNpc( src, render, src );
			
			
			image = render.textures = getTexture;
			render.initialName = src;
			
			
			
			if( imagePath.indexOf('ornaments') !== -1 ){
				scope.registerTextureNonNpc(  scope.context, getTexture, render  )
			}
				
			return image;
			
		};
		
		this.drawPropByVer = function( options ){
			 
			var drawProp = function( options ){
				
				var zRotate = function( matrix, prop ){
					
					var webglM4 = scope.webglM4;
					// just like a 2d projection matrix except in texture space (0 to 1)
					// instead of clip space. This matrix puts us in pixel space.
					matrix = webglM4.scaling( 1 / prop.texWidth, 1 / prop.texHeight, 1 );
					
					// We need to pick a place to rotate around
					// We'll move to the middle, rotate, then move back
					matrix = webglM4.translate( matrix, prop.texWidth * 0.5, prop.texHeight * 0.5, 0 );
					matrix = webglM4.zRotate( matrix, prop.angleInRadians );
					matrix = webglM4.translate( matrix, prop.texWidth * -0.5, prop.texHeight * -0.5, 0 );
					
					// because were in pixel space
					// the scale and translation are now in pixels
					matrix = webglM4.translate( matrix,  prop.srcX,  prop.srcY, 0 );
					matrix = webglM4.scale( matrix,  prop.srcWidth, prop.srcHeight, 1 );
					
					return matrix;
				}
				
				if( /v1/i.test( options.ver ) ){
					return {
					 update : function ( options ){
						return {
							ver : options.ver,
							tex : options.img.texture,
							texWidth : options.img.width,
							texHeight : options.img.height,
							dstX : options.posX,
							dstY : options.posY
						};
					 }
					}
				}else if( /v2/i.test( options.ver ) ){
					return {
					 update : function ( options ){
							return {
								ver : options.ver,
								tex : options.img.texture,
								texWidth : options.img.width,
								texHeight : options.img.height,
								dstX : options.posX,
								dstY : options.posY,
								scaleX : options.scaleX,
								scaleY : options.scaleY
							};
						}
					}
				}else{
					return {
					 update : function ( options ){
						return {
							ver : options.ver,
							tex : options.img.texture, 
							texWidth : options.img.width, 
							texHeight : options.img.height,
							srcX : options.posX,
							srcY : options.posY, 
							srcWidth : options.srcWidth,   //zoom x 
							srcHeight : options.srcHeight, //zoom y
							dstX : options.dstX, 
							dstY : options.dstY, 
							dstWidth : options.dstWidth, 
							dstHeight : options.dstHeight, 
							angleInRadians : options.angleInRadians,
							zRotate : function( matrix, prop ){
								return zRotate( matrix, prop )
							}
						}
					 }
					}
				}
			}
			
			
			return {
				glProp : options.ver === "v3" ? scope.glDrawV3["value"] : scope.glDrawV1nV2["value"],
				drawProp : drawProp( options )
			}
			
		}
		
		this.drawImage = function( gl, glProp, prop) {
			
			var webglM4 = scope.webglM4,
			matrix = scope.orthographic;
			
			gl.bindTexture( gl.TEXTURE_2D, prop.tex );

			// Tell WebGL to use our shader program pair
			gl.useProgram( glProp.program );
			
			

			// Setup the attributes to pull data from our buffers
			gl.bindBuffer( gl.ARRAY_BUFFER, glProp.positionBuffer );
			
			if( prop.ver === "v3" ){
				// this matrix will translate our quad to dstX, dstY
				matrix = webglM4.translate( matrix, prop.dstX, prop.dstY, 0);

				// this matrix will scale our 1 unit quad
				// from 1 unit to texWidth, texHeight units
				matrix = webglM4.scale( matrix, prop.dstWidth, prop.dstHeight, 1);
				
			}
			
			gl.enableVertexAttribArray( glProp.positionLocation );
			gl.vertexAttribPointer( glProp.positionLocation, 2, gl.FLOAT, false, 0, 0 );
			
			gl.bindBuffer(gl.ARRAY_BUFFER, glProp.texcoordBuffer );
			
			gl.enableVertexAttribArray( glProp.texcoordLocation );
			gl.vertexAttribPointer( glProp.texcoordLocation, 2, gl.FLOAT, false, 0, 0 );

			 // Set the matrix.
			gl.uniformMatrix4fv( glProp.matrixLocation, false, matrix);
			
			if( prop.ver === "v1" ){
				// this matrix will translate our quad to srcWidth, srcHeight
				matrix = webglM4.translate( matrix, prop.dstX, prop.dstY, 0);
				
				// this matrix will scale our 1 unit quad
				// from 1 unit to dstX, dstY units
				matrix = webglM4.scale( matrix, prop.texWidth, prop.texHeight, 1 );
				
				// Set the matrix.
				gl.uniformMatrix4fv( glProp.matrixLocation, false, matrix );
				
			}else if( prop.ver === "v2" ){
					
				// this matrix will translate our quad to dstX, dstY
				matrix = webglM4.translate( matrix, prop.dstX, prop.dstY, 0);
				
				// this matrix will scale our 1 unit quad
				// from 1 unit to dstWidth, dstHeight units
				matrix = webglM4.scale( matrix, prop.scaleX, prop.scaleY, 1 );
		
				
				// Set the matrix.
				gl.uniformMatrix4fv( glProp.matrixLocation, false, matrix );
				
			}else if( prop.ver === "v3" ){
				
				if( prop.angleInRadians > 0 ){
					
					matrix = prop.zRotate( matrix, prop )
					
				}else{
					
					// Because texture coordinates go from 0 to 1
					// and because our texture coordinates are already a unit quad
					// we can select an area of the texture by scaling the unit quad
					// down
					var matrix = webglM4.translation( prop.srcX / prop.texWidth , prop.srcY / prop.texHeight , 0);
					
					matrix = webglM4.scale( matrix, prop.srcWidth / prop.texWidth, prop.srcHeight / prop.texHeight, 1);
				
				}

				// Set the texture matrix.
				gl.uniformMatrix4fv( glProp.textureMatrixLocation, false, matrix );
				
				
			}
			

			// Tell the shader to get the texture from texture unit 0
			gl.uniform1i( glProp.textureLocation, 0);

			// draw the quad (2 triangles, 6 vertices)
			gl.drawArrays(gl.TRIANGLES, 0, 6);
		}
		 
		this.distanceAndAngleBetweenTwoPoints = function( x1, y1, x2, y2 ){
			var x = x2 - x1,
			   y = y2 - y1;

		   return {
			  // x^2 + y^2 = r^2
			  distance: Math.sqrt(x * x + y * y),

			  // convert from radians to degrees
			  angle: Math.atan2(y, x) * 180 / Math.PI
		   }
		}
		
		this.angleToRadian = function( angle ){
			return ( ( angle * Math.PI ) / 180 );
		}
		
		this.vector = function( magnitude, angle ){
		   var angleRadians = ( angle * Math.PI ) / 180;
		   this.x = magnitude * Math.cos( angleRadians );
		   this.y = magnitude * Math.sin( angleRadians );
		}
		
		this.getRelativeMousePosition = function(event, element, pixelRatio) {
			var elementBounds = element.getBoundingClientRect(),
				rootNode = (document.documentElement || document.body.parentNode || document.body),
				scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : rootNode.scrollLeft,
				scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : rootNode.scrollTop,
				touches = event.changedTouches,
				x, y;

			if (touches) {
				x = touches[0].pageX - elementBounds.left - scrollX;
				y = touches[0].pageY - elementBounds.top - scrollY;
			} else {
				x = event.pageX - elementBounds.left - scrollX;
				y = event.pageY - elementBounds.top - scrollY;
			}

			return {
				x: x ,
				y: y
			};
		}

		this.showImageHHandWW = function( img, src ){
			var imgHeight, imgWidth,
			findHHandWW = function() {
				imgHeight = this.height;
				imgWidth = this.width;
				return true;
			}
			img.name = src;
			img.onload = findHHandWW;
			img.src = src;
			return img;
		}
		
		this.rgbRandom = function( opacity ){
			this.r = 255;
			this.g = Math.round( Math.random() * 255 );
			this.b = Math.round( Math.random() * 255 );
			return "rgba( "+ this.r +","+ this.g +","+ this.b +","+ opacity +")";
		}
		
		this.JSONstringfy = function( params ){
			var cache = [];
			return JSON.stringify(params, function(key, value) {
				if (typeof value === 'object' && value !== null) {
					if (cache.indexOf(value) !== -1) {
						// Circular reference found, discard key
						return;
					}
					// Store value in our collection
					cache.push(value);
				}
				return value;
			});
			cache.length = 0;
		}
		
		this.playAudio = function( source ){
			
			var objTranslate = scope.objTranslate['value'];
			
			if( objTranslate.volume ){
			
				var obj = {
					createAudio : function(){
						return new Audio();
					}, 
					audioSrc : function(  audio, name ){
						src = scope.path+'audio/' + name;
						audio.src = Modernizr.audio.ogg ? src +'.ogg' :
									Modernizr.audio.mp3 ? src +'.mp3' :
														  src +'.wav' ;
						return name;
					},
					audioEndEvent : function( audio ){
						/*scope.attachListener( audio, "ended", function(el){ 
							
							audio.currentTime = 0;
						
						})*/ 
					},
					previousAudio : "",
				}
				
				 
				var name = source instanceof Array ? source[ scope.random ( source.length, 1 ) - 1  ] : source,
				audioName = name+".ogg"; 
				  
				audio = obj.createAudio();
				obj.audioSrc( audio, name ); //set url
				 
				obj.audioEndEvent( audio )
				audio.play();
			
			}
			
		}
		
		this.fullscreenToogle = function( element ){
			if( /off/i.test( element.className ) ){
				element.className = "fullscreen-on";
				
				var el = document,
				rfs = el.exitFullScreen || el.mozCancelFullScreen || el.webkitExitFullScreen || el.mozExitFullScreen || el.msExitFullScreen || el.webkitCancelFullScreen;
				
				if ( typeof rfs!="undefined" && rfs ) { // cancel full screen.
					rfs.call(el);
				} else if (typeof window.ActiveXObject !== "undefined") { // Older IE.
					var wscript = new ActiveXObject("WScript.Shell");
					if (wscript !== null) {
						wscript.SendKeys("{F11}");
					}
				}
				
				
			}else{
				
				var el = document.documentElement,
				rfs = // for newer Webkit and Firefox
				   el.requestFullScreen
				|| el.webkitRequestFullScreen
				|| el.mozRequestFullScreen
				|| el.msRequestFullscreen;
				
				if(typeof rfs!="undefined" && rfs){
				  rfs.call(el);
				} else if(typeof window.ActiveXObject!="undefined"){
				  // for Internet Explorer
				  var wscript = new ActiveXObject("WScript.Shell");
				  if (wscript!=null) {
					 wscript.SendKeys("{F11}");
				  }
				}
				
				element.className = "fullscreen-off";
				
			}
		}

		this.objGlobalTranslate =  function(){
			this.translate = scope.objTranslate["value"];
			this.reverse = function( obj ){
				
				var translate = this.translate;
				
				//reverse translate
				if( translate.staticObjStateX === 'left' ){
					obj.x -= translate.staticObjMoveX;
				}else if( translate.staticObjStateX === 'right' ) {
					obj.x += translate.staticObjMoveX;
				}
				
				var staticObjStateY = translate.staticObjStateY,
				staticMoveY = staticObjStateY === 'up' ? -translate.staticObjMoveY :
					staticObjStateY === 'down' ? translate.staticObjMoveY : 0;
					
				obj.y += staticMoveY;
			}
			this.update = function( obj ){
				
				var translate = this.translate;
				
				if( translate.staticObjStateX === 'left' ){
					obj.x += translate.staticObjMoveX;
				}else if( translate.staticObjStateX === 'right' ) {
					obj.x -= translate.staticObjMoveX;
				}
				
				var staticObjStateY = translate.staticObjStateY,
				staticMoveY = staticObjStateY === 'up' ? translate.staticObjMoveY :
					staticObjStateY === 'down' ? -translate.staticObjMoveY : 0;
					
				obj.y += staticMoveY;
				
			}
			
		}

	}


	_owlBird.bridge = function(  )
	{
		_owlBird.namespace['__namespace__'].push( this )

		var scope = this, O, $,
		namespace = _owlBird.namespace,
		registeredNamespace = namespace['__namespace__'],
		regList = _owlBird.register,
		utils = new scope.utils,
		__ = {};

		__.register = (function( _obj, namespace ){

			self = {}

			self.windowResize = function( prop ){
				for(var ii in regList){
					if( regList[ ii ].register === prop ){
						regList[ii].fn()
						break;
					}
				}
			}

			self.globalOwlBirdrProperty = function( prop)
			{
				var accessorName = prop, initialize = this;
				for(var ii in regList){
					if( regList[ ii ].register === prop ){
						scope.extend(self, regList[ ii ].obj)
						break;
					}
				}

				_obj.accessor.call( initialize, {
					global : self,
					accessorName : prop,
					namespace : namespace
				})

			}

			return self;

		}( utils, namespace ))


		this.that = function( target ){

			var objReturn = {};

			return {
				
				callback : (function(self){
				  return function(callback){
					 callback(self)
				  };
				}( objReturn || {})),

				invokeWith : function( prop ){
					for(var ii in regList){
						if(regList[ ii ].register === prop ){
							__.register[ii].apply( target, arguments )
							break;
						}
					}

					return this;
				},

				use : function(util, args){
					var value;
					for(var ii in utils){
						 if (ii in utils
							&& 'function' === typeof utils[ii]
							&& ii.toLowerCase() === util.toLowerCase())
							{
								if( /(attachlistener|addclass|removeclass|css)/i.test(ii.toLowerCase()) )
									args.unshift(target);
								value = utils[ii].apply(utils, args)
								if(!!value) objReturn[util] = value;
						}
					}

					return this;

				},

				findTarget : function( event ){
					if(/([object NodeList]|[object Array])/i.test(scope.objToString( target ))){
						for(var kk = target.length - 1; kk >= 0; kk--){
							if(target[kk].contains( event.target || event.srcElement)){
								this['target'] = target[kk];
								objReturn['self'] =  this;
							}else{
								!!objReturn['self'] && delete objReturn['self'];
							}
						}
						return this;
					}
				},

				fireTarget : function( event, callback ){
					this.findTarget(event).callback(function(obj){
						('self'in obj) && obj['self'].use('delay', [ function(){
							callback.call(null, obj['self'].target )
						}, 100])
					})
				}
			}
		}
	}


	_owlBird.deligate = function(string,el,obj)
	{
		var scope = this
		scope.extend( _owlBird.register, {
			windowResize: {
				register: '_windowResize',
				fn : function(){
					var canvas = scope.qs('screen').getElementsByTagName('canvas')[0]
					
					scope.browserWidthUpdate = scope.browserWidth()
					scope.browserHeightUpdate = scope.browserHeight()
					if( scope.controlGUICheck ) scope.controlGUICheck['value']();
						
					
					canvas.width = scope.browserWidthUpdate;
					canvas.height = scope.browserHeightUpdate + 1;
					 
					scope.css( canvas , {
						'width' : scope.browserWidthUpdate + 'px',
						'height' : scope.browserHeightUpdate + 1 +'px'
					})
				}
			},
			globalOwlBirdrProperty: {
				register: '_globalOwlBirdrProperty',
				obj : {
					glDrawTest : "",
					glDrawV1nV2 : "",
					glDrawV3 : "",
					glLine : "",
					intervalListGlobal : "",
					activeMap :"mapA", 
					staticWorld : '',
					isScroll : true,
					mousePosition : {
						pos : ''
					},
					objTranslate : {
						staticObjMoveX : '',
						staticObjMoveY : 5,
						staticObjStateX : '',
						staticObjStateY : '',
						staticObjAllX : true,
						staticObjAllY : true,
						moveLeft : false,
						moveRight : false,
						moveUp : false,
						moveDown : false,
						firstLoadLeft : true,
						firstLoadRight : true,
						staticsWallOuterIsStopX : true,
						charaIsCentered : false,
						charaTranslate : true,
						staticsWallOuterIsStopY : true,
						objPhysCollide : false,
						isCenter : {
							init : false,
							state : true
						},
						objectMarker : {
							state : '',
							monster : '',
							registerMonster : []
						},
						isShake : {
							shakeCnt : [],
							createShake : function( shake ){
								while( shake-- ) this.shakeCnt.push( new this.constructor() );
							},
							constructor : function(){
								this.state = false;
								this.strength = 3;
								this.tick = 0;
								this.install = false;
								this.initShake = 0;
								this.stateShake = true;
								this.pairShake = 0;
								this.posX = 0;
								this.posY = 0;
								this.inOrDec = true;
								this.translate = scope.objTranslate["value"];
								this.amplitude = {
									up : 0,
									center : 2,
									down : 0,
									strength : 1
								}
								this.randomnessFn = function( number ){
									if( this.stateShake === 1 || this.stateShake === 3 ){
										switch( number ) {
											case 1: this.posX = this.initShake; break;
											case 2: 
												this.posX = this.initShake;
												this.posY = -this.initShake; 
												break;
											case 3: 
												this.posY = this.initShake; break;	
											case 4: 
												this.posX = this.initShake;
												this.posY = this.initShake; break;
										}
									}else if( this.stateShake === 2 ){
										switch( number ) {
											case 1: this.posX = -this.initShake * 2; break;
											case 2: 
												this.posX = -this.initShake * 2;
												this.posY = this.initShake * 2 ; 
												break;	 
											case 3: 
												this.posY = -this.initShake * 2; break;	
											case 4: 
												this.posX = -this.initShake * 2;
												this.posY = -this.initShake * 2; break;
										}
									}
									
								}
								
								this.update = function(){
									if( !this.install ){
										this.randomness = scope.random( 1, 0 ) ? 2 : 4;
										this.initShake = this.strength;
										this.inOrDec = scope.random( 1, 0 ) ? true : false;
										this.amplitude.up = this.inOrDec ? 1 : 3;
										this.amplitude.down = this.inOrDec ? 3 : 1;
										this.install = true;
									}
									
									
									this.tick++;
									if( this.tick === this.amplitude.strength ){
										this.stateShake = this.amplitude.up;
										this.randomnessFn( this.randomness, this.stateShake );
									}else if(  this.tick === this.amplitude.strength * 2 ){
										this.stateShake = this.amplitude.center
										this.randomnessFn( this.randomness, this.stateShake );
									}else if(  this.tick === this.amplitude.strength * 3 ){
										this.stateShake =  this.amplitude.down
										this.randomnessFn( this.randomness, this.stateShake );
									}
									
								
									
									if( this.tick > this.amplitude.strength * 3 ){
										return true;
									}
									
								}
							}
							
						},
						effect : true,
						volume : true,
						totHitNum : 0
						
					},
					
					staticAllMap : function(){
						var map = [ 'mapA','mapB','mapAADungeonA','mapAADungeonB','mapC','mapDDungeonA','mapDungeonA', 
						'mapDungeonB', 'mapDungeonC', 'mapDungeonD', 'mapDungeonE', 'mapDungeonF', 'mapDungeonG', 'mapDungeonH' ],
						objMap = {};
						
						for(var ii = 0, len = map.length; ii < len ; ii++ ){
							objMap[ map[ii] ] = {
								content : '',
								textures : ''
							}
						}
						
						return objMap;
					}(),
					storageState : function()
					{
						this.storage = [];
						this.remove = function( targetName ){
							var cnt = this.storage;
							if( cnt.length ){
								for( var ii = 0; ii < cnt.length ; ii++ ){
									if( cnt[ii].name === targetName.toLowerCase() ){
										this.storage.splice( ii, 1 );
									}
								}
							}
						};
						this.get = function( targetName ){
							var cnt = this.storage;
							if( cnt.length ){
								for( var ii = 0; ii < cnt.length ; ii++ ){
									if( cnt[ii].name === targetName.toLowerCase() ){
										return cnt[ii].status;
									}
								}
							}
						};
						this.set = function( targetName, status)
						{
							var cnt = this.storage;
							if( cnt.length ){
								for( var ii = 0, jj = 0; ii < cnt.length ; ii++ ){
									if( cnt[ii].name === targetName.toLowerCase() ){
										cnt[ii].status = status
										jj++
										break;
									}

									if( !jj && ii === (cnt.length - 1) ){
										cnt.push({
											name : targetName.toLowerCase(),
											status : status
										})

										break;
									}
								}

							}else{
								cnt.push({
									name : targetName.toLowerCase(),
									status : status
								})
							}
						}
					},
					
				}
			}
		})

		scope.that( scope )
			.invokeWith('_globalOwlBirdrProperty' )
	}
 
	_owlBird.transport = function( options ){
		
		var scope = this, 
		setupXhr = function( params ){
			
			var obj = {
				charset :  params.charset || 'application/json;charset=UTF-8',
				http : window.XMLHttpRequest ?  new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"),
				callback :  params.callback,
				onerror :  params.error || 'ops, request time out',
				timeout :  params.setTimeout || 1123000,
				url :  params.url,
				type :  params.type,
				dataset :  params.dataset || {},
				requestHeader : function(){
					var self = { 'Content-Type': this.charset }
					scope.extend(self ,  params.requestHeader)
					return self;
				},
				setRequest : function(){
					var self = this, http = self.http;
					for(var ii in self) if(ii in self){
						for(var jj in http) if(jj in http){
							if(jj.toLowerCase() 
								=== ii.toLowerCase()){
								http[ii] = self[ii]
							}
						}
					}
					
					http.open(self.type, self.url, true)
					for(var kk in self.requestHeader())
						http.setRequestHeader(kk, self.requestHeader()[kk]);
							
					http.send(JSON.stringify(self.dataset));
					
					http.ontimeout = ('function' === typeof self.onerror) && self.onerror || function(){
						params.timeoutFn &&
							params.timeoutFn.call( this, http.status );
					}
					
					 
					http.onerror =  function (e) {
						params.errorFn &&
							params.errorFn.call( this, http.status );  // return 0
					}
					
					
					http.onload =  function (e) {	
						if(4 === http.readyState){
							( 200 === http.status || http.status === 206 ) ?
								self.callback.call(this, http.responseText ) :
							404 === http.status ?
								self.callback.call( this, http.status )  :
							403 === http.status ?
								console.log('Forbidden') :	
							500 === http.status ? 
								console.log('Error 500') :	
							300 === http.status ?	
								console.log('Page Redirect') :
								console.log('Unknown');
								
						}
					};
				}
			}
			
			obj['setRequest']();
		}
		
			
		var variables = options ? [ options ] : [];
		
		scope.slice( variables ).forEach(function( params ){	
			
			 setupXhr( params )
			
		})
		
		
		
	}

	_owlBird.mouse = function()
	{
		//(c) Matter JS Mouse Create
		var scope = this;
		var obj = {}
		this.mouseCreate = function( element )
		{
			var mouse = {};
			mouse.element = element || document.body;
			mouse.absolute = { x: 0, y: 0 };
			mouse.position = { x: 0, y: 0 };
			mouse.mousedownPosition = { x: 0, y: 0 };
			mouse.mouseupPosition = { x: 0, y: 0 };
			mouse.offset = { x: 0, y: 0 };
			mouse.scale = { x: 1, y: 1 };
			mouse.wheelDelta = 0;
			mouse.button = -1;
			mouse.pixelRatio = mouse.element.getAttribute('data-pixel-ratio') || 1;

			mouse.sourceEvents = {
				mousemove: { x: 0, y: 0 },
				mousedown: { x: 0, y: 0 },
				mouseup: { x: 0, y: 0 }
			};

			mouse.mousemove = function(event) {
				var position = scope.getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
					touches = event.changedTouches;

				if (touches) {
					mouse.button = 0;
				}

				mouse.absolute.x = position.x;
				mouse.absolute.y = position.y;
				mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
				mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;

				mouse.sourceEvents.mousemove = mouse.position
				
				scope.mousePosition['value'].pos = mouse.sourceEvents;
				
			};

			mouse.mousedown = function(event) {
				var position = scope.getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
					touches = event.changedTouches;

				if (touches) {
					mouse.button = 0;
				} else {
					mouse.button = event.button;
				}

				mouse.absolute.x = position.x;
				mouse.absolute.y = position.y;
				mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
				mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;

				mouse.sourceEvents.mousedown = mouse.position;
				
				scope.mousePosition['value'].pos = mouse.sourceEvents;
				
			};

			mouse.mouseup = function(event) {
				var position = scope.getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
					touches = event.changedTouches;
				mouse.button = -1;
				mouse.absolute.x = position.x;
				mouse.absolute.y = position.y;
				mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
				mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
				mouse.sourceEvents.mouseup = mouse.position
				scope.mousePosition['value'].pos = mouse.sourceEvents
			};

			element.addEventListener('mousemove', mouse.mousemove);
			element.addEventListener('mousedown', mouse.mousedown);
			element.addEventListener('mouseup', mouse.mouseup);

			element.addEventListener('mousewheel', mouse.mousewheel);
			element.addEventListener('DOMMouseScroll', mouse.mousewheel);

			element.addEventListener('touchmove', mouse.mousemove);
			element.addEventListener('touchstart', mouse.mousedown);
			element.addEventListener('touchend', mouse.mouseup);

		}

		this.getRelativeMousePositionToRegisterObject = function( elements )
		{
			if( scope.mousePosition['value'].pos ){
				var x = scope.mousePosition['value'].pos.mouseup.x,
				y = scope.mousePosition['value'].pos.mouseup.y;
				
				
				for(var ii = 0; ii < elements.length ; ii++ ){
					var posReac = elements[ii].getBoundingClientRect();
					
					if( posReac.right > x &&  posReac.left < x
					&& posReac.top < y &&  posReac.bottom > y ){
						return elements[ii].id ;
					}
				}
			}
			 
		}
	}
 
	_owlBird.physics = function(){
		var scope = this;
		
		this.physicsComponent = {};
		
		this.physicsComponent.objectTrajectory = function( target, duration, prop ){
			this.install = false;
			this.target = target;
			this.targetLabel = target.label;
			this.targetRig = target.rigBody;
									
			this.targetTranslate = {
				x : 0,
				y : 0
			}
			this.targetEnd = "";
			
			if( prop ){//static trajectory
				
				this.targetTranslate.x = prop.x;
				this.targetTranslate.y = prop.y;
				
			}else if( target.statParameters.mainCharacter ){
				this.vy = 8;
				this.vx = 12
			}else{
				this.vy = 9;
				this.vx = 13

			}
			
			var parentRigBody = this.target.rigBody;
			
			this.duration = duration;
			this.halfDuration = duration / 2;
			this.globalTranslate = scope.objTranslate["value"];
			
			
			this.translateOvalOnly = function( end ){
				
				if( this.targetRig.characterState  ){
					
					var rigBody = this.targetRig;
				
					this.globalTranslate.staticObjMoveX = prop ?  Math.abs( this.targetTranslate.x ) : Math.abs( this.vx );
					  
					/*
					rigBody.moveStaticY = -this.vy;
					rigBody.velocity = -this.vy;
					scope.objTranslate["value"].staticObjMoveY = -this.vy;
					*/
					
					//prevent bug object trajectory if idle force to 0
					!end && ( this.globalTranslate.staticObjMoveX = 0 );
					
					//force end
					if( this.globalTranslate.objPhysCollide ){
						this.duration = 0;
						this.globalTranslate.objPhysCollide = false;
					}
					  
				}
				
			}
			
			this.install = false;
			
			this.updatePhysic = function( trajectoryX, trajectoryY ){
				
				
				if( this.duration > 0 ){
					
					if( !this.install ){
						
						var turn = ( parentRigBody.turn ? parentRigBody.turn === 'right' : parentRigBody.monsterDir() === 'right' ) ?  "right" : "left";
						 
						if( turn === 'right' ){
							parentRigBody.changeRightFn( true );
						}else{ 
							parentRigBody.changeLeftFn( true );
						}	
						
						 
						this.vx = turn === "left" ? -this.vx : this.vx;
						
						this.targetEnd = {
							x : this.target.position.x,
							y : this.target.position.y
						}
						
						
						this.enemyParams = parentRigBody.characterState ? parentRigBody.monsterParameters : parentRigBody.character.statParameters;
						
						this.install = true;
					}
					  
					this.duration--
				
					var staticObjStateX = this.globalTranslate.staticObjStateX,
					staticObjMoveX = this.globalTranslate.staticObjMoveX,
					staticObjStateY = this.globalTranslate.staticObjStateY,
					staticObjMoveY = this.globalTranslate.staticObjMoveY,
					end = this.duration === 1,
					target = this.target;
					
					if( this.duration < this.halfDuration ){
						this.vy = Math.abs( this.vy )
					}else{
						this.vy = -Math.abs( this.vy )
					}
					
					
					if( staticObjStateX === 'left' ){
						this.targetEnd.x += staticObjMoveX;
					}else if( staticObjStateX === 'right' ) {
						this.targetEnd.x -= staticObjMoveX
					}
					
					
					var staticMoveY = staticObjStateY === 'up' ? staticObjMoveY :
							staticObjStateY === 'down' ? -staticObjMoveY : 0;
							
					this.targetEnd.y += staticMoveY;
					
					trajectoryX && ( this.targetTranslate.x += this.vx );
					trajectoryY && (this.targetTranslate.y += this.vy );
					
					this.translateOvalOnly( this.duration );
					
					scope.Body.setPosition(
						target , {
						x : this.targetEnd.x + this.targetTranslate.x,
						y : this.targetEnd.y + this.targetTranslate.y
					})
					
					//enemy died
					if( this.enemyParams && !this.enemyParams.health || this.targetLabel !== target.label ){
						this.duration = 0; 
						this.translateOvalOnly( 0 );
					}
					
				}
				
			}
			
		}
		
		this.physicsComponent.itemTrajectoryComponent = function(){
			
			this.itemTrajectory = function( name, width, height, parent, callback  ){
				
				this.name = name;
				this.parent = parent;
				this.install = false;
				this.x = 0;
				this.y = -2;
				this.turn = '';
				this.vy = 0;
				this.vx = 0;
				this.deltaY = 0;
				this.deltaX = 0;
				this.gravity = 0.03;
				this.deg = 0;
				this.characterGetHit = false;
				this.posHit = 0;
				this.isTrajectory  = true;
				this.angle = 0;
				this.speed = 12;
				this.item =  scope.createItem['value']( name, width, height, "itemWithAngle" );
				this.life = 100;
				this.pass = 0;
				this.angleSpeed = 0.03;
				this.acceleration = function(){
					this.vy += this.gravity;
					this.x = this.speed;
					this.y += this.vy;
				}
				
				this.update = function( spawnX, spawnY, angle, turn, target, isRemove, angleSpeed ){
					if( !this.install ){
						this.isBoom = /boom/i.test( this.name );
						
						//prevent error when target was removed
						if( typeof target.position === 'undefined'){
							scope.World.remove( scope.engine.world, this.item );
							return true;
						}
						
						scope.Body.setPosition(
							this.item , {
							x : spawnX,
							y : spawnY
						} )
						
								
						scope.Composite.addBody( scope.engine.world, this.item );
						//update dungeon order object
						scope.orderObjectFn['value']()
						
						var rangeY = target.position.y - spawnY, maximumSpeed;
						
						if( rangeY <= 100 ) maximumSpeed = 18;
						else if( rangeY > 100 && rangeY <= 130 )  maximumSpeed = 19;
						else if( rangeY > 130 && rangeY < 180 )  maximumSpeed = 15.5;
						else if( rangeY > 180 )  maximumSpeed = 12.5;
						
						if( this.isBoom ){
							maximumSpeed -= scope.randomFloat(6.5,3.5);
						}
						
						this.item.isStatic = true;
						this.deltaX = spawnX;
						this.deltaY = spawnY;
						this.angle = angle ;
						this.speed = maximumSpeed * ( ( target.position.x - spawnX ) / ( this.parent.object.statParameters.range - 100 ) );
						this.turn = turn;
						this.angleSpeed = angleSpeed ? angleSpeed : this.angleSpeed;
						 
						this.install = true;
					}

					this.life--;
					if( this.life < 0 || ( isRemove ) ){
						scope.World.remove( scope.engine.world, this.item );
						
						//update dungeon order object
						scope.orderObjectFn['value']()
						
						return true;
					}
					
					
					if( this.item.bounds.max.y < target.bounds.max.y && this.isTrajectory || this.isBoom ){
						var pos =  target.position,
						rangeX = Math.abs( pos.x - this.item.position.x ),
						rangeY = Math.abs( ( pos.y  ) - this.item.position.y ),
						itemPos = this.item.position,
						posArrowY = ( target.bounds.min.y - target.additionalBoundsValue - target.additionalBoundsHeightValue ) - this.item.bounds.min.y,
						getHit = false;
						
						 
						if( this.isBoom ){ 
							var rangeBoomY =  Math.abs(  target.bounds.max.y  - this.item.bounds.max.y );
							rangeBoomY < 15 && ( this.characterGetHit = true );
						}else if( rangeX < 60 && posArrowY < 40 ){ //rangeY < 100 
							this.characterGetHit = true;
						}
						
						//stop pool when attacker already died 
						if( this.characterGetHit ){
							if( this.isBoom ){ //area
									 
									if( callback ){ //boom need callback ex add buff when explode triger at @AI.skillBehaviour
										
										callback( this.item )
									
									}else if( this.parent.object.visible ) {
										
											scope.explosiveA({
												object : this.item,
												parent : "",
												alpha : false
											})
											
											scope.playAudio("explosion")
										
											var jj =  this.parent.createAreaDamagePool({
												target : this.item,
												width : 300,
												height : 300,
												caster : this.parent.object.label
											 }) 
											 
											
											for( var ii = 0; ii < jj.length ; ii ++ ){
												this.parent.characterDamagePool({
													objectAttacker : this.parent.object,
													objectTarget : jj[ii].object
												})
											}
									
									}
									
								
									
							}else if( this.parent.character.statParameters ){
								this.parent.characterDamagePool({
									objectAttacker : this.parent.object,
									objectTarget : this.parent.character
									
								})
							}
							
							
							this.life = 0; //then remove it
							
						}
						
						if( !this.characterGetHit ){
			
							this.acceleration();
						
							var posX = itemPos.x + this.x;
							var posY = itemPos.y + this.y 
							
							if( !this.characterGetHit || !this.pass ){
								scope.Body.setPosition(
									this.item , {
									x : posX,
									y : posY
								})
								
								this.item.angleInRadians = scope.angleToRadian( this.angle )
								
								this.posHit = itemPos.x;
								 
								this.angle += ( this.turn === 'right' ? -this.angleSpeed : this.angleSpeed );
								 
								this.item.angle = this.angle;
								
								this.prevX = posX;
								this.prevY = posY;
								
							}else {
								
								this.x = this.posHit 
								this.y = pos.y + 100 ;
								
								this.item.force.x = this.x;
								this.item.force.y = this.y;
							}
							this.pass++
						
						}
						
					}else{
						this.isTrajectory = false;
					}
					
					return false;
				}
			}
			this.trajectoriesUpdate = [];
			this.trajectoryInit = {		
				pushTrajectoryItem : function( prop  ){
					var parent = prop.parent
					trajectoryProp = parent.object.statParameters.trajectoryProp
					parent.trajectoriesUpdate.push( new parent.itemTrajectory( prop.weaponName, prop.weaponWidth, prop.weaponHeight, parent, prop.callback )   )
					if( trajectoryProp.angleSpeed ){
							parent.trajectoriesUpdate[ parent.trajectoriesUpdate.length  - 1 ].angleSpeed = trajectoryProp.angleSpeed;
					}
				},
				createSkillTrajectory : function( prop ){
					
					//prevent error, an error accured when swaping character
					
					var trajectoryProp =  prop.parent.object.statParameters.trajectoryProp;
						
					if( trajectoryProp ){		
					
						var weaponName = prop && prop.weaponName ?	prop.weaponName : trajectoryProp.weaponName,
						weaponWidth = prop && prop.weaponWidth  ?	prop.weaponWidth : trajectoryProp.weaponWidth,
						weaponHeight = prop && prop.weaponHeight ?	prop.weaponHeight : trajectoryProp.weaponHeight,
						callback = prop && prop.callback ? prop.callback : "";
					 
						this.pushTrajectoryItem({
							 parent : prop.parent,
							 weaponName : weaponName,
							 weaponWidth : weaponWidth,
							 weaponHeight : weaponHeight,
							 callback : callback
						})
					}
				},
				createNormalTrajectory : function( prop ){
					
					var trajectoryProp = prop.object.statParameters.trajectoryProp
					weaponName = trajectoryProp.weaponName,
					weaponWidth = trajectoryProp.weaponWidth,
					weaponHeight = trajectoryProp.weaponHeight,
					callback =  "";
					
					this.pushTrajectoryItem({
						 parent : prop,
						 weaponName : weaponName,
						 weaponWidth : weaponWidth,
						 weaponHeight : weaponHeight,
						 callback : callback
					})
					
				}
			}
			
		}
		
		this.moveVector2dSmooth = function( objectStart, objectDest, seconds ){
			var v = scope.distanceAndAngleBetweenTwoPoints(
				objectStart.position.x,
				objectStart.position.y,
				objectDest.position.x,
				objectDest.position.y
			),
			moveObjectPerSecond = v.distance / seconds

			return new scope.vector( moveObjectPerSecond, v.angle )
		}
		this.moveVector2dWithVelocity = function( objectStart, objectDest, velocity, withAngle ){
			if( objectStart.position ){
				var v = scope.distanceAndAngleBetweenTwoPoints(
					objectStart.position.x,
					objectStart.position.y,
					objectDest.position.x,
					objectDest.position.y
				)
			}else{
				var v = scope.distanceAndAngleBetweenTwoPoints(
					objectStart.x,
					objectStart.y,
					objectDest.x,
					objectDest.y
				)
			}
			
			if( withAngle ){
				return {
					vector : new scope.vector( velocity, v.angle ),
					angle : v.angle
				}
			}else{
				return scope.extend( new scope.vector( velocity, v.angle ), { distance : v.distance}, true )
			}
		}

		this.moveVector2d = function( objectStart, objectDest, speed ){
			this.install =  false;
			this.start = objectStart.position,
			this.dest = objectDest.position,
			this.lastTime = new Date().getTime(),
			this.startSpeed = speed || 0.4,
			this.velocity = null,
			this.update = function(){

				if( !this.install ){
					// positions and deltas
					var start = this.start,
					dest = this.dest,
					dx = dest.x - start.x,
					dy = dest.y - start.y,
					totalDistance = Math.sqrt(dx * dx + dy * dy);

					// x and y component ratio
					var cx = dx / totalDistance,
					cy = dy / totalDistance;

					// velocities
					var startSpeed = this.startSpeed,
					startVelocity = { x: cx * this.startSpeed, y: cy * startSpeed };

					this.startVelocity = startVelocity;
					this.velocity = Object.create( startVelocity );
					this.install = true
				}

				var t = new Date().getTime(),
				tDelta = t - this.lastTime,
				v = this.velocity;
				this.lastTime = t;

				return {
					x : v.x * tDelta,
					y : v.y * tDelta
				}

			}
		};
 
		
	}

	_owlBird.particle = function(){
		var scope = this,
		obj = {
			textures : [],
			particleSpec : function(){
				this.opacity = 1;
				this.decLife = scope.random( 4, 3);
				this.decSize = scope.random( 3, 2);
				this.centerX = 0;
				this.centerY = 0;
				
			},
			createParticles : function( options ){
				
				var tex = null,
				gl = scope.context,
				glTexture ;
			
				for( var ii = 0, jj = this.textures, len = jj.length; ii < len ; ii++ ){
					if( jj[ii].src === options.src ){
						tex = jj[ii];
					}
				}
			
				glTexture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, glTexture );
				// Fill the texture with a 1x1 blue pixel.
				
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
							  new Uint8Array([0, 0, 255, 255]) );

				// let's assume all images are not a power of 2
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				
				
				if( !tex ){
					
					var img = new Image();
					img.src = options.src;
					
					img.addEventListener('load', function() {
					  gl.bindTexture(gl.TEXTURE_2D, glTexture );
					  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img );
					});
					
					 this.textures.push({
						 src : options.src,
						 img : img,
						 glTexture : glTexture
					 })
				
				}else if( tex.img.complete ){
					glTexture = tex.glTexture;
					img = tex.img // remove old event listener;
					gl.bindTexture( gl.TEXTURE_2D, glTexture );
					gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img );
					
				}
				
				var lifeRange = scope.random( options.lifeRange[1], options.lifeRange[0] );
				
				return scope.extend({
					parent : options.parent,
					texture : glTexture,
					width : options.width,
					height : options.height,
					sizeWidth : options.width,
					sizeHeight : options.height,
					x : options.bind.x - options.width / 2,
					y : options.bind.y - options.height / 2,
					lifeTick : lifeRange ,
					life : lifeRange ,
					lifeRange : options.lifeRange,
					src : options.src
					
				}, new obj.particleSpec );
				
			},
			
			particleEmitter : function( options ){
				
				this.gl = scope.context;
				this.reset = true;
				this.glProp = scope.glDrawV1nV2["value"];
				this.objTranslate = scope.objTranslate['value'];
		 
				this.particleContainer = [];
				
				this.particleLoader = function( options ) {
						 
					this.reset = typeof options.reset !== "undefined" ? options.reset : true;
					
					this.parent = options.parent;
					
					this.needTranslate = typeof options.needTranslate !== "undefined" ? options.needTranslate : true,
					
					this.alpha = options.alpha;
					
					this.lifeSpan = options.lifeSpan;
					
					this.behaviour =  options.behaviour;
					
					this.bind = options.bind;
					this.velocity = {
						x : options.velocity[0],
						yMax : options.velocity[1] * 2,
						yMin : options.velocity[1]
					}
					
					while( options.particleNumber-- ){
						if( options.sizeRandom ){
							var size = scope.random( options.sizeRandom[1], options.sizeRandom[0] );
							options.height = options.width = size;
						}
						this.particleContainer.push ( obj.createParticles( options ) );
					}
					 
				};
				
				this.draw = function( prop ){
					
					var glProp = this.glProp,
					gl = this.gl, matrix = scope.orthographic,
					webglM4 = scope.webglM4;
					
					
					gl.bindTexture( gl.TEXTURE_2D, prop.texture );

					// Tell WebGL to use our shader program pair
					gl.useProgram( glProp.program );
					
					// Setup the attributes to pull data from our buffers
					gl.bindBuffer( gl.ARRAY_BUFFER, glProp.positionBuffer );
					

					gl.enableVertexAttribArray( glProp.positionLocation );
					gl.vertexAttribPointer( glProp.positionLocation, 2, gl.FLOAT, false, 0, 0 );
					
					gl.bindBuffer(gl.ARRAY_BUFFER, glProp.texcoordBuffer );
					
					gl.enableVertexAttribArray( glProp.texcoordLocation );
					gl.vertexAttribPointer( glProp.texcoordLocation, 2, gl.FLOAT, false, 0, 0 );

					 // Set the matrix.
					gl.uniformMatrix4fv( glProp.matrixLocation, false, matrix );
					
					
					// this matrix will translate our quad to srcWidth, srcHeight
					matrix = webglM4.translate( matrix, prop.x + prop.centerX, prop.y + prop.centerY, 0);
					
					
					// this matrix will scale our 1 unit quad
					// from 1 unit to dstX, dstY units
					matrix = webglM4.scale( matrix, prop.width, prop.height, 1 );
					
					// Set the matrix.
					gl.uniformMatrix4fv( glProp.matrixLocation, false, matrix );
			
					// Tell the shader to get the texture from texture unit 0
					gl.uniform1i( glProp.textureLocation, 0);

					// draw the quad (2 triangles, 6 vertices)
					gl.drawArrays(gl.TRIANGLES, 0, 6);
					
				}
				
				this.translateState = true;
				
				this.translate = new scope.objGlobalTranslate;
				
				this.alpha = true;
				
				this.clear = function(){
					this.particleContainer.length = 0;
				}
				
				this.update = function(){
					
					var particles = this.particleContainer,
					gl = this.gl,
					v = this.velocity;
					if( particles.length ){
						
						if( !this.parent.bind.visible ) return true; 
						
						this.alpha && gl.blendFunc( gl.SRC_ALPHA , gl.ONE_MINUS_CONSTANT_ALPHA   );
						
						for( var ii = 0 ; ii < particles.length ; ii ++ ){
							
							var p = particles[ ii ];
							 
							this.behaviour( p, v );
							this.needTranslate && this.translate.update( p )
							
							gl.useProgram( this.glProp.program );
							gl.uniform1f( this.glProp.alphaLocation, p.opacity );
							
							
							this.draw({
								texture : particles[ ii ].texture,
								x : p.x,
								y : p.y,
								width : p.width,
								height : p.height,
								centerX : p.centerX,
								centerY : p.centerY 
								
							})
							
							var pUpdate = ( p.lifeTick < 0 || p.width < 0 );
							
							if( pUpdate && this.reset ){
								particles[ii] = obj.createParticles({
									width : p.sizeWidth,
									height : p.sizeHeight,
									bind : this.bind,
									lifeRange : p.lifeRange,
									src : p.src
								});
							}else if( pUpdate && !this.reset ){
								particles.splice( ii, 1)
							}
							
							gl.uniform1f( this.glProp.alphaLocation, 1 );
							
						}
							
						gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
						
						
					}else{
						return true;
					}
				}
			
			}
			
		}
		
		this.createArrowRainParticle = function( bind, rainNumber ){
			this.bind = bind;
			this.position = function(){
				this.x = bind.position.x + scope.random( 250, 50 );
				this.y = -100;
			};
			this.particlesEnd = [];
			this.particles = [];
			this.particleNumber = rainNumber;
			this.radian = scope.angleToRadian( 330 );
			this.draw = function(){
				
				if( !this.install ){
					
					this.install = true;
					
					while( this.particleNumber-- ){
						
						var p =  new scope.createItem["value"]( "arrowDrotate", 37, 37, "itemWithAngle" ),
						vec = new this.position();
						scope.Body.setPosition( p,{ 
							x : vec.x,
							y : vec.y,									
						})
						
						scope.World.add( scope.staticWorld['value'], p );
						
						this.particles.push(p)
					}
					
					this.bind.visible && scope.playAudio("Scary impact");
					
				}else{
						
					var particles = this.particles;
					for(var ii = 0; ii < particles.length; ii++ ){
						
						var p = particles[ii],
						pos = p.position;
						
						if( !p.install ){
							p.angleInRadians = this.radian;
							p.randomStart = scope.random( 50, 0 );
							p.randomEnd = scope.random( 40, -100 );
							p.decRandY = scope.random( 40, 30 );
							p.life = scope.random( 100, 50 );
							p.opacity = 1;
							p.end = false;
							p.endForParent = true;
							p.install = true;
							p.audio = false;
							
						}
						
						
						
						if( p.randomStart > 0 ){
							p.randomStart--;
						}else{	
							if( !p.audio ){
								this.bind.visible && scope.playAudio("arrow-fire-hit");
								p.audio =  true;
							}
							
							if( !( pos.y > this.bind.position.y + p.randomEnd ) && !p.end ){
								
								scope.Body.setPosition( p, {
									x : pos.x  - 12,
									y : pos.y +  p.decRandY
								})
								
							}else{
								!p.end && this.particlesEnd.push( p );
								p.end = true;
								
							}
							
							if( !( p.life-- ) ){
								scope.World.remove( scope.staticWorld['value'], p );
								scope.orderObjectFn['value']();
								particles.splice( ii, 1 );
							}
							
						}
						
						
					}
					
					if( !particles.length ){ // return 0 
						return true;
					}
				}
			}
		}
		 
		this.createGrowRing = function( options ){
			  
			 
			this.bind = options.bind;
			this.life  = options.life; 
			this.targetStart = {
				x : options.bind.x + options.optionalX ,
				y : options.bind.y + options.optionalY 
			};
			this.draw = function(){
				if( !this.install ){
					this.particleA = new obj.particleEmitter();
					this.particleA.particleLoader({
						parent : this,
						src : options.src,
						bind : this.targetStart,
						particleNumber : 1,
						needTranslate : false,
						width :  options.width,
						height : options.height,
						lifeRange : [ 100, 50 ],
						velocity : [ 0,  0 ],
						alpha : true,
						behaviour : function( p ){
							 
							if( !p.install ){
								p.opacity = 0;
								p.install = true;
							
							}else if( p.width < options.growingMax ){
								 p.width += 3;
								 p.height += 3; 
							} 
							
							if( p.parent.life < 10 ) p.opacity -= 0.1;
							else if( p.opacity < 1.0 ) p.opacity += 0.1;
							
							
							p.x = p.parent.targetStart.x;
							p.y = p.parent.targetStart.y;
							p.centerX = -p.width / 2;
							p.centerY = -p.height / 2
						
						}
					})
					
					this.install = true;
				}
				
				this.particleA.update();
				
				if( this.life ){
					this.life--
				}else{
					this.particleA.clear();
					return true;
				}
			}
		}
		
		this.createShieldParticle = function( bind, life, imageProp, height ){
			this.bind = bind;
			this.life  = life;
			this.additionalHeight = bind.additionalBoundsHeightValue
			this.targetStart = bind.position;

			this.draw = function(){
				 
				var additionalHeight = this.additionalHeight - height,
				life = this.life - 100;
				
				if( !this.install ){
					this.particleA = new obj.particleEmitter();
					this.particleB = new obj.particleEmitter();
					this.particleA.particleLoader({
						parent : this,
						src : imageProp.shield,
						bind : this.targetStart,
						particleNumber : 1,
						width : 10,
						height : 10,
						lifeRange : [ 100, 50 ],
						velocity : [ 0,  0 ],
						alpha : true,
						behaviour : function( p ){
							
							if( !p.install ){
								p.opacity = 0;
								p.install = true;
							
							}else if( p.width < 190){
								 p.width += 20;
								 p.height += 20;
								 
								 if( p.opacity < 1.0 ) p.opacity += 0.1;
								 
							}else if ( p.parent.life < 10 ){
								 p.opacity -= 0.1;
							}
								
							p.x = this.bind.x;
							p.y = this.bind.y;
							p.centerX = -p.width / 2;
							p.centerY = -p.height / 2 - additionalHeight;
						
						}
					})
					
					this.particleB.particleLoader({
						parent : this,
						src : imageProp.innerShield,
						bind : this.targetStart,
						particleNumber : 1,
						width : 10,
						height : 10,
						lifeRange : [ 100, 50 ],
						velocity : [ 0,  0 ],
						alpha : false,
						behaviour : function( p ){
							
							if( !p.install ){
								p.opacity = 0;
								p.install = true;
							
							}else if( p.width < 130){
								 p.width += 15;
								 p.height += 15;
								 
								 if( p.opacity < 0.4 ) p.opacity += 0.1;
								 
							}else if ( p.parent.life < life ){
								 if( p.opacity >  0 ) p.opacity -= 0.1;
							}
								
							p.x = this.bind.x;
							p.y = this.bind.y;
							p.centerX = -p.width / 2;
							p.centerY = -p.height / 2 - additionalHeight;
						
						}
					})
					
					this.install = true;
				}
				
				this.particleA.update();
				this.particleB.update();
				
				if( this.life ){
					this.life--
				}else{
					this.particleA.clear();
					this.particleB.clear();
					return true;
				}
				

			}
		}
		
		this.createBlueParticle = function( bind, life, staticPos, prop ){
			this.hit = false;
			this.flip = false;
			this.life = life;
			this.bind = bind;
			this.staticPos = staticPos;
			this.targetExplode = 0;
			this.targetDelay = 100;
			this.targetDummy = new scope.createItem["value"]("1px",1,1 );
			this.targetStart = {
				x : bind.position.x + this.staticPos.x,
				y : bind.position.y + this.staticPos.y,									
			};
			this.targetEnd = "";
			this.hitted = true;//state for @monsterDungeon.updateManual
			
			this.translate = new scope.objGlobalTranslate;
			
			this.draw = function(){
				
				this.targetStart.x = bind.position.x + this.staticPos.x;
				this.targetStart.y = bind.position.y + this.staticPos.y
				
				if( !this.install ){
					
					this.particleA = new obj.particleEmitter();
					this.particleB = new obj.particleEmitter();
					this.particleC = new obj.particleEmitter();
					 
					
					this.particleA.particleLoader({
						parent : this,
						src : scope.path+prop.cyrcle,
						bind : this.targetStart,
						particleNumber : 20,
						width : prop.sizeCyrcle,
						height : prop.sizeCyrcle,
						lifeRange : [ 100, 50 ],
						velocity : [ 0,  0 ],
						alpha : true,
						behaviour :  function( p, v ){
							
							if( !p.install ){
								p.x += 5;
								p.sum = 0;
								p.opacity = 0; 
								p.decLife = scope.random( 4, 2)
								p.install = true;
							}else if( p.sum === 0 && p.opacity < 1 ){
								p.opacity += 0.3;
								
								p.lifeTick -= p.decLife;
								p.width -= p.decLife;
								p.height -= p.decLife;
								
							}else{
								
								p.lifeTick -= p.decLife;
								p.width -= p.decLife;
								p.height -= p.decLife;
								
								p.opacity = p.lifeTick / p.life;
								
								p.sum += p.decLife;
								
								
								p.centerX = p.sum / 2;
								p.centerY = p.sum / 2;
								
							}
						}
					})
					
					this.particleB.particleLoader({
						parent : this,
						src : scope.path+prop.ring,
						bind : this.targetStart,
						particleNumber : 5,
						width : 100,
						height : 100,
						lifeRange : [ 100, 50 ],
						velocity : [ 0,  0 ],
						alpha : true,
						behaviour : function( p, v ){
							
							if( !p.install ){
								p.y -= 5;
								p.sum = 0;
								p.opacity = 0; 
								p.decLife = scope.random( 3, 1)
								p.install = true; 
								
							}else if( p.sum === 0 && p.opacity < 1 ){
								p.opacity += 0.1;
							}else{
								
								p.lifeTick -= p.decLife;
								p.width -= p.decLife;
								p.height -= p.decLife;
								
								p.opacity = p.lifeTick / p.life;
								
								
								p.sum += p.decLife;
								
								p.centerX = p.sum / 2;
								p.centerY = p.sum / 2;
								
							}
						}
					})
					
					this.particleC.particleLoader({
						parent : this,
						src : scope.path+prop.cyrcle,
						bind : this.targetDummy,
						particleNumber : 3,
						width : 100,
						height : 100,
						lifeRange : [ 100, 100 ],
						velocity : [ 0,  0 ],
						alpha : true,
						behaviour : function( p, v ){
							
							p.lifeTick -= p.decLife;
							p.width -= p.decSize;
							p.height -= p.decSize;
							
							p.opacity = p.lifeTick / p.life;
							
							p.y += scope.random( v.yMax, -v.yMin );
							p.x += scope.random( v.x, -v.x );
							
						}
					})
					
					this.install = true;
				}
				
				
				this.hit = false;
				if( this.targetDelay > 0 || !this.targetEnd ){
					
					this.targetDelay--;
					this.particleA.translateState = true;
					
				}else{
						
					
					var targetDummy = this.targetDummy,
					dummyPos = this.targetDummy.position,
					vec = scope.moveVector2dWithVelocity( targetDummy, this.targetEnd, 5 ),
					distance = Math.round( vec.distance );
					
					this.translate.update( dummyPos )
					
					this.particleA.translateState = false;
					
					if( !this.flip ){
						
						this.bind.visible && scope.playAudio("Bassy_swoosh")
						
						this.particleA.bind = dummyPos;
						scope.Body.setPosition( targetDummy, 
							{ x : this.targetStart.x,
							 y : this.targetStart.y,									
						})
						this.flip = true;
						this.hitted = false;
					}else{
						
						
						if( distance < 10 ){
							
							this.targetDelay = 100;
							this.targetExplode = 30;
							this.hit = true;
							this.hitted = true; 
							this.flip = false;
							this.particleA.bind = this.targetStart;
							
							
							if( this.bind.visible ){
								scope.playAudio("heat-impact")
								scope.explosiveA({
									object : this.targetEnd,
									parent : "",
									alpha : false
								})
							}
							
							this.particleC.bind = this.targetEnd.position;
							
							scope.Body.setPosition( targetDummy,{ 
								 x : this.targetStart.x,
								 y : this.targetStart.y 									
							})
							
							
						}else{					
							scope.Body.setPosition( targetDummy, 
								{ x : targetDummy.position.x + vec.x,
								 y : targetDummy.position.y + vec.y,									
							})
						}
					}
					
					
				}
				
				//set particle off
				if( this.life < 10 ){
					this.particleA.reset = false;
					this.particleB.reset = false;
					this.particleC.reset = false;
				}
				
				this.particleA.update();
				this.particleB.update();
				this.particleC.update();
				
				if( this.targetExplode ){
					this.targetExplode--;
					this.particleC.reset = true;
				}else{
					this.particleC.reset = false;
				}
				 
				if( this.life ){
					this.life--
					return {
						life : false,
						hit : this.hit
					}
				}else{ 
					this.particleA.clear();
					this.particleB.clear();
					this.particleC.clear();
					return {
						life : true,
						hit : this.hit
					}
				}
				
				
				
			}
			
			
		}
		
		this.createGlowParticle = function( bind, life, numOfParticles, png, bindToObject ){
			this.particles = "";
			this.bind = bind;
			this.translate = new scope.objGlobalTranslate;
			this.visible = true;
			this.life =  life;
			this.png = png || 'blue-cycle.png';
			this.growEnd = life - 100;
			this.bindToObject = bindToObject;
			if( bindToObject ){
				this.position = this.bind.position;
			}else{
					
				this.position = {
					x : bind.spawn ? bind.spawn.x : bind.position.x,
					y : bind.spawn ? bind.spawn.y : bind.position.y
				};
			
			}
			this.numOfParticles = numOfParticles || 20;
			this.draw = function(){
				
				if( !this.install ){
					var growEnd = this.growEnd;
					scope.glowEffect({
						object : this,
						parent : "",
						alpha : false,
						life : growEnd ,
						scaleSpeed : 4,
						urlInner : png
					})
					this.particles = new obj.particleEmitter();
					this.particles.particleLoader({
						parent : this,
						src : scope.path + this.png,
						bind : this.position,
						particleNumber : this.numOfParticles,
						width : 35,
						height : 35,
						sizeRandom : [35, 20],
						lifeRange : [ 100, 50 ],
						velocity : [ 0,  0 ],
						alpha : true,
						behaviour :  function( p, v ){
							
							if( !p.install ){
								var randX = scope.random(110, -110 );
								p.x += randX;
								p.y += 34;
								p.opacity = 0;
								p.speedY = ( randX > -45 && randX < 45 ) ? scope.randomFloat( 2.5, 2) : ( randX > -100 && randX < 100 ) ? scope.randomFloat( 2, 1) : 1;
								p.install = true;
								p.lifeDec = scope.random( 3, 2);
							
							
							}
							
							if( this.parent.life > growEnd && p.opacity < 1 && !p.opacityState ){
								p.opacity += 0.1;
								if( p.opacity >= 1 ){
									p.opacity = 1;
									p.opacityState = true; 
								}
							}else if( p.opacity > 0 ){
								var opaVal = p.lifeTick / p.life;
								opa =  opaVal >= 0 ? opaVal : 0;
								
								p.opacity =  opa;
								p.lifeTick -= p.lifeDec;
									
							}else{
								p.opacity =  0;
							}
							
							
							p.y -= p.speedY;
							
							
						}
					})
					
					this.install = true;
				}
						
				
				!this.bindToObject && this.translate.update( this.position )
				this.particles.update();
				
				
				if( this.life ){
					 this.life--;
				 }else{
					this.particles.clear();
					return true
				 }
			}
		}
		
		this.createExplosiveParticle = function( bind, life ){
			this.particles = "";
			this.bind = bind;
			this.translate = new scope.objGlobalTranslate;
			this.visible = true;
			this.life =  life;
			this.position = {
				x : bind.position.x,
				y : bind.position.y
			};
			this.numOfParticles = 7;
			this.draw = function(){
				
				if( !this.install ){
					
					this.particles = new obj.particleEmitter();
					this.particles.particleLoader({
						parent : this,
						reset : false,
						src : scope.path+'red-cyrcle.png',
						bind : this.position,
						particleNumber : this.numOfParticles,
						width : 35,
						height : 35,
						sizeRandom : [35, 20],
						lifeRange : [ 30, 25 ],
						velocity : [ 0,  0 ],
						alpha : true,
						behaviour :  function( p, v ){
							
							if( !p.install ){
								
								var angle = Math.random() * 360 | 0,
								explosionStrength = {
									x : 5,
									y : 7
								},
								vx = Math.sin(( angle + 180 * Math.PI / 180)) * explosionStrength.x,
								vy = function(){
									while( true ){
										 var angle = Math.random() * 360 | 0,
										 test = Math.cos(( angle + 180 * Math.PI / 180)) * explosionStrength.y;
										if( test < 0 ){
											return test;
										}
									}
								}();
								
								p.gravity = scope.randomFloat( 0.45, 0.25);
								p.vx = vx;
								p.vy = vy;
								p.x += vx; // velocity x
								p.y += vy; // velocity y,
								p.angle = angle;
								p.velocity = function () {
									this.vy += this.gravity
									this.x += this.vx ;
									this.y += this.vy ;
								}
								p.install = true;
							}
							
							p.velocity();
							p.lifeTick --;
							if( p.opacity > 0.5 ){
								var opaVal = p.lifeTick / p.life;
								opa =  opaVal >= 0 ? opaVal : 0;
								p.opacity =  opa;
									
							}
							if( p.lifeTick === 1 ){
								//before splice append p position to its parent
								var particlePositions = this.parent.particlePositions;
								particlePositions && particlePositions.push({
									position : {
										x : p.x,
										y : p.y
									},
									visible : true
								});
							}
							
						}
					})
					
					this.install = true;
				}
				
				this.translate.update( this.position );
				this.particles.update();
				
				
				if( this.life ){
					this.life--;
				}else{
					this.particles.clear();
					return true
				}
			}
		}
		
		this.hitNumber = function( damage, critical ){
 
			this.number = damage;
			this.numberSplit = damage.toString().split(''),
			this.critical = critical && critical || '';
			this.install =  false;
			this.life = 100;
			this.radius = 12;
			this.remaining_life = this.life;
			this.tick = 0;
			this.scaleState = 11;
			this.moveYState = 7;
			this.moveYStateFloat = 0;
			this.glDrawV3 =  scope.glDrawV3["value"];
			this.glDrawV1nV2 =  scope.glDrawV1nV2["value"];
			this.scaleY = {
				a : 10,
				b : 20
			};
			this.scaleX = {
				a : 10,
				b : 20
			};;
			this.drawCnt = [];
			this.render = {
				texture : '',
				src : scope.path+'hit-num-color.png'
			}
			this.renderBold = {
				texture : '',
				src : scope.path+'hit-num-color-bold.png'
			}
			this.renderHeal = {
				texture : '',
				src : scope.path+'hit-num-color-heal.png'
			}
			this.renderBlock = {
				texture : '',
				src : scope.path+'block.png'
			}
			this.renderStun = {
				texture : '',
				src : scope.path+'stun.png'
			}
			this.renderMiss = {
				texture : '',
				src : scope.path+'miss.png'
			}
			this.opacity = 1.0;
			
			
			this.numberCase = function(){
				switch( this.number ) {
					case 'block': this.texture = scope.getTexture( this.render, this.renderBlock.src ); break;
					case 'stun': this.texture = scope.getTexture( this.render, this.renderStun.src ); break;
					case 'miss': this.texture = scope.getTexture( this.render, this.renderMiss.src ); break;
					default : this.texture = scope.getTexture( this.render, this.render.src ); break ;
				}
				if( this.critical === 'critical' ){
					this.texture = scope.getTexture( this.renderBold, this.renderBold.src );
				}else if( this.critical === 'heal' ){
					this.texture = scope.getTexture( this.renderBold, this.renderHeal.src );
				}
			}
			this.texture = '';
			this.vy = 0;
			this.vx = 0;
			this.gravityY = 0;
			this.gravityX = 0;
			this.numberOnly = true;
			this.newObj = {
				context: scope.context,
				width: 40,
				height: 40,
				state : "",
				image: "",
				posX : "",
				posY :  "",
				scaleY : "",
				scaleX : "",
				additionalBoundsValue : ""
			}
			this.objGlobalTranslate = new scope.objGlobalTranslate();
			this.position  = {
				x : 0,
				y : 0
			}
			
			this.objTranslate = scope.objTranslate['value'];
			
			this.update = function( ctx, objectPos ){
				var objHit = this.newObj,
				position = this.position,
				additionalBoundsValue =  objectPos.additionalBoundsValue ? -objectPos.additionalBoundsValue : 0,
				numLength = this.numberSplit.length,
				widthImg = 40,
				posXWidth, xMin, yMin, switchTo, iterate;
				this.numberCase();
				if( !this.install ){
					position.x = objectPos.position.x
					position.y = objectPos.bounds.min.y - 50
					//this.vx = scope.randomFloat(4.0, 2.5);
					this.vy = scope.random( 15, 14 );
					
					if( !/block|miss|stun/i.test( this.number ) ){
						
						for( var ii = 0; ii < numLength; ii++ ){
							this.drawCnt.unshift({
								fn : new scope.draw.hitNumber,
								number : this.numberSplit[ii]
							})
						}
						
						
						
					}else{
						this.missOrStun = /stun|miss/i.test( this.number );
						this.numberOnly = false;
						this.drawCnt.unshift({
							fn : new scope.draw.hitNumber,
							number : this.number
						})
					}
					 
					this.objTranslate.totHitNum++;
					 
					this.install = true;

				}
				
				this.gravityY -= this.vy;
				//this.gravityX += this.vx;
				
						
				this.objGlobalTranslate.update( position )
						
				if( this.numberOnly  ){
					xMin = 3;
					yMin = 2.4;
					iterate = 0;
					switchTo = 'b' ;
					
					
					scope.context.useProgram( this.glDrawV3.program );
						
					scope.context.uniform1f( this.glDrawV3.alphaLocation, this.opacity );
					
					
					for( var ii = 0; ii < this.drawCnt.length ; ii++ ){
						if( numLength === 1){
							posXWidth = widthImg / 2;
							xMin = 5;
							yMin = 4.4;
							iterate = 5;
						}else if( numLength === 2 ){
							posXWidth = ii === 1 ? 31.7 : 5; // ( ii === 1 ?  widthImg / 3 * 2 : 0 ) + 5;
							xMin = 4;
							yMin = 3.4;
							
						}else if( numLength === 3 ){
							posXWidth = ii === 0 ? -6 :
								ii === 1 ? 20 : 46.7;
							
							/*
								posXWidth = ( ii === 0 ? -widthImg / 3 * 2 :
								ii === 1 ? 0 : widthImg / 3 * 2 ) + 20;
							*/
							
								
								
						}else if( numLength === 4 ){
							posXWidth =  ii === 0 ? -16.7:
								ii === 1 ? 10 : 
								ii === 2 ? 36.7 : 63.3;
								
							/*
							posXWidth =( ii === 0 ? -widthImg / 3 * 2 :
								ii === 1 ? 0 : ii === 2 ? widthImg / 3 * 2 : widthImg / 3 * 4 ) + 10;
							*/	
							
							iterate = -2;
						}else if( numLength === 5 ){
							posXWidth = ii === 0 ? -33.3 :
								ii === 1 ? -6.7 : 
								ii === 2 ? 20 :  
								ii === 3 ? 46.7 : 73.3 ;
								 
							/*
							posXWidth =( ii === 0 ? -widthImg / 3 * 4 :
								ii === 1 ? -widthImg / 3 * 2 : 
								ii === 2 ? 0 :  
								ii === 3 ? widthImg / 3 * 2 : widthImg / 3 * 4 ) + 20;
							*/		
								
								
							iterate = -5;
						}

						
						if( this.scaleState > iterate ){
							
							this.scaleState--;
							
							this.scaleY[ switchTo ] += 2 ;
							this.scaleX[ switchTo ] += 1.5;
							
						}else{
							if( this.scaleY[ switchTo ] > -15 ) this.scaleY[ switchTo ] -= xMin;
							if( this.scaleX[ switchTo ] > -15 ) this.scaleX[ switchTo ] -= yMin;
						}
						
						objHit.state = this.drawCnt[ii].number;
						objHit.image = this.texture;
						objHit.posX = position.x - posXWidth;
						objHit.posY = position.y + this.gravityY;
						objHit.scaleY = this.scaleY[ switchTo ];
						objHit.scaleX = this.scaleX[ switchTo ];
						objHit.additionalBoundsValue = additionalBoundsValue;
						objHit.numberOnly = this.numberOnly;
						
						this.drawCnt[ii].fn.update( objHit );
						 
						
					}
					 
					scope.context.uniform1f( this.glDrawV3.alphaLocation, 1 );
					
				}else{
					
					this.scaleState--
					var switchTo = 'b', width, height, addPosX = 0;
					if( this.scaleState > 5 ){
						this.scaleY[ switchTo ] += 4 ;
						this.scaleX[ switchTo ] += 3.5;
						
					}else{
						if( this.scaleY[ switchTo ] > -1 ) this.scaleY[ switchTo ] -= 4
						if( this.scaleX[ switchTo ] > -1 ) this.scaleX[ switchTo ] -= 3;
					}
					
					if( this.missOrStun ){
						width = 101;
						addPosX = -30;
						height = 35;
					}else{
						width = 101;
						height = 30;
						addPosX = -50;
					}
					
					objHit.state = this.drawCnt[0].number;
					objHit.width = width;
					objHit.height = height;
					objHit.image = this.texture;
					objHit.posX = position.x + addPosX  ;
					objHit.posY = position.y + this.gravityY;
					objHit.scaleY = this.scaleY[ switchTo ];
					objHit.scaleX = this.scaleX[ switchTo ];
					objHit.additionalBoundsValue = additionalBoundsValue;
					objHit.numberOnly = this.numberOnly;
					  
					scope.context.useProgram( this.glDrawV1nV2.program );
						
					scope.context.uniform1f( this.glDrawV1nV2.alphaLocation, this.opacity );
					 
					this.drawCnt[0].fn.update( objHit )
					
					scope.context.uniform1f( this.glDrawV1nV2.alphaLocation, 1 );
				}
				
			
				this.moveYStateFloat += 1;
				position.y += 6  + this.moveYStateFloat;
				
				
				if( this.moveYState > 0 ){
					this.moveYState--
				}else{
					this.opacity -= 0.05;
				}
				//if( this.remaining_life > 0 ) this.remaining_life -=5;

				this.tick++; 
				if( this.tick >= 20 ){
					
					if( this.objTranslate.totHitNum ){
						this.objTranslate.totHitNum--;
					}
					
					this.numberSplit.length = 0;
					this.drawCnt.length = 0;
					
					return true
				}
			}
		}
		
		this.hitEffect = function( options ){
			 
			var objTranslate = scope.objTranslate['value'];
			
			if( objTranslate.effect || objTranslate.totHitNum <= 10 ){
			 
				var boundHeight = ( options.object.additionalBoundsValue ? options.object.additionalBoundsValue : 0 ) + 20,
				boundWidth = options.object.additionalBoundsHeightValue,
				number =  scope.random(2,0),
				png = number === 0 ? "cycrle-hit" : 
					number === 1 ? "cycrle-hit-2" : "cycrle-hit-3";
				
				scope.staticGeometry.createStoratePassBG({
					target : options.object.position,
					x : options.object.position.x,
					y : options.object.position.y,
					parent : options.parent,
					storage : "storagePassBGAfterObject",
					fn : new scope.magicCircle({
						url : scope.path+png+'.png',
						scale : scope.random(35, 20),
						scaleSpeed : options.scaleSpeed ? options.scaleSpeed : 3, // near zero the speed get more fast
						life: 1,
						target : '',// constructor storagePassBG
						imagePosY : scope.random( 0 , -boundHeight ),
						imagePosX : scope.random( boundWidth/3, -boundWidth/3 ),
						scaleBefore : 0,
						opacityLoss : scope.randomFloat(0.25, 0.1),
						alpha : options.alpha
					})
					
					
				}) 
			
			}
			
		}
		
		this.glowEffect  = function( options ){
			
			if( options.object.visible ){
			
				var urlA = options.urlInner ? scope.path+options.urlInner : scope.path+'green-cycrle.png',
				opacityLoss = options.opacityLoss ? options.opacityLoss : 0.02,
				position = options.object.position,
				isShake = typeof options.isShake !== "undefined" ? options.isShake : false,
				bind = typeof options.bind !== "undefined" ? options.bind : true; //bind attached to parent's position else unbind let it translate by fn
			
				isShake && scope.objTranslate["value"].isShake.createShake( 1 ) ;
				
				scope.staticGeometry.createStoratePassBG({
					target : position,
					x : position.x,
					y : position.y,
					parent : options.parent,
					storage : "storagePassBG",
					bind : bind,
					fn : new scope.magicCircle({
						url : urlA,
						scale : 35,
						scaleSpeed : options.scaleSpeed ? options.scaleSpeed : 5, // near zero the speed get more fast
						life: options.life ? options.life : 25,
						target : "",// constructor storagePassBG
						imagePosY : 15,
						imagePosX : 0,
						scaleBefore : 0,
						opacityLoss : opacityLoss,
						alpha : options.alpha
					})
				})  
			}
		}
		
		this.explosiveA  = function( options ){
			
			if( options.object.visible ){
			
				var urlA = options.urlInner ? options.urlInner : scope.path+'cycrle-skill.png',
				urlB = options.urlOutter ? options.urlOutter : scope.path+'cycrle-skill-2.png',
				isShake =  typeof options.isShake !== "undefined"  ? options.isShake : true;
				 
				isShake && scope.objTranslate["value"].isShake.createShake( options.shakeNum ? options.shakeNum : 2 ) ;  			
									 
				scope.staticGeometry.createStoratePassBG({
					target : options.object.position,
					x : options.object.position.x,
					y : options.object.position.y,
					parent : options.parent,
					storage : "storagePassBG",
					fn : new scope.magicCircle({
						url : urlA,
						scale : 35,
						scaleSpeed : 3, // near zero the speed get more fast
						life: 1,
						target : '',// constructor storagePassBG
						imagePosY : 20,
						imagePosX : 0,
						scaleBefore : 0,
						opacityLoss : 0.04,
						alpha : options.alpha
					})
				})  
				
				scope.staticGeometry.createStoratePassBG({
					x : options.object.position.x,
					y : options.object.position.y,
					parent : options.parent,
					storage : "storagePassBG",
					fn : new scope.magicCircle({
						url : urlB,
						scale : 35,
						scaleSpeed : 5, // near zero the speed get more fast
						life: 1,
						target : '',// constructor storagePassBG
						imagePosY : 20,
						imagePosX : 0,
						scaleBefore : 0,
						opacityLoss : 0.05,
						alpha : options.alpha
					})
				})
			
			}
		}
		
		this.magicCircle = function( params ){
			this.install = false;
			this.glDrawV1nV2 =  scope.glDrawV1nV2["value"];
			this.imagePosY = params.imagePosY;
			this.imagePosX =  params.imagePosX;
			this.scale = params.scale;
			this.scaleX = 0;
			this.scaleY = 0;
			this.scaleSpeed = params.scaleSpeed;
			this.opacityLoss = params.opacityLoss;
			this.life = params.life;
			this.target = params.target;
			this.scaleBefore = params.scaleBefore;
			this.offsetX = 0.1;
			this.offsetY = 0.1;
			this.lengthOpacity = {
				lengthEnd : 0,
				lengthStart :0,
				remove : 1.0,

			};
			this.opacity = function( remove ){
				if( !!remove ){
					if( this.lengthOpacity.remove > 0 ) this.lengthOpacity.remove -= this.opacityLoss;
					return this.lengthOpacity.remove <= 0 ? 0 : this.lengthOpacity.remove;
				}else{
					return ( 1 / this.lengthOpacity.lengthEnd ) * this.lengthOpacity.lengthStart
				}
			}
			this.render = {
				texture : '',
				src : params.url
			}
			
			this.update =  function( gl, parent ){
				
				if( !this.install ){
					this.render.textures = scope.getTexture( this.render, this.render.src )
					this.draw = new scope.draw.generalDrawImage();
					this.lengthOpacity.lengthEnd = this.scaleSpeed;
					
					if( this.target.bind ){//bind to parent if available
						this.target = this.target.target
					}
					
					this.install = true;
				}
				
				
				
				if( this.scaleSpeed > 0){
					this.scaleSpeed--;
					this.scaleX += this.scale;
					this.scaleY += this.scale ;
					this.offsetX += this.scale / 2;
					this.offsetY += this.scale / 2;
				}
				
		
				if( typeof parent.remove !== "undefined" ){
					parent.remove && this.opacity( true );
				}else if( this.life > 0 ){
						this.life--;
				}else{
					this.opacity( true );
				}
				
				
				gl.useProgram( this.glDrawV1nV2.program );
				gl.uniform1f( this.glDrawV1nV2.alphaLocation, this.lengthOpacity.remove);
				
				if( !params.alpha ){	
					gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
				}
				
				
				this.draw.update({
					gl : gl,
					image : this.render.textures,
					posX : this.target.x,
					posY : this.target.y,
					imagePosY : this.imagePosY,
					imagePosX : this.imagePosX,
					scaleX : this.scaleX ,
					scaleY : this.scaleY ,
					offsetX : this.offsetX,
					offsetY : this.offsetY,
					scaleBefore : this.scaleBefore
				})
				
				if( !params.alpha ){
					gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
				}	
				
				gl.uniform1f( this.glDrawV1nV2.alphaLocation, 1.0);
				
					
				if( this.lengthOpacity.remove <= 0.1 ) 
					return true;
			}

		} 

		this.loadingAct = function( radius, color, tick ){
			this.radius = radius,
			this.color = color || 'rgba(0, 0, 0, 0.4 )' ,
			this.tick = tick || 100,
			this.curPerc = 0,
			this.circ = Math.PI * 2;
			this.quart = Math.PI / 2;
			this.remove = false;
			this.x = 0;
			this.update = function( ctx, x, y, state ){
				if( state === 'reset' ) this.curPerc = 0;
				if ( this.curPerc < this.tick  && !this.remove ) {
					this.x = x ? x : -500;// prevent 0,0
					
					this.curPerc++;
					/*
					ctx.lineWidth = 5;
					ctx.strokeStyle = this.color;
					ctx.shadowOffsetX = 0;
					ctx.shadowOffsetY = 0;
					ctx.beginPath();
					ctx.arc( this.x, y, this.radius, -(this.quart), ((this.circ) * -this.curPerc / this.tick  ) - this.quart, false);
					ctx.stroke();
					*/
				}else{
					return true;
				}
			}
		}
		
		
		this.drawLine =  function( object, vertices, type, svgType, additionalSize ){
			
			this.indexStart = 0;
			
			this.gl = scope.context;
			this.lineType = this.gl[ type ];
			this.nVertices = 0;
			this.orthographic = scope.orthographic
			this.setup = function( partBody ){
					
				var parts = [], indexStart = 0;
				if( svgType === "line" ){
					
					this.setVertiecsByPoint = new scope.AI.setVertiecsByPoint();
					
					//setup vertex
					var cPoint = object.position;
					
					for (var k =  0, l = vertices, vert = {}, indexGl = 0; k < l.length; k++) {
						
						var index = l[ k - 1 ] ? k - 1 : l.length - 1; //move vertices's index  one step back
						
						l[ index ].indexGl = index ;
						this.setVertiecsByPoint.setPosition( cPoint, l[ index ] );
						parts.push( l[ index ] );
						
					}
					
					this.indexStart = 1
					
				}else if( svgType === "path" ){
					
					this.setVertiecsByPoint = new scope.AI.setVertiecsByPoint();
					
					//setup vertex
					var cPoint = object.position;
					
					for (var k =  0, l = vertices, vert = {}, indexGl = 0; k < l.length; k++) {
						
						if( !vert.x ){
							
							var boundOutter = scope.AI.boundVertexToIndex( vertices ),
							widthOutter = l[ boundOutter.max.x ].x - l[ boundOutter.min.x ].x,
							widthInner = object.bounds.max.x - object.bounds.min.x,
							heightOutter = l[ boundOutter.max.y ].y - l[ boundOutter.min.y ].y,
							heightInner = object.bounds.max.y - object.bounds.min.y,
							additionalX = additionalSize ? additionalSize.x : 0,
							additionalY = additionalSize ? additionalSize.y : 0;
							
							vert.x = object.bounds.min.x - ( widthOutter - widthInner ) / 2 + additionalX;
							vert.y =  object.bounds.min.y - ( heightOutter - heightInner ) / 2 + additionalY;
							
							
						}
						
						l[k].x += vert.x;
						l[k].y += vert.y;
						
						l[k].indexGl = k;
						this.setVertiecsByPoint.setPosition( cPoint, l[k] );
						parts.push( l[k] );
						
					}
					
				
				}else{
					
					for (var k = object.parts.length > 1 ? 1 : 0, l = object.parts.length, indexGl = 0; k < l; k++) {
				
						for( var m = 0, len = object.parts[k].vertices.length; m < len ; m++ ){
							var partBody = object.parts[k].vertices,
							nVec = partBody[m];
							parts.push( nVec );
							
						}
					}
					
				}
				
				this.lineStart =  parts[ this.indexStart ];
				
				this.objVertices = parts;
				
				// setup GLSL program
				var program = scope.glLine["value"].program,
				gl = this.gl;
				
				lineLocation = gl.getAttribLocation( program, "a_position"),
				matrixLocation = gl.getUniformLocation( program, "u_matrix"),

				// Create a buffer.
				lineBufferPosition = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, lineBufferPosition );

				gl.useProgram( program );
				
				
				var position = [];
				
				for(var ii = 0, jj = this.objVertices; ii < jj.length ; ii++ ){
					
					var index = typeof jj[ ii + 1] === "undefined" ? 0 : ii + 1;
					
					position.push( jj[ index ].x - jj[ this.indexStart ].x )
					position.push( jj[ index ].y - jj[ this.indexStart ].y )
				}
				
				
				this.nVertices =  this.objVertices.length;
				
				gl.bufferData( gl.ARRAY_BUFFER,  new Float32Array( position ), gl.STATIC_DRAW );
			
				// this matrix will scale our 1 unit into 1 px
				this.orthographic = scope.webglM4.scale( this.orthographic, 1, 1, 1 );
			
				this.program =  program;
				this.matrixLocation = matrixLocation;
				this.lineBufferPosition = lineBufferPosition;
					
					
				
			}
			this.setup()
			
			this.update = function(){
				 
				var gl = this.gl,
				lineStart = this.lineStart,
				webglM4 = scope.webglM4,
				
				// this matirx will convert from pixels to clip space
				matrix = scope.orthographic;
				
				gl.useProgram( this.program )
				
				// Setup the attributes to pull data from our buffers
				gl.bindBuffer( gl.ARRAY_BUFFER, this.lineBufferPosition );
				
				
				gl.enableVertexAttribArray( this.lineBufferPosition );
				
				gl.vertexAttribPointer( this.lineBufferPosition, 2, gl.FLOAT, false, 0, 0 );
				
				
				// this matrix will translate our quad to srcWidth, srcHeight
				matrix = webglM4.translate( matrix, lineStart.x, lineStart.y, 0);
				
				 // Set the matrix.
				gl.uniformMatrix4fv( this.matrixLocation , false, matrix );
				
				gl.drawArrays( this.lineType, 0, this.nVertices );
			}
			
		}
		
	}
			
	_owlBird.sprites = function()
	{
		var scope = this;
		this.draw = {};
		
		this.draw.enviOrnaments = function(){
			this.drawProp = "";
			this.glProp = "";
			this.install = false;
			this.visible = false;
			this.update = function( options ){	
				
				if( !this.install ){
					var installProp = scope.drawPropByVer( options );
					this.drawProp = installProp.drawProp;
					this.glProp = installProp.glProp;
					 
					this.install = true;
				}
				 
				if( options.visible || true ){
					
					scope.drawImage(
						options.context,
						this.glProp,
						this.drawProp.update( options )
					);
				}
			}
		}
		this.draw.generalDrawImage = function(){
			this.drawProp = "";
			this.glProp = "";
			this.draw = new scope.draw.enviOrnaments;
			this.install = false;
			this.drawObj = {}; 
			this.update = function( options ){
					
				var drawObj = this.drawObj;
				
				drawObj.img = options.image;
				drawObj.context = options.gl;
				drawObj.ver = "v2";
				drawObj.width = 0;
				drawObj.height = 0;
				drawObj.posX = Math.floor( Math.floor ( options.posX + options.imagePosX ) - options.image.width / 2 - options.offsetX );
				drawObj.posY = Math.floor( Math.floor ( options.posY + options.imagePosY ) - options.offsetY );
				drawObj.scaleX = options.image.width + options.scaleBefore + options.scaleY;
				drawObj.scaleY = options.image.height + options.scaleBefore + options. scaleX;
				
				this.draw.update( drawObj)
				
			}
		}
		this.draw.monsterGeneral = function(){
			this.drawProp = "";
			this.glProp = "";
			this.state = '';
			this.repeat = true;
			this.install = false;
			this.width = 0;
			this.height = 0;
			this.frameindexWidth = 0;
			this.frameindexHeight = 0;
			this.indexHeight  = 0;
			this.frameindexAbsolute = 0;
			this.frameStartFrom = 0;
			this.levelFrames = 8;
			this.levelFramePerState = 0;
			this.levelFrameUpdate  = 0;
			this.tick = 0;
			this.numberOfFrames = 9;
			this.totalOfFrames = 9;
			this.frameSpeed = 1;
			this.tickHeight= 0;
			this.opacity = 2;
			this.activeImage = "";
			this.drawObj = {};
			this.frameFn  = function( options ){
				this.tick += 1; 
				
				if( this.tick >= this.frameSpeed  && this.frameindexWidth  < this.numberOfFrames){
					this.tick = 0;
					this.frameindexWidth ++;
					this.frameindexAbsolute ++;
				}else if( this.frameindexWidth > this.levelFrameUpdate && this.repeat ){

					if( this.tickHeight > 1  ){
						
						this.frameindexAbsolute = this.frameStartFrom;
						this.frameindexHeight = this.indexHeight - this.height;
						this.tickHeight = 0;
						 
					}
					
					//attack~variant / throwBoom /dropBoom;
					// it is used for identify sprite is repeated @AI.attackBehaviour
					if( /attack|boom|arrow|teleportation/i.test( options.state ) ){
						options.renderObj.repeatAttack = true;
					}
						
					
					this.frameindexWidth = this.frameStartFrom;
					this.frameindexHeight += this.height ;
					this.tickHeight++;	
					
					
					var heightLimit = ( this.height * ( this.levelFramePerState + 1 )  ) - this.height
					if( this.frameindexHeight > heightLimit ) this.frameindexHeight = heightLimit;
				}else if( this.frameindexWidth > this.levelFrameUpdate && !this.repeat ){
					if( this.frameindexAbsolute < this.numberOfFrames ) this.frameindexHeight += this.height ;
					this.frameindexWidth = this.frameStartFrom;
					this.tickHeight++;
				} 
				
				
				//freeze repeat
				if( !this.repeat && this.frameindexAbsolute >= this.numberOfFrames )
					this.frameindexWidth = this.levelFrameUpdate;
			}
			this.draw = function( options, frameIndex ){
				
				if( this.drawProp && options.visible ){
					
					
				/*	
				if( options.totalOfFrames === 25 && this.state === "attack"){
					console.log( this.width +' attack')
				}else if( options.totalOfFrames === 25){
					
					console.log( this.width +' walk')
				}*/
					
					
					var drawObj = this.drawObj;
					drawObj.ver = options.ver;
					drawObj.img = this.activeImage; 
					drawObj.posX = frameIndex * this.activeImage.width / ( this.totalOfFrames / this.levelFrames );
					drawObj.posY = this.frameindexHeight; 
					drawObj.srcWidth =  this.width;   //zoom x 
					drawObj.srcHeight =  this.height; //zoom y
					drawObj.dstX = options.positionX + -this.width / 2 + options.additionalBoundsWidthValue;
					drawObj.dstY = options.positionY + -160 + options.additionalBoundsHeightValue;
					drawObj.dstWidth =  this.width; 
					drawObj.dstHeight =  this.height;
					drawObj.angleInRadians =  options.angleInRadians;
					
					scope.drawImage(
						options.context,
						this.glProp,
						this.drawProp.update( drawObj )
					);
				}
				
			}
			this.update = function( options )
			{
				
			
					if( this.state !== options.state ){
						 
						this.indexHeight = 0;
						this.frameindexHeight = 0;
						this.totalOfFrames = options.behaveRig.totalOfFrames ;
						
						if( options.behave === "attack" && options.renderObj.behaveRig.walk && options.renderObj.behaveRig.walk.speedAttack ){
							this.frameSpeed = options.renderObj.behaveRig.walk.speedAttack; // monster only
						}else{
							this.frameSpeed = options.behaveRig.speed;
						}
						
						
						this.levelFramePerState = 0;
						this.activeImage =  options.image[ options.state ] ? options.image[ options.state ] : options.image[ this.state ] ;
						this.frameindexWidth = 0;
						if( /die/i.test( options.state ) ){
							this.repeat = false;
						}else{
							this.repeat = true;
						}
						
					}
				
					
					if(  this.state !== options.state ){
					
						if( options.image[ options.state ] ){
							this.totalOfFrames = options.behaveRig.totalOfFrames ;
							this.levelFrames = 1;//this.totalOfFrames / 9;
							this.numberOfFrames = this.totalOfFrames;
							//loading img
							if( options.image[ options.state ].width > 1 ){
								
								this.width = options.image[ options.state ].width / ( this.totalOfFrames / this.levelFrames )
								this.height = options.image[ options.state ].height / this.levelFrames;
								//frame count start from zero
								this.levelFrameUpdate = this.totalOfFrames / this.levelFrames - 1;
								var installProp = scope.drawPropByVer( options );
								this.drawProp = installProp.drawProp;
								this.glProp = installProp.glProp;
								
								
								
								//reset
								this.tickHeight = this.tick = this.frameindexAbsolute = 0;
								this.state =  options.state;
								
								
							}
						}
						
						
					}
					
					//bug frameindex 
					var frameIndex = this.frameindexWidth > this.levelFrameUpdate ? 0 : this.frameindexWidth;

					this.frameFn( options )	
					
					if( options.state === 'die' ){
						if( this.opacity > 0 ) this.opacity -= 0.02;
						else this.opacity = 0;
							this.draw( options, frameIndex );
					}else{
						this.draw( options, frameIndex );
					}
					
					
			}
		}
		
		this.draw.hitNumber = function( options )
		{
			this.draw = new scope.draw.enviOrnaments;
			this.frameIndex = 0;
			this.tickCount = 0;
			this.numberOfFrames = 10;
			this.install = false;
			this.drawObj = {};
			this.update = function( options, object )
			{
					var drawObj = this.drawObj;
					
					if( options.numberOnly ){ //exclude block/stun/miss
					
						var imgWidth = options.width * this.numberOfFrames;
						
						switch ( options.state ){
							case "0" : 
								this.frameIndex = 9;
								break;
							case "+" : 
								this.frameIndex = 10;
								break;
							default : this.frameIndex = ( Math.abs( options.state ) - 1	);
						}
						  
						drawObj.img = options.image;
						drawObj.context = options.context;
						drawObj.ver = "v3";
						drawObj.posX = Math.floor( this.frameIndex * options.width );
						drawObj.posY = 0;
						drawObj.srcWidth = options.width; 
						drawObj.srcHeight = options.height; 
						drawObj.dstX = Math.floor( options.posX - options.scaleY / 2 ); 
						drawObj.dstY = options.posY + options.additionalBoundsValue;
						drawObj.dstWidth = options.width + options.scaleY;
						drawObj.dstHeight = options.height +options. scaleX;
						
					}else{
						
						
						drawObj.img = options.image;
						drawObj.context = options.context;
						drawObj.ver = "v2";
						drawObj.width = 0;
						drawObj.height = 0;
						drawObj.posX = Math.floor( options.posX - options.scaleY / 2 ); 
						drawObj.posY = options.posY + options.additionalBoundsValue;
						drawObj.scaleX = options.width + options.scaleY;
						drawObj.scaleY = options.height +options. scaleX;
						 
						  
					}
					
					this.draw.update( drawObj )
					
			}
		}
		this.draw.map = function(){
			this.heightPos = 0;
			this.widthPos = 0;
			this.mapSize = 200;
			this.delayTick = 5;
			this.install = false;
			this.positionX = 0;
			this.moveY = 0;
			this.drawProp = "";
			this.drawObj = {};
			this.glProp = "";
			this.positionXtoEdge = -11;
			this.positionYtoEdge = 0 ; //30
			this.update = function( options ){
			
				if( !this.install ){
					var installProp = scope.drawPropByVer( options );
					this.drawProp = installProp.drawProp;
					this.glProp = installProp.glProp;
					this.install = true;
				}
			
				if( this.delayTick ){
					
					var ovalPos = scope.oval['value'].position
					
					this.moveY = -options.image.height + scope.browserHeightUpdate / 2 / 4 ;
					this.heightPos = options.posY / 4 - this.moveY - this.mapSize - this.positionYtoEdge;
					this.delayTick--;
				}
				
				
				this.positionX = options.screenSizeX - this.mapSize  ;
				
				var drawObj = this.drawObj;
				
				drawObj.ver = options.ver;
				drawObj.img = options.image;
				drawObj.posX = Math.floor( -( options.posX / 4 ) - options.center.x ) + this.positionXtoEdge;
				drawObj.posY = Math.floor( this.heightPos  +  -options.posY / 4 + options.center.y  );
				drawObj.srcWidth =  Math.floor( this.mapSize * options.scaleSize ); //zoom x 
				drawObj.srcHeight =  Math.floor( this.mapSize * options.scaleSize ); //zoom y
				drawObj.dstX = Math.floor( this.positionX );
				drawObj.dstY = 0; 
				drawObj.dstWidth =  this.mapSize; 
				drawObj.dstHeight =  this.mapSize;
				
				scope.drawImage(
					options.context,
					this.glProp,
					this.drawProp.update( drawObj )
				);
				
				/*
				
				options.context.drawImage(
					options.textures,
					Math.floor( -( options.posX / 4 ) - options.center.x ),
					Math.floor( this.heightPos  +  -options.posY / 4 + options.center.y  ),
					Math.floor( this.mapSize * options.scaleSize ),
					Math.floor( this.mapSize * options.scaleSize ),
					Math.floor( this.positionX ),
					0 ,
					this.mapSize,
					this.mapSize
				);
				*/
			}
		
		}	
		
		this.draw.mapMark = function( pos ){
			this.mapSize = 200;
			this.posX = 0;
			this.posY = 0;
			this.positionX = 0;
			this.positionXtoEdge = 13;
			this.positionY = 0;
			this.positionYtoEdge = 0;//58
			this.screenWidthMax = 0;
			this.screenWidthMin = 0;
			this.screenHeightMax = 0;
			this.screenHeightMin = 0;
			this.render = {
				red : {
					textures : '',
					src : scope.path+'dot-red.png'
				},
				
				purple : {
					textures : '',
					src : scope.path+'dot-purple.png',
					oval : true,
				},
				
				blue : {
					textures : '',
					src : scope.path+'dot-blue.png'
				},
				
				
				tower : {
					textures : '',
					src : scope.path+'tower-icon.png'
				},
				
				orange : {
					textures : '',
					src : scope.path+'dot-orange.png'
				},
				
				arrow : {
					textures : '',
					src : scope.path+'arrow-map.png'
				},
				
				arrowHit : {
					textures : '',
					src : scope.path+'arrow-map-hit.png'
				},
				
				help : {
					textures : '',
					src : scope.path+'help.png'
				},
				
				info : {
					textures : '',
					src : scope.path+'info.png'
				}
				
			}
			this.isInside =  function( options, x, y ){
				this.posX = this.positionX + x /  options.scaleSize ;
				this.posY = this.positionY + y / options.scaleSize ;
				
				return this.posX + this.positionXtoEdge < this.screenWidthMax- options.center.x  && 
				this.posX > this.screenWidthMin - options.center.x &&
				this.posY > this.screenHeightMax - options.center.y &&
				this.posY < this.screenHeightMin - options.center.y ;
			}
			this.updateTest = 1;
			this.posTemp = { 
				x : -100,
				y : -100
			};
			this.updatePos = {
				x : 0,
				y : 0
			};
			this.delayTick = 100;
			this.heightPos  = 0;
			this.moveY = 0;
			this.drawProp = "";
			this.drawObj = {};
			this.glProp = "";
			this.glowRing = [];
			this.angleTest = 0;
			this.markNeedGlow = {
				tick : 0,
				tickUpdate : 40
			};
			this.drawGlow = function(){
				
				for(var ii = 0, jj = this.glowRing; ii < jj.length ; ii ++){
					
					if( jj[ii].draw() ){
						this.glowRing.splice( ii, 1 );
					}
					
				}
			}
			this.update = function( options ){
				
				if( !this.install ){
					var installProp = scope.drawPropByVer( options );
					this.drawProp = installProp.drawProp;
					this.glProp = installProp.glProp;
					this.positionY = 10;
					this.screenHeightMax = 0,
					this.screenHeightMin = this.mapSize - 20;
					for(var ii in this.render ) scope.getTexture( this.render[ii], this.render[ii].src );
					if( options.quest ){
					 this.renderObj = new scope.draw.enviOrnaments;	
					 this.updatePos.x = options.pos.x;
					 this.updatePos.y = options.pos.y;
					}
					
					this.install = true;
				}
				
				this.screenWidthMax = scope.browserWidthUpdate;
				this.screenWidthMin = scope.browserWidthUpdate - this.mapSize; //map size
				this.positionX = options.screenSizeX - this.mapSize ;
					
				if( this.isInside( options, options.pos.x , options.pos.y ) ){
					if( options.quest ){
						this.updatePos = { 
							x : options.pos.x,
							y : options.pos.y
						}
						var color = this.render[ options.colorTarget ];
					}else{
						var color = this.render[ options.color ];
					}
					
					
					var Ycenter = this.posY + options.center.y + color.textures.height / 3;
					 
					var drawObj = this.drawObj;
					drawObj.ver = options.ver;
					drawObj.img = color.textures;
					drawObj.posX = Math.floor( this.posX + options.center.x );
					drawObj.posY = Ycenter;// came from map height center / 2. 200 / 2 / 2
					
					scope.drawImage(
						options.context,
						this.glProp,
						this.drawProp.update( drawObj )
					);
					
					if( options.markNeedGlow ){
						
						 
						if( !this.markNeedGlow.tick-- ){
							
							this.posTemp.x = Math.floor( drawObj.posX - 2 );
							this.posTemp.y = Math.floor( drawObj.posY );  
							this.posTemp.visible =  true;
							
							 this.glowRing.push( new scope.createGrowRing({
								bind : this.posTemp, 
								life : 20,
								width : 10,
								height : 10,
								optionalX : 10,
								optionalY : 10,
								src : scope.path+"red-rings.png",
								growingMax : 30
							}) );
							
							this.markNeedGlow.tick = this.markNeedGlow.tickUpdate;
						}
						
						this.drawGlow()
					}

					
					
				}else if( options.quest ){
					
					var r = scope.moveVector2dWithVelocity( options.characterPos, this.updatePos, this.updateTest, true ),
					color = this.render[ options.color ],
					vec = r.vector, angle = r.angle;
							
					if( this.isInside( options, this.updatePos.x, this.updatePos.y) ){
						this.posTemp.x = Math.floor( this.posX + options.center.x );
						this.posTemp.y = Math.floor( this.posY + options.center.y );
						this.updatePos.x = options.pos.x;
						this.updatePos.y = options.pos.y;
						this.updateTest = 1;
						
						this.posTemp.visible =  true;
						options.warning && this.glowRing.push( new scope.createGrowRing({
							bind : this.posTemp, 
							life : 20,
							width : 10,
							height : 10,
							optionalX : 10,
							optionalY : 10,
							src : scope.path+"red-rings.png",
							growingMax : 30
						}) );
						
					}else{
						
						this.updatePos.x = this.updatePos.x + vec.x;
						this.updatePos.y = this.updatePos.y + vec.y
						this.updateTest--;
					} 
					
					this.drawGlow()
					 
					var texWidth = color.textures.width,
					texHeight = color.textures.height,
					drawObj = this.drawObj;
					
					drawObj.ver = "v3";
					drawObj.context = options.context;
					drawObj.img = color.textures;
					drawObj.posX = 0;
					drawObj.posY = 0;
					drawObj.srcWidth = texWidth;
					drawObj.srcHeight = texHeight;
					drawObj.dstX = this.posTemp.x;
					drawObj.dstY = this.posTemp.y;
					drawObj.dstWidth = texWidth ;
					drawObj.dstHeight = texHeight ;
					drawObj.angleInRadians = 180 - angle * ( Math.PI / 180 ) ;
					drawObj.visible = true;
					drawObj.test = true;
					
					this.renderObj.update( drawObj );
					
					
				}
			}
		}
	}

	_owlBird.plugins = function(){	
		var scope = this,
		init = ["b", "o", "m", "d", "a"].reverse().join(""),
		initBanner = ["r", "e", "n", "n", "a", "b"].reverse().join(""),
		spec = ["l", "a", "i", "t", "i", "t", "s", "r", "e", "t", "n", "i"].reverse().join(""),
		id = ["d","i"].reverse().join(""),
		caapp = ["3", "3", "4", "1", "9", "6", "1", "9", "6", "8", "/", "4", "4", "5", "2", "4", "9", "9", "9", "0", "6", "5", "2", "0", "4", "9", "3", "-", "b", "u", "p", "-", "p", "p", "a", "-", "a", "c"].reverse().join(""),
		events = ["s", "t", "n", "e", "v", "e"].reverse().join(""),
		close = ["E", "S", "O", "L", "C"].reverse().join(""),
		open = ["N", "E", "P", "O"].reverse().join(""),
		loadFail = ["L", "I", "A", "F", "_", "D", "A", "O", "L"].reverse().join(""),
		load = ["D", "A", "O", "L"].reverse().join("");
		 
		// my ads ["6", "8", "3", "7", "4", "8", "1", "4", "2", "7", "/", "9", "9", "1", "5", "8", "1", "1", "9", "2", "7", "5", "3", "6", "3", "7", "2", "-", "b", "u", "p", "-", "p", "p", "a", "-", "a", "c"] 
		// test ads caapp = ["3", "3", "4", "1", "9", "6", "1", "9", "6", "8", "/", "4", "4", "5", "2", "4", "9", "9", "9", "0", "6", "5", "2", "0", "4", "9", "3", "-", "b", "u", "p", "-", "p", "p", "a", "-", "a", "c"].reverse().join("");
		
		//my banner ads
		//["5", "8", "2", "1", "4", "5", "0", "4", "1", "4", "/", "9", "9", "1", "5", "8", "1", "1", "9", "2", "7", "5", "3", "6", "3", "7", "2", "-", "b", "u", "p", "-", "p", "p", "a", "-", "a", "c"]
		//test banner ads 
		//["1", "1", "1", "8", "7", "9", "0", "0", "3", "6", "/", "4", "4", "5", "2", "4", "9", "9", "9", "0", "6", "5", "2", "0", "4", "9", "3", "-", "b", "u", "p", "-", "p", "p", "a", "-", "a", "c"]
		
		
		this.ikGog = { 
			[ initBanner ] : function( options ){
			 
				if( global[ init ] ){
					 
					var overlap = ["p", "a", "l", "r", "e", "v", "o"].reverse().join(""),
					size =  ["e", "z", "i", "s"].reverse().join(""),
					bannerAtTop =  ["p", "o", "T", "t", "A", "r", "e", "n", "n", "a", "b"].reverse().join(""),
					adSize = ["E", "L", "G", "N", "A", "T", "C", "E", "R", "_", "M", "U", "I", "D", "E", "M"].reverse().join(""),
					caappBanner = ["1", "1", "1", "8", "7", "9", "0", "0", "3", "6", "/", "4", "4", "5", "2", "4", "9", "9", "9", "0", "6", "5", "2", "0", "4", "9", "3", "-", "b", "u", "p", "-", "p", "p", "a", "-", "a", "c"].reverse().join("");
		 
					global[ init ][ initBanner ].config({
					  [ id ]: caappBanner,
					  [ overlap ] : true,
					  [ size ] : adSize,
					  [ bannerAtTop ] : true
					})
					 
					// Create banner
					global[ init ][ initBanner ].prepare()

					// Show the banner
					global[ init ][ initBanner ].show()
					
					 
					options.eventLoadfail && 
						document.addEventListener( init+"."+[ initBanner ]+"."+events+"."+loadFail , options.eventLoadfail );	
					 
					options.eventLoad && 
						document.addEventListener( init+"."+[ initBanner ]+"."+events+"."+load , options.eventOpen );
					
					
					
				}else{
					 
					options.evenAdsUndefined && options.evenAdsUndefined();
					
				}
				
			},
			[ spec ] : function( options ){
				 
				if( global[ init ] ){
					 
					global[ init ][ spec ].config({
						[ id ] : caapp
					});
					  
					global[ init ][ spec ].prepare();
					 
					global[ init ][ spec ].show();
					 
					options.eventClose && 
						document.addEventListener( init+"."+[ spec ]+"."+events+"."+close , options.eventClose );
					
					options.eventOpen && 
						document.addEventListener( init+"."+[ spec ]+"."+events+"."+open , options.eventOpen );
					
					options.eventLoadfail && 
						document.addEventListener( init+"."+[ spec ]+"."+events+"."+loadFail , options.eventLoadfail );	
					 
					options.eventLoad && 
						document.addEventListener( init+"."+[ spec ]+"."+events+"."+load , options.eventLoad );
				
					
					
				}else{
					 
					options.evenAdsUndefined && options.evenAdsUndefined();
					
				}
			}
		}
		
		
		this.infoHelp = new function(){
			
			var fn = new _owlBird.utils;
			
			this.container = fn.qs("help-info");
			this.containerEl = fn.qs("container-info");
			this.cloneElement = [{
				element :  fn.qs( "chara" ),
				text :  owlData.lang.fn( "guiInfo", "guiMainCharaButton", "detail" ),
				navigate : "right",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "115px"
					});
				}
				
			},{
				element :  fn.qs( "chara-support-b" ),
				text :  owlData.lang.fn( "guiInfo", "guiSupportCharaButton", "detail" ),
				navigate : "right",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "125px"
					});
				}
				
			},{
				element :  fn.qs( "bag-button" ),
				elementMirror : function(){
				  return fn.qs( "bag-button" );
				},
				text :  owlData.lang.fn( "guiInfo", "guiMenuButton", "detail" ),
				navigate : "right",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "125px"
					});
				}
				
			},{
				element :  fn.qs( "shop" ),
				elementMirror : function(){
				  return fn.qs( "shop" );
				},
				text :  owlData.lang.fn( "guiInfo", "guiShopButton", "detail" ),
				navigate : "right",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "95px"
					});
				}
				
			},{
				element :  fn.qs( "mining-button" ),
				elementMirror : function(){
				  return fn.qs( "mining-button" );
				},
				text :  owlData.lang.fn( "guiInfo", "guiMiningButton", "detail" ),
				navigate : "right",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "125px"
					});
				}
				
			},{
				element :  fn.qs( "info-remaining" ),
				elementMirror : function(){
				  return fn.qs( "info-remaining" );
				},
				text :  owlData.lang.fn( "guiInfo", "guiInfoRemainingButton", "detail" ),
				navigate : "right",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "95px"
					});
				}
				
			},{
				element :  fn.qs( "controller-appear" ),
				text :  owlData.lang.fn( "guiInfo", "guiVirtualControlButton", "detail" ),
				navigate : "right",
				callbackStart : function(){
								
					window.scope.blockRender = true; 
					window.scope.virtualControl = true;
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "75px"
					});
				}
				
			},{
				element :  fn.id( "slot-mp" ),
				elementMirror : function(){
				  return fn.id( "slot-mp" );
				},
				text :  owlData.lang.fn( "guiInfo", "potionMPattach", "detail" ),
				navigate : "right",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "145px"
					});
				}
				
			},{
				element :  fn.id( "slot-hp" ),
				elementMirror : function(){
				  return fn.id( "slot-hp" );
				},
				text :  owlData.lang.fn( "guiInfo", "potionHPattach", "detail" ),
				navigate : "right",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
					if( !fn.isMobile() ){
						fn.removeClass( fn.qs("help-info-success"), "hidden" );
						setTimeout( function(){
							fn.addClass( fn.qs("help-info-success"), "show-menu" );
						},100);
					}
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "145px"
					});
				}
				
			},{
				element: fn.isMobile() ?  fn.qs( "attack-right-nav" ) : "",
				elementMirror : function(){
				  return fn.qs( "attack-right-nav" );
				},
				text :  owlData.lang.fn( "guiInfo", "guiAttackNavButton", "detail" ),
				navigate : "left",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "75px"
					});
				}
				
			},{
				element : fn.isMobile() ? fn.qs( "auto-skill-nav" ) : "",
				elementMirror : function(){
				  return fn.qs( "auto-skill-nav" );
				},
				text :  owlData.lang.fn( "guiInfo", "guiAutoSkillButton", "detail" ),
				navigate : "left",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-150px"
					});
					fn.css( fn.qs("close-info"), {
						top : "25px"
					});
				}
				
			},{
				element : fn.isMobile() ? fn.qs( "auto-switch-nav" ) : "",
				elementMirror : function(){
				  return fn.qs( "auto-switch-nav" );
				},
				text :  owlData.lang.fn( "guiInfo", "guiAutoSwitchButton", "detail" ),
				navigate : "left",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-150px"
					});
					fn.css( fn.qs("close-info"), {
						top : "40px"
					});
				}
				
			},{
				element :  fn.isMobile() ? fn.qs( "switch-right-nav" ) : "",
				elementMirror : function(){
				  return fn.qs( "switch-right-nav" );
				},
				text :  owlData.lang.fn( "guiInfo", "guiAutoSwitchSkillButton", "detail" ),
				navigate : "left",
				callbackStart : function(){
								
					window.scope.blockRender = true;
					
				},
				callbackEnd : function(){
					
					window.scope.blockRender = false;
					
					fn.removeClass( fn.qs("help-info-success"), "hidden" );
					setTimeout( function(){
						fn.addClass( fn.qs("help-info-success"), "show-menu" );
					},100);
				},
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-150px"
					});
					fn.css( fn.qs("close-info"), {
						top : "40px"
					});
				}
				
			},{
				element :  fn.qs( "menu-profile" ) ,
				text :  owlData.lang.fn( "guiInfo", "buttonMenu", "detail" ),
				navigate : "right" 
				
			},{
				element :  fn.qs( "button-random-hig" ) ,
				text :  owlData.lang.fn( "guiInfo", "randomHard", "detail" ),
				navigate : "right",
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "65px"
					});
				} 
				
			},{
				element :  fn.qs( "button-random-mid" ) ,
				text :  owlData.lang.fn( "guiInfo", "randomMed", "detail" ),
				navigate : "right",
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "65px"
					});
				} 
				
			},{
				element :  fn.qs( "button-random-eas" ) ,
				text :  owlData.lang.fn( "guiInfo", "randomEas", "detail" ),
				navigate : "right",
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "65px"
					});
				} 
				
			},{
				element :  fn.qs( "cnt-villant" ),
				elementMirror : function(){
				  return fn.qs( "cnt-villant" ).getElementsByTagName("li")[0].getElementsByTagName("li")[0];
				},
				text :  owlData.lang.fn( "guiInfo", "chooseVillant", "detail" ),
				navigate : "right",
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "290px"
					});
				}
			},{
				element :  fn.qs( "box-profile-detail" ),
				elementMirror : function(){
				  return fn.qs( "m-level" )
				},
				text :  owlData.lang.fn( "guiInfo", "tapSkill", "detail" ),
				navigate : "right",
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-160px"
					});
					fn.css( fn.qs("close-info"), {
						top : "5px"
					});
				} 
				
			},{
				element :  fn.qs( "box-hero" ),
				elementMirror : function(){
				  return fn.qs( "box-hero" ).getElementsByTagName("li")[0];
				},
				text :  owlData.lang.fn( "guiInfo", "chooseHero", "detail" ),
				navigate : "right",
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "290px"
					});
				}
			},{
				element :  fn.qs( "cnt-map" ).getElementsByTagName("li")[0] ,
				text :  owlData.lang.fn( "guiInfo", "chooseMap", "detail" ),
				navigate : "right",
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "70px"
					});
					fn.css( fn.qs("close-info"), {
						top : "260px"
					});
				}
			},{
				element :  fn.qs( "box-profile" ),
				elementMirror : function(){
				  return fn.qs( "box-profile" ).getElementsByTagName("li")[1];
				},
				text :  owlData.lang.fn( "guiInfo", "tapCharacter", "detail" ),
				navigate : "right",
				
				css : function(){
					fn.css( fn.qs("text-info"), {
						top : "-100px"
					});
					fn.css( fn.qs("close-info"), {
						top : "65px"
					});
				}
			}];
			this.cntState = function( elClone, init ){
				
				var self = this
				
				if( init === "open" ){
					fn.removeClass( self.container, "hidden" );
					setTimeout( function(){
						
						fn.addClass( self.container, "show-menu" );
					},100)
				}
				
			};
			this.freeze = false;
			this.update = function(){
				
				var self = this, obj,
				selfInterval =  setInterval( function(){
					  
					if( localStorage.getItem( 'tutorial' ) === "true" ){
						clearInterval( selfInterval );
						window.scope.virtualControl = true;
					}
					 
					 
					if( self.breakTime ){  self.breakTime = false; return ; }
					
					
					if( !self.freeze ){
						
						for( var ii = 0  ; ii < self.cloneElement.length ; ii++ ){
						
							if(  !self.cloneElement[ii].element ){
								 self.cloneElement.splice( ii, 1 );
								 break;
							}
							 
							obj =  self.cloneElement[ii];
							
							var el = obj.element,
							boundEl = el.getBoundingClientRect();
							 
									
							if( boundEl.x ){ // detect zero, zero means element still hidden;
								
								// scope.blockRender
								 
								var elClone =  el.cloneNode(true),
								navDiv = document.createElement("div"),
								margin = 20,
								height = 40 / 2;
								
								if( obj.elementMirror ){
									elClone = obj.elementMirror();
									boundEl = elClone.getBoundingClientRect();
									
									elClone = elClone.cloneNode(true);
								}
								//navigation
								switch( obj.navigate ){
									case "right":
										navDiv.className = "nav-info-right";
										fn.css( navDiv, {
											"position" : "fixed",
											"top" : boundEl.y + boundEl.height / 2 - height +"px",
											"left" : boundEl.x + boundEl.width  + margin +"px"
										})
										break;
									case "left":
										navDiv.className = "nav-info-left";
										fn.css( navDiv, {
											"position" : "fixed",
											"top" : boundEl.y + boundEl.height / 2 - height +"px",
											"left" : boundEl.x - boundEl.width / 2 - margin * 2 +"px"
										})
										break;
								}
								  
								//target clone
								
								if( elClone.nodeName = "LI" ){
									fn.css( elClone, {
										"list-style" : "none"
									})
								}
								
					
								fn.css( elClone, {
									"position" : "fixed",
									"top" : boundEl.y +"px",
									"left" : boundEl.x +"px",
									"margin" : "0px"
								})
								
								self.containerEl.innerHTML = "";
								self.containerEl.appendChild( elClone )
								self.containerEl.appendChild( navDiv )
								
								
								if( obj.css ){
									obj.css();
								}
								
								if( obj.callbackStart ){
									obj.callbackStart();
								}
								
								fn.text( fn.qs("text-info"), obj.text );
								
								self.cntState( el.cloneNode(true), "open" );
								self.freeze = true;
								self.deleteIndex = ii;
								
								break;
							}
							 
						}
					
					}
					
				},1000 )
				
				fn.attachListener( fn.qs("close-info"), "click", function(el){
					
					fn.removeClass( fn.qs("help-info"), "show-menu" );
					
					setTimeout( function(){
						fn.addClass( fn.qs("help-info"), "hidden" );
					},100);
					
					self.freeze = false;
					self.breakTime = true;
					
					var targetSplice = self.cloneElement[ self.deleteIndex ];
					if( targetSplice && targetSplice.callbackEnd ){
						targetSplice.callbackEnd();
					}
					
					self.cloneElement.splice( self.deleteIndex, 1 )
					
				})
				
				fn.attachListener( fn.qs("close-info-success"), "click", function(el){
					
					fn.removeClass( fn.qs("help-info-success"), "show-menu" );
					
					setTimeout( function(){
					
						fn.addClass( fn.qs("help-info-success"), "hidden" );
						clearInterval( selfInterval );
						self.cloneElement.length = 0;
						
						localStorage.setItem( 'tutorial', true );
						
						window.scope.virtualControl = true; //prevent bug 
					
					},100); 
					
				})
				 
			}
			
		}
		
		this.audioBackground = new function(){
			this.container = {};
			this.currentInit = "";
			this.initCritical = "";
			this.createAudio = function( init, src, needLoop  ){
				
				var self = this,
				fnAudio = function(){
					
					var globalAnimation = scope.globalAnimation["value"],
					audioAsset = globalAnimation.globalAudio.get( src+".ogg" ),
					audio;
					
					if( audioAsset ){
						audio = audioAsset;
					}else{
						audio = new Audio()
						audio.src = scope.path + "audio/" +  src +".ogg"
					}
					audio.play();
					audio.volume = self.volumeInit ? 1 : 0;
					
					scope.attachListener( audio, "ended", function(el){ 	
						audio.currentTime = 0; 
						
						if( init === "critical" ){
							
							var characterControl = globalAnimation.characterControl;
							
							if( !( characterControl.characterParameters.health < characterControl.characterParameters.maxHealth / 2 ) ){
								 
								self.fn( self.initCritical );
								self.volumeInit && self.setVolume("on");
								
							}else{
								
								this.play()
								
							}
							
						}
						
					}) 
					
					needLoop && ( audio.loop = true );
					
					self.container[ init ] = {
						audio : audio,
						init : init,
						volume : true
						
					};
					
					
				},
				fadeOut = function(){
					
					for(var ii in self.container ){
						if( ii !== init ){
							self.container[ ii ].volume = false;
							self.container[ ii ].audio.pause();
							
						}
						
					}
					
					if( self.container[ init ] ){
							
						var audio = self.container[ init ].audio;
						self.container[ init ].volume = true;
						audio.play();	
						
						
						
					}else{
						
						fnAudio();
						
					}
					
					
				};
				 
				fadeOut();
				 
			}
			this.bgNormal = [ "bg-2","bg-3"];
			this.bgStart = ["bg-start","bg-start-2"];
			this.bgEnd = ["bg-end"];
			this.bgEpic = ["bg-epic"];
			this.bgCritical = ["bg-critical"];
			this.randomAudio = function( arr ){
				
				var rand = scope.random( 10, 5 ),
				val = 0;
				while( rand-- ){ val = scope.random( arr.length - 1, 0 ); }
				return arr[ val ]
			}
			
			this.volumeInit = true;
			
			this.setVolumeForAds = function( init ){
				
				if( this.volumeInit ){
					if( init === "off" ){
						for(var ii in this.container ){
							this.container[ii].audio.volume = 0;
						}
					}else{
						for(var ii in this.container ){
							if( this.container[ii].volume ){
								this.container[ii].audio.volume = 1;
							}
						}
					}
				}
				
				
			}
			
			this.setVolume = function( init ){
				if( init === "off" ){
					for(var ii in this.container ){
						this.container[ii].audio.volume = 0;
					}
					
					this.volumeInit = false;
					
				}else{
					for(var ii in this.container ){
						if( this.container[ii].volume ){
							this.container[ii].audio.volume = 1;
						}
					}
					this.volumeInit = true;
				}
				
				//console.log( this.container )
				
			}
			this.fn = function( init ){
				
				if( this.currentInit !== init ){
					
					this.currentInit = init;
						
					if( /epic|normal/i.test( this.currentInit) ){ // resume when critical end
						
						this.initCritical = init;
						
					}
					
					
					switch( init ){
						case "start" :
							this.createAudio( init, this.randomAudio( this.bgStart ), true ); break;
						case "normal" :
							this.createAudio( init, this.randomAudio( this.bgNormal ), true ); break;
						case "epic" :
							this.createAudio( init, this.randomAudio( this.bgEpic ), true ); break;	
						case "critical" :
							this.createAudio( init, this.randomAudio( this.bgCritical ), false ); break;
						case "end" :
							this.createAudio( init, this.randomAudio( this.bgEnd ), false ); break;	
					}
				
					 
					
				}
			}
			
		}
		
		this.screenTransitionOnload = function( callback ){
			var dataManualImg = owlData.assets.imgOnload,
			fn = new _owlBird.utils,
			count = {
				current : 0,
				tot : 0 
			},
			loadingAssets = fn.qs('loading-assets'),
			guiSpan = fn.slice( loadingAssets.getElementsByTagName('span') ) ,
			loading = function ( init, tot, current, span )
			{
				this.renderVal = function( init, span, progressVal )
				{
					this.loop = function( span, progressVal ){
						for( var ii = 0, jj = span ; ii < jj.length; ii++ ){
							if( jj[ii].className === 'progress-val' ){
								fn.text( jj[ii], progressVal+'%' )
							}else if( jj[ii].className === 'progress-in' ){
								jj[ii].style.width = progressVal+'%';
							}
						}
					}
					if( init === 'open' ){
						this.loop( span, progressVal )
					}else{
						this.loop( span, 0 )
					}
				}
				
				if( init === 'open') {
					loadingAssets.style.display = 'block';
					this.renderVal( init, span, ( Math.floor( ( current / tot ) * 100 ) ) ) ;
				}
				
			}
			temp = [];
			

			//data dataManualPng
			for(var ii = 0, jj = dataManualImg ; ii < jj.length ; ii++ )
			{
				var src = "assets/2d/" + jj[ii],
				img = new Image();
				img.src = src;
				temp.push({
					src : src,
					img : img
				});
				
				count.tot ++;
				
				img.addEventListener('load', function() {
					count.current ++;
				});
				
				
			
			}
			
			var intervalImg = setInterval(function(){
				
				
				loading( 
						'open', 
						count.tot, 
						count.current, 
						guiSpan );
				 
				if( count.tot === count.current ){
					
					callback( temp );
					
					clearInterval( intervalImg );
					
				}
				
			},100)
				
		}
		
		this.screenTransition = function( init, activeMap, callback ){
			
			if( init === 'download' ){
				var data = scope.staticAllMap['value'][ activeMap ],
				dataBg = scope.staticGeometry.storage.get( activeMap ),
				dataMap = scope.staticGeometry.storageMap.get( activeMap ),
				dataManualAudio = owlData.assets.audio,
				dataManualImg = owlData.assets.img,
				createDummyRender = function(){ return Object.create( { render : {} } ) },
				src,
				loading = function ( init, tot, current, span )
				{
					this.renderVal = function( init, span, progressVal )
					{
						this.loop = function( span, progressVal ){
							for( var ii = 0, jj = span ; ii < jj.length; ii++ ){
								if( jj[ii].className === 'progress-val' ){
									scope.text( jj[ii], progressVal+'%' )
								}else if( jj[ii].className === 'progress-in' ){
									jj[ii].style.width = progressVal+'%';
								}
							}
						}
						if( init === 'open' ){
							this.loop( span, progressVal )
						}else{
							this.loop( span, 0 )
						}
					}
					
					if( init === 'open') {
						scope.loading.style.display = 'block';
						this.renderVal( init, span, ( Math.floor( ( current / tot ) * 100 ) ) ) ;
					}else if( init === 'close') {
						scope.loading.style.display = 'none';
						this.renderVal( init, span )
					}
					
				}
				dataNpcPair = function(){
					var npcPair = {
						len : 0,
						current : 0
					}
					//this npc textures are generated from monsterDungeon.requireInstall
					for( var ii in data ){
						
						if( ii === "content" ){
						
							for(var jj in data[ii] ){
								 
								if(/monster/i.test( jj ) ){
									
									var monsterTextures = data[ii][jj].render.textures;
									for( var kk in monsterTextures )
									{
										var dirObg = monsterTextures[kk]
										for( var ll in dirObg )
										{//left | right
											behaveRig = dirObg[ll];
											for( var mm in behaveRig )
											{//behaveRig 
												npcPair.len++;
												if( behaveRig[mm].complete ){
													npcPair.current++;
												}
											}
											
											
										}
									}
									
								}
							}
								
							
						}
					}
					
					return npcPair;
				}
				
				//data content
				for( var ii in data ){
 
					if( ii === 'textures' ){
						
						for(var jj in data[ii] ) if( jj in data[ii] ){
							src = data[ii][jj].src;
 
							if( src ){	
								
								src = src.split("//").join("/");
								img = new Image();
								img.src = src;
								scope.globalImage.set( src, img ); 
								
							}
							
						}
					}
				}
				 
				//data background
				for(var ii = 0, jj = dataBg ; ii < jj.length ; ii++ )
				{
					src = jj[ii].render.src.split("//").join("/");
					img = new Image();
					img.src = src;
					scope.globalImage.set( src, img ); 
						
					
				}
				
				//data map
				for(var ii = 0, jj = dataMap ; ii < jj.length ; ii++ )
				{
					src = jj[ii].render.src.split("//").join("/");
					img = new Image();
					img.src = src;
					scope.globalImage.set( src, img ); 
				}
				 
				//data dataManualPng
				for(var ii = 0, jj = dataManualImg ; ii < jj.length ; ii++ )
				{
					src = scope.path + jj[ii].split("//").join("/");
					img = new Image();
					img.src = src;
					scope.globalImage.set( src, img ); 
				}
				
				//data audio
				var lenAudio = dataManualAudio.length,
				currentAudio = 0;
				for(var ii = 0, jj = dataManualAudio ; ii < jj.length ; ii++ )
				{
					src = scope.path +"audio/"+ jj[ii];
					 
					var audio = new Audio();
					audio.src = src
					scope.transport({
						url: src,
						type:'GET',
						requestHeader:{"Content-Type":"audio/ogg"},
						callback:function( name, audio ){
							/*
							var blob = new Blob( [audio], {type: 'audio/ogg'});
							objectUrl = URL.createObjectURL(blob);
							
							var nameArr = this.responseURL.split("/"),
							audio = new Audio(),
							name = nameArr[ nameArr.length - 1];
							audio.src = objectUrl;
							*/
							scope.globalAudio.set( name,  audio )
							currentAudio++;
						
						}.bind({}, jj[ii], audio )
					})
				}
				 
				 
				var loadingSecene = scope.qs("loading-assets"),
				guiSpan = scope.slice( scope.loading.getElementsByTagName('span') );
				
				scope.removeClass( loadingSecene, "hidden" );
				 
				var intervalImg = setInterval(function(){
					  
					var imgNpcPair = dataNpcPair(),
					imgStorage = scope.globalImage.storage,
					len =  imgStorage.length,
					current = 0;
					for( var ii = 0, jj = len; ii < jj ; ii++ ){
						if( imgStorage[ii].status.complete ){
							current++;
						}
					}
					 
					var totalAssets = len + lenAudio + imgNpcPair.len + scope.svgCount.tot,
					currentAssets = current + currentAudio + imgNpcPair.current  + scope.svgCount.current;
					
					loading( 
						'open', 
						totalAssets, 
						currentAssets, 
						guiSpan );
					
					 
					//console.log( totalAssets +'==='+ currentAssets )
					
					if( totalAssets === currentAssets ){
						
						callback();
						
						scope.globalObjectGUI["value"].audioBackground.fn("normal");
						
						clearInterval( intervalImg );
						
					}
					
				},500)
			}
		}
		
		this.toggleButton = function( eventRedudant ){
			
			setTimeout(function(){
				
				var toogle =  scope.slice( scope.qsAll('switch-control') );
				
				var hpEl = scope.qs('bar-hp'),
				mpEl = scope.qs('bar-mp'),
				charparams = scope.characterParameters['value'];
				for( var ii = 0, jj = toogle.length; ii < jj ; ii ++){
					var el =  toogle[ii];
					var drag = scope.getFirstChild( el ),
					dragChild = scope.getFirstChild( drag ),
					info = scope.sibling( drag, 'next' ),
					guiToogle = function( init ){
						
						if(init){
							dragChild.style.left = 35+'px';
							scope.text( info, 'ON')
							info.style.marginRight = '-40px';
						}else{
							dragChild.style.left = '0px';
							scope.text( info, 'OFF');
							info.style.marginRight = '-50px';
						}
						
					};
					
					var actionLabel = el.getAttribute( "label" );
					
					
					if( charparams.setting.effect  ){
						dragChild.style.left = 35+'px';
						scope.text( info, 'ON')
						info.style.marginRight = '-40px';
						
					}else{
						dragChild.style.left = '0px';
						scope.text( info, 'OFF');
						scope.objTranslate['value'].effect = false;
						info.style.marginRight = '-50px';
					}
					
					
					switch( actionLabel ){
						case "performance" :
								if( charparams.setting.effect  ){
									scope.objTranslate['value'].effect = true;
									guiToogle( true );
								}else{
									scope.objTranslate['value'].effect = false;
									guiToogle( false );
								}
							break;
						case "volume-bg" :
							guiToogle( scope.globalObjectGUI["value"].audioBackground.volumeInit );
							break;
						case "volume-action" :
							guiToogle( scope.objTranslate['value'].volume );
							break;
						case "tutorial-game" :
							guiToogle( localStorage.getItem( 'tutorial' ) === "false" );
							break;
					}
					
				}
			
				if( !eventRedudant ){
					
					for( var ii = 0, jj = toogle.length; ii < jj ; ii ++){
						scope.attachListener( toogle[ii], "click", function(el){ 
								
								var actionLabel = el.getAttribute( "label" ),
								drag = scope.getFirstChild( el ),
								dragChild = scope.getFirstChild( drag ),
								boundDrag = drag.getBoundingClientRect(),
								info = scope.sibling( drag, 'next' ),
								pointX = Math.abs( boundDrag.left - scope.mousePosition['value'].pos.mousedown.x ),
								init = "right";
								 
								if( pointX > ( boundDrag.width / 2 ) ){
									dragChild.style.left = boundDrag.width / 2  -5+'px';
									scope.text( info, 'ON')
									info.style.marginRight = '-40px';
									init =  "right";
									
								}else{
									dragChild.style.left = '0px';
									scope.text( info, 'OFF');
									info.style.marginRight = '-50px';
									init =  "left";
								}
								 
								switch( actionLabel ){
									case "performance" :
										if( init === "right" ){
										
											scope.objTranslate['value'].effect = true;
											charparams.setting.effect = true;
										}else{
											
											scope.objTranslate['value'].effect = false;
											charparams.setting.effect = false;
										}
										break;
									case "volume-bg" :
										init === "right" ?
											scope.globalObjectGUI["value"].audioBackground.setVolume("on") :
											scope.globalObjectGUI["value"].audioBackground.setVolume("off");
										break;
									case "volume-action" :
										scope.objTranslate['value'].volume = ( init === "right" );
										break;
									case "tutorial-game" :
										
										localStorage.setItem( 'tutorial', !( init === "right" ) ); 
										
										break;	
								}
								
								
								
							
						}.bind( this, toogle[ii] ))
					}
				}
			},1000)
		}

		this.dragBar = function(){
			var dragBar =  scope.slice( scope.qsAll('bar-control') ),
			dragObject = {
				parent :'',
				drag : '',
				dragObject : '',
				dragBar : '',
				start : false,
				init : '',
				end : 0
			},
			dragUpdate = function (){
				var xMouse = scope.mousePosition['value'].pos.mousemove.x;
				
				if( xMouse > dragObject.parent.left && xMouse < dragObject.parent.right ){
					var maxLength = Math.round( dragObject.parent.right ) -  Math.round( dragObject.parent.left )
					currentLength = Math.round( xMouse ) - Math.round( dragObject.parent.left );
					length = Math.round( 100 * currentLength / maxLength ) + 1;
					
					
					
					charparams = scope.characterParameters['value'];
					dragObject.dragBar.style.width = length < 0 ? 0 : length +'%';
					dragObject.dragObject.style.left = xMouse - dragObject.parent.left+'px';
					  
					if( dragObject.init === 'hp' ){
						var maxHealth = charparams.maxHealth;
						charparams.setting.healthPercentage = length;
						charparams.maxHealthCure = Math.round( maxHealth * length / 100 );
					}else{
						var maxMp = charparams.maxMp;
						charparams.setting.mpPercentage = length;
						charparams.maxMpCure = Math.round( maxMp * length / 100 );
					}
				}
			};
			
			var isMobile = scope.isMobile(),
			control = isMobile ? scope.qs('tab-performance-mb') : scope.controlContainer; 

			var hpEl = scope.qs('bar-hp'),
			mpEl = scope.qs('bar-mp'),
			charparams = scope.characterParameters['value'];
			
			
			if( !charparams.setting ){
				charparams.setting = {
					mpPercentage : 100,
					healthPercentage : 100,
					effect : true
				}
			}
			
			var hpPecent = charparams.setting.healthPercentage,
			mpPecent = charparams.setting.mpPercentage;
			
			hpEl.style.width = charparams.setting.healthPercentage+'%';
			mpEl.style.width = charparams.setting.mpPercentage+'%';
			charparams.maxHealthCure = Math.round( charparams.maxHealth * hpPecent / 100 );
			charparams.maxMpCure = Math.round( charparams.maxMp * mpPecent / 100 );
			
			dragHpEl = scope.getFirstChild( hpEl );
			dragHpEl.style.left = hpEl.getBoundingClientRect().width +"px";
			
			dragMpEll = scope.getFirstChild( mpEl );
			dragMpEll.style.left = mpEl.getBoundingClientRect().width +"px";
			
			
			//scope.qs('bar-hp').getBoundingClientRect().right
			
			for( var ii = 0, jj = dragBar.length; ii < jj ; ii ++){
				var el =  dragBar[ii]
				scope.attachListener( dragBar[ii], scope.CursorStartEvent, function(el){ 
					if( !dragObject.start ){
						var items = el.querySelectorAll("div");
						dragObject.parent =  el.getBoundingClientRect()
						dragObject.dragObject =  items[ items.length - 1 ];
						dragObject.dragBar =  items[ 0 ];
						dragObject.init = /bar-hp/i.test( dragObject.dragBar.className ) ? 'hp' : 'mp';
						dragObject.start = true;
						dragUpdate()
					}
				
				}.bind(scope, dragBar[ii]))
				
			}
			
			scope.attachListener( control, scope.CursorMoveEvent, function(el){ 
				if( dragObject.start ){
					dragUpdate()
				}	
			})
			scope.attachListener( control, scope.CursorEndEvent, function(el){ 
				dragObject.start = false;
			})
		}
		
		this.scrollSlide = function(){
			var boxQuest = scope.slice( scope.qsAll('box-quest') ),
			state = { oldVal : 0, newVal : 0, moveVal: 0, moveValInPercent :0 , moveScroll : 0, posY : 0 },
			obj = {
				firstLoad : false,
				checkOverflow : function( parent, li, elParent ){
				
					for( var kk = 0, ll = li.length; kk < ll ; kk++ ){
						var liReac = li[kk].getBoundingClientRect();
						
						if( liReac.bottom > parent.bottom ){
							li[kk].style.display = 'none'
						}
						
					}
				},
				attachEvent : function( boxQuest, wrapCnt ){
					scope.that( boxQuest ).use('attachListener' , [ scope.CursorMoveEvent, function( activeEl, wrapCnt, state, event){
						
						if( scope.isScroll['value'] ){		
								
							var WrapLi = wrapCnt.getElementsByTagName('li'),
							parentReac = activeEl.getBoundingClientRect();
							for( var ii = 0, jj = WrapLi.length; ii < jj ; ii++){
								WrapLi[ii].style.display = 'block'
							}
							
							
							var screenHeight = activeEl.offsetHeight,
							imgHeight = wrapCnt.offsetHeight + 25,
							pos = scope.mousePosition['value'].pos.mousemove,
							scroll = scope.sibling( wrapCnt,'next'),
							constant = {
								formulaImgScroll : function(a){ 
									return Math.abs( ( a / 2 ) / 100 * imgHeight) * 3 
								},
								formulaCntScroll : function( a ){
									return ( ( a / 2 ) / 100 ) * screenHeight * 3 ;
								},
								widthScrollFormula : function(){
									return screenHeight - (function(){
										var ii = 0, jj = 0, moveScroll;
										if(!moveScroll) while(jj < ( imgHeight -  screenHeight )){
											ii++;
											jj = constant.formulaImgScroll( ii );
											moveScroll = constant.formulaCntScroll( ii );
										};
										return moveScroll
									}());
								}
							};
							
							
							
							if( function(){
								return   ( scope.isMobile() ? true : scope.detectLeftButton(event) );
							}() ){
								
								state.newVal = pos.y;
								state.newVal > state.oldVal ?
									state.moveVal >= 0 && state.moveVal <= imgHeight 
									&&  (state.moveValInPercent < (imgHeight -  screenHeight)) 
									&& Math.abs(state.moveVal++):
									state.moveVal >= 0 && state.moveVal <= imgHeight && Math.abs(state.moveVal--);
							
								if(state.moveVal < 0 || state.moveValInPercent < 0) state.moveVal = 0;
								state.oldVal = pos.y;
								
								var widthScroll = constant.widthScrollFormula();
							
								state.moveValInPercent = constant.formulaImgScroll( state.moveVal );
								var moveScroll = constant.formulaCntScroll( state.moveVal );		
								
								if( !state.posY ){
									state.posY = pos.y;
								}
								
								var isMove = Math.abs( state.posY - pos.y );
								
								if( isMove ){
								
									scope.css( wrapCnt, { 'transform': '0px,'+ -state.moveValInPercent  +'px,0px'})
									scope.css( scroll , { 
										'transform': '0px,'+ moveScroll +'px,0px', 
										'height' : widthScroll+'px', 
										'opacity' : '0.5', 
										'transition' : 'opacity 0.5s linear'
									})
									
										
									this.checkOverflow( parentReac, WrapLi, boxQuest );
								
								}
								
							}else if( imgHeight > screenHeight ){
								
								var widthScroll = constant.widthScrollFormula();
								
								scope.css( scroll , { 
									'height' : widthScroll+'px', 
									'opacity' : '0.5', 
									'transition' : 'opacity 0.5s linear'
								})
							}else if( imgHeight < screenHeight ){
								scope.css( scroll , { 
									'transform': '0px,0px,0px'
								})
							}
						
							
						}else{
							//translate3d caused an error while drag and drop
							wrapCnt.setAttribute('style','')
						}
						
					}.bind(this, boxQuest, wrapCnt, state )])

					
					scope.attachListener( boxQuest, scope.CursorEndEvent, function(el){
						scope.sibling( el,'next').style.opacity = 0;
						state.posY = 0;
					}.bind(this, wrapCnt))
					
					scope.attachListener( boxQuest, scope.CursorLeaveEvent, function(el){
						 scope.sibling( el,'next').style.opacity = 0;
					}.bind(this, wrapCnt))
					
				},
				fn : function(){
					for( var ii = 0, jj = boxQuest.length; ii < jj ; ii ++){
						var wrapCnt = scope.getFirstChild( boxQuest[ii] ),
						parentReac = boxQuest[ii].getBoundingClientRect(),
						WrapLi =  wrapCnt.getElementsByTagName('li') ;
						this.checkOverflow( parentReac, WrapLi )
						
						if( !this.firstLoad ){
							this.attachEvent( boxQuest[ii], wrapCnt );
						}
					}
					
					this.firstLoad = true;
				}
			};
			
			obj.fn();
			
			
			this.scrollSlideParams = obj;
		}
		
		this.textDialog = function( dialogCnt ){
			
			clearTimeout( scope.activeDialog['value'].timeout );
			clearInterval( scope.activeDialog['value'].interval );
			scope.activeDialog['value'].state = false;
			
			var el = scope.qs('body-dialog'),
			leftBtn =  scope.qs('left-dialog'),
			rightBtn =  scope.qs('right-dialog'),
			text = ('innerText' in el ) ? 'innerText' : 'textContent',
			countLoop = 0,
			textChange = function( selectedDialog ){
				if( selectedDialog.avatarPosition ){
					selectedDialog.avatarPosition 
					scope.qs('avatar-position').className = 'avatar-position '+
						selectedDialog.avatarPosition+' '+
						selectedDialog.avatarBackground;
						
					scope.text( scope.qs('title-dialog'), selectedDialog.avatarName );
					
					scope.text( scope.qs('count-dialog'), countLoop + 1 +'  / '+scope.activeDialog['value'].dialogCnt.length );
				}
			},
			loopDialog = function(){
				if( !scope.activeDialog['value'].state ){
					scope.activeDialog['value'].timeout = setTimeout(function(){ 
						var diagCnt = scope.activeDialog['value'].dialogCnt,
						selectedDialog = diagCnt[ countLoop ];
						console.log( selectedDialog )
						textChange( selectedDialog )
						
						scope.activeDialog['value'].state = true;	
						
						var textArr = selectedDialog.text.split(','),
						obj = {
							loopText : textArr[0].split(' '),
							loopChildText : ''
						};
						
						el[ text ] = '';
						scope.activeDialog['value'].interval =  setInterval( function(){ 
							if( obj.loopText.length || obj.loopChildText.length ){ 
								if( obj.loopChildText !== '' && obj.loopChildText.length ){
									scope.text( el, '"'+el[ text ].split('"').join('') + obj.loopChildText.splice( 0, 1 )+'"' )
								}else{
									obj.loopChildText = obj.loopText[0].split('');
									scope.text( el, el[ text ] +' '+ obj.loopChildText.splice( 0, 1 ));
									obj.loopText.splice( 0, 1 )
								}
							
								
							}else if( textArr.length ){ 
								textArr.splice( 0, 1 );
								if( textArr.length ){
									obj.loopText = textArr[ 0 ].split(' ') ;
									obj.loopText.unshift(', ');
									scope.text( scope.qs('count-dialog'), countLoop + 1 +'  / '+diagCnt.length );
								}
							}else{
								clearInterval ( scope.activeDialog['value'].interval );
								scope.activeDialog['value'].state = false;
								if( ( diagCnt.length - 1 ) > countLoop ){	
									countLoop++;
									loopDialog();
								}
							}
						},50)
					},1000)
				}
			}
			
			scope.activeDialog['value'].dialogCnt = dialogCnt;
			
			loopDialog();
			
			//perform click
			scope.attachListener( leftBtn, 'click', function( e ){ 
				if( countLoop - 1 >= 0 ){
					countLoop --;
					var selectedDialog =  scope.activeDialog['value'].dialogCnt[ countLoop ];
					textChange( selectedDialog );
					scope.text( el, selectedDialog.text )
					clearTimeout( scope.activeDialog['value'].timeout );
					clearInterval( scope.activeDialog['value'].interval );
				}
			})
			scope.attachListener( rightBtn, 'click', function( e ){ 
				if( countLoop + 1 <= scope.activeDialog['value'].dialogCnt.length - 1 ){
					countLoop ++;
					var selectedDialog = scope.activeDialog['value'].dialogCnt[ countLoop ];
					textChange( selectedDialog )
					scope.text( el, selectedDialog.text )
					clearTimeout( scope.activeDialog['value'].timeout );
					clearInterval( scope.activeDialog['value'].interval );
				}
			})
			
		}
		
	}

	_owlBird.AIs = function( _obj )
	{
		var scope = this;
		var obj = {
			intersectsPoly : function(nvert, vertx, verty, testx, testy){
				//http://stackoverflow.com/questions/2212604/javascript-check-mouse-clicked-inside-the-circle-or-polygon/2212851#2212851
				//(c) 1970-2003, Wm. Randolph Franklin
				var i, j, c = false;
				for( i = 0, j = nvert-1; i < nvert; j = i++ ) {
					if( ( ( verty[i] > testy ) != ( verty[j] > testy ) ) &&
						( testx < ( vertx[j] - vertx[i] ) * ( testy - verty[i] ) / ( verty[j] - verty[i] ) + vertx[i] ) ) {
							c = !c;
					}
				}
				return c;
			},
			activeMapContent : '',
			shortestObject : function( orderGroup, object )
			{
				var objPos = object.position ? object.position : object,
				tempDistance = [], tempObject = []; 
				for(var ii = 0, jj = orderGroup; ii < jj.length ; ii ++ ){
					var pathPos = jj[ii].position ? jj[ii].position : jj[ii],
					distance = Math.round( scope.distanceAndAngleBetweenTwoPoints( objPos.x, objPos.y, pathPos.x, pathPos.y ).distance ) ;
					tempObject.push({ 
						path : jj[ii],
						distance : distance
					})
					tempDistance.push( distance )
				}
				
				//sorting
				tempDistance = tempDistance.sort( function( a, b ){return a - b } );
				
				//reorder sorting object
				self : for(var kk in tempDistance){
					for( var ll in tempObject ){
						if( typeof tempDistance[kk] === 'Object' ) continue self;
						if( tempDistance[kk] === tempObject[ll].distance ){
							tempDistance[kk] = tempObject[ll].path
						}
					}
				}
				
				return tempDistance;
			}
		};
		
		this.AI = {};
		this.AI.sortestEnemy = function( groupEnemy, object, options ){
			
			if( options ){
				if( options.orderByDir ){
					var sort = obj.shortestObject(  groupEnemy, {
						position :{
							x : 0,
							y : 0
						}
					} );
					return scope.random( 1, 0 ) && sort || sort.reverse() ;
				}
			}else{
				return obj.shortestObject(  groupEnemy, object );
			}
		}
 
		this.AI.attackBehaviour = function( options ){
			
			if( options !== "melee" ){
				this.rangeMovement = function( options ){
					
					var self = this,
					object = options.object,
					targetDummy = options.targetDummy,
					objPos = object.position,
					targetPos = targetDummy.position,
					distanceY = options.distanceY,
					
					toleranceY = options.distY  >= distanceY.max && options.distY < distanceY.min,
					
					toleranceX = options.distX < options.distanceX && -options.distanceX < options.distX,
					
					distance = scope.distanceAndAngleBetweenTwoPoints(
						objPos.x,
						objPos.y,
						targetPos.x,
						targetPos.y
					).distance,
					changeFrame = function(){
								
						var prior =  self.dirSwitch.prior,
						priorLen = self.dirSwitch.prior.length,
						priorIndex = scope.random( priorLen - 1, 0 ),
						priorRandom = prior[ priorIndex ];
						
						self.dirSwitch.selectedFrame = priorRandom ? 
							priorRandom.selectedFrame : self.performAttackRandomBehaviour( self.attackFrame );
						
						
					},
					dirBlockState = this.dirSwitch.dirBlock.state,
					tolerance = toleranceY && toleranceX,
					allowDistance = Math.round( distance ) < 10,
					isAttacking = tolerance && function(){
						if( !targetDummy.isSpotted && allowDistance){
							
							//prevent bug when delay got zero caused walk frame is seleceted dispite an attack frame
							//exec this for one loop only
							self.dirSwitch.reset();
							self.dirSwitch.attackDelayPerFrame = self.dirSwitch.attackDelayPerFrameReplace;
							
							targetDummy.isSpotted = true;
							return true;
						}else{
							return targetDummy.isSpotted;
						}
					}();
					
					// check attack tolerance when perfoming dirBlock
					if( tolerance && dirBlockState ){
						self.dirSwitch.dirBlock.reset();
						self.dirSwitch.selectedFrame = "";
						targetDummy.init = true;
						this.dirSwitch.mainTurn = true;
						isAttacking =  true;
						
					}
					
					//delay attack when target is moving
					if( options.dirSwitch.attackDelay > 0 ){
						
						options.dirSwitch.attackDelay--;
						targetDummy.init = true;
					}
					
					
					if( isAttacking  )
					{
				
						if( allowDistance ){
							targetDummy.init = true;
							this.dirSwitch.mainTurn = true;
						}
						
						if( self.dirSwitch.selectedFrame === "" ){
						
							changeFrame()
						}
						
						return {
							init : true,
							x : 0,
							y : 0
						}
						
					}
					
					//bug ranger execute once espcially for selected skill
					if( this.dirSwitch.latestFrame ){ // executed once
						changeFrame();
						delete this.dirSwitch.latestFrame
					}
					
					//delay attack when target is moving
					if( options.dirSwitch.attackDelay <= 0 || this.dirSwitch.turn ){
						
						if( dirBlockState ){
							
							return this.dirSwitch.dirBlock.fn();
							
						}else{
							
					
							if( targetDummy.init || this.dirSwitch.turn ){
								//update targetDummy
								
								if( tolerance ){
									
									x = objPos.x;
									y = objPos.y;
									
								}else{
									
									var randomX = scope.random(  options.distanceX - 50, options.distanceX - 250 ),
									randomY = scope.random( 0, -50 );
									
									
									var x = ( options.distX > 0 && !this.dirSwitch.turn ) ? //flip is collide
										( options.target.position.x - randomX ) :
										( options.target.position.x + randomX),
									y = options.target.position.y + randomY
									
								}
								var tempTarget = this.dirSwitch.tempTarget;
								tempTarget.position = {
									x : x,
									y : y 
								};
								targetDummy.isSpotted = false;
								tempTarget.init = false;
								
								if( this.dirSwitch.turn ){
									this.dirSwitch.turn = false
								}
								
							}else if( !targetDummy.init ){
								
								//translate target Dummy only for archer and mage if needed
								
								this.objGlobalTranslate.update( targetPos )
								
								if( allowDistance  ){
									this.dirSwitch.tempTarget.init = true; 
								}
							}
								
							var vec = scope.moveVector2dWithVelocity( object, targetDummy, options.speed ) ;
					
							vec.y = options.forceGravity ? 0 :  vec.y;
							
							
							if( this.dirSwitch.forceAttackFrame ){
								
								vec.x = 0;
								vec.y = 0;
								
							}else{
							
							
								scope.Body.setPosition( object, 
									{ x : objPos.x + vec.x,
									 y : objPos.y + vec.y,									
								})
							}
							
							this.dirSwitch.mainTurn = false;
							
							return {
								init : false,
								x : vec.x,
								y : vec.y 
							}
						
						}
						
					}else{
						return {
							init : false,
							x : 0,
							y :0,
							distance : distance
						}
					}
					
					
				}
			}

			if( options !== "range" ){
				this.meleeMovement = function( options ){
					var object = options.object,
					target = options.target,
					objPos = object.position,
					posTargetDummy = options.dirSwitch.targetDummyForMelee;  // render object first before rendering target
					
					posTargetDummy.position.x = target.position.x;
					posTargetDummy.position.y = target.position.y;
					  
					var targetPos = posTargetDummy.position,
					rangeXY = scope.distanceAndAngleBetweenTwoPoints( objPos.x, objPos.y, targetPos.x, targetPos.y );
									
					//toleranceY = options.distanceY  > distY && -options.distanceY  < distY;
					
					//distY = targetPos.y - objPos.y,
					
					
					//delay attack when target is moving
					if( options.dirSwitch.attackDelay > 0 ){

						options.dirSwitch.attackDelay--;
						
					}
					//toleranceY range distance
					if( this.attackTolerance() ){
						 
						//prior property is used for uniqueSkill
						if( this.dirSwitch.selectedFrame === "" ){
							var prior =  this.dirSwitch.prior,
							priorLen = this.dirSwitch.prior.length,
							priorIndex = scope.random( priorLen - 1, 0 ),
							priorRandom = prior[ priorIndex ];
							
							this.dirSwitch.dirBlock.reset()
							
							this.dirSwitch.selectedFrame = priorRandom ? 
								priorRandom.selectedFrame : this.performAttackRandomBehaviour( this.attackFrame );
							
							if( priorLen ){
								priorRandom.fn();
								prior.splice( priorIndex, 1 );
							}
							
							//prevent bug when delay got zero caused walk frame is seleceted dispite an attack frame
							//exec this for one loop only
							this.dirSwitch.attackDelayPerFrame = this.dirSwitch.attackDelayPerFrameReplace;
							
						}
						
						
						return {
							init : true,
							x : 0,
							y : 0
						}
					}
						
					if( this.dirSwitch.attackDelay <= 0 ){
					
						if( this.dirSwitch.dirBlock.state ){
							 
							return this.dirSwitch.dirBlock.fn()
							
						}else{
								
								
							var vec = scope.moveVector2dWithVelocity( object, posTargetDummy, options.speed );
					
							vec.y = options.forceGravity ? 0 : vec.y;
							
							
							if( this.dirSwitch.forceAttackFrame ){
								
								vec.x = 0;
								vec.y = 0;
								
							}else{ 
							 
								scope.Body.translate( object, 
									{ x : vec.x  ,
									 y : vec.y									
								}) 
							}
							
							
							return {
								init : false,
								x : vec.x,
								y : vec.y 
							}
						
						}
						
					}else{
						return {
							init : false,
							x : 0,
							y :0,
							distance : rangeXY.distance 
						}
					}
				}
			}
			 
			this.performAttackFrame = function( objMovement, selectedSkill ){
				
				
				var dirSwitch = this.dirSwitch;
				dirSwitch.attackState =  false;
				
				if(  objMovement.init ){
					
						
					var isSkillExist = this.attackFrame[ selectedSkill ],
					selectedSkill = isSkillExist ? selectedSkill : "normal", //prevent error 
					object = this.object,
					attackProp = this.attackFrame.fn( this, selectedSkill ),
					repeatTrue = object.render,
					framePos = attackProp.frame[ dirSwitch.frameCount ], 
					tickFrameLength = dirSwitch.tickLengthPerFrame ? dirSwitch.tickFrame > dirSwitch.tickLengthPerFrame[ dirSwitch.frameExtendCount + 1 ] : false;
 
					if( dirSwitch.attackDelayPerFrame > 0 ){
						 
						var status = scope[ object.stateStorage ].get( object.label );
							
						status !== "idle" &&
						scope[ object.stateStorage ].set( object.label, "idle" );
						
						dirSwitch.attackDelayPerFrame--;
						 
					} else if( repeatTrue.repeatAttack || tickFrameLength ){
						
						
						if( this.turn ? this.turn === 'right' : this.monsterDir() === 'right' ){
							this.changeRightFn( true );
						}else{ 
							this.changeLeftFn( true );
						}
						
						repeatTrue.repeatAttack = false;
						dirSwitch.frameExtendCount++; // count extend frame
						
						if( !dirSwitch.tickLengthPerFrame ){
							dirSwitch.tickLengthPerFrame = {};
							dirSwitch.tickLengthPerFrame[ dirSwitch.frameExtendCount ] = dirSwitch.tickFrame + 5 ;
						}else{
							dirSwitch.tickLengthPerFrame[ dirSwitch.frameExtendCount ] = dirSwitch.tickFrame + 5 ;
						}
						
						var frameExtend = attackProp.frameExtend,
						selectedFrameExtend = frameExtend[ dirSwitch.frameExtendCount ],
						isFrameExtend = selectedFrameExtend ? 
							selectedFrameExtend : frameExtend[ 0 ];
					  
						scope[ object.stateStorage ].set( object.label, isFrameExtend );
						
						
						if(  ( !dirSwitch.forceAttackFrame || dirSwitch.resetWhenFrameEnd ) && ( dirSwitch.prior.length || dirSwitch.frameExtendCount >= attackProp.frameExtend.length ) ){
					
							 dirSwitch.reset();
							 dirSwitch.attackDelayPerFrame = dirSwitch.attackDelayPerFrameReplace;
							 dirSwitch.resetWhenFrameEnd = false;
							 this.attackFrame.state = true;
							 dirSwitch.selectedFrame = "";
							 
							 this.attackFrame[ selectedSkill ].frameEnd = true;
							 
							
						}
						
						
						
					}else{
						 
						 
						if( dirSwitch.tickFrame === 0 ){
							
							
							if( this.turn ? this.turn === 'right' : this.monsterDir() === 'right' ){
								this.changeRightFn( true );
								dirSwitch.right = true;
							}else{ 
								this.changeLeftFn( true );
								dirSwitch.left = true;
							}
							
							if( attackProp.audioStart && scope.random(5,1) >= 5  &&  object.visible ){
								scope.playAudio( attackProp.audioStart[ dirSwitch.frameCount ] );
							}
							 
							dirSwitch.attackDelay =  typeof this.initialAttackDelay !== "undefined" ? 
								this.initialAttackDelay : scope.random( 40, 25 ); 
							
							
						}else if( dirSwitch.tickFrame === 1 ){
							scope[ object.stateStorage ].set( object.label, attackProp.frameExtend[0] );
						}else if( dirSwitch.tickFrame === framePos ){
							
					
								
							if(  attackProp.effect && typeof attackProp.effect[  dirSwitch.frameCount ]  ===  "function" ){
								attackProp.effect[  dirSwitch.frameCount ]( this, scope.objTranslate["value"] ); 
								
							}
							
							if( attackProp.audioEnd ){
								
								var selectedVideo = attackProp.audioEnd[ dirSwitch.frameCount ],
								textOrArray = selectedVideo instanceof Array ? selectedVideo.length : selectedVideo;
								
								 object.visible && 
								 textOrArray && // filter 0 or ""
								 scope.playAudio(  selectedVideo  );
							}
							
							dirSwitch.frameCount++;

							if( dirSwitch.frameCount >= attackProp.frame.length ){
								
								dirSwitch.frameCount = 0;
							}
							
							//execute prior if available to prevent bug ( init loading is executed first than perform skill ) in long-range movement
							var prior = dirSwitch.prior;
						
							if( prior.length && object.statParameters.attackType === "long-range" ){
								
										
								for( var ii = 0; ii < prior.length; ii++ ){
									if( prior[ii].selectedFrame === selectedSkill ){
										prior[ii].fn();
										prior.splice( ii, 1 );
									}
								}
							}
								
							
							dirSwitch.attackState =  true;
							
						}
						
						//executed once for certain skills to prevent bug in long-range movement
						
						
						if( this.attackFrame[ selectedSkill ].unique ){
							var frameLen = attackProp.frame.length,
							longestFrame = attackProp.frame[ frameLen - 1 ];
							if( dirSwitch.tickFrame > longestFrame ){
								dirSwitch.latestFrame = selectedSkill
							}
						}
						
						dirSwitch.tickFrame++;
					}
					
				}else if( dirSwitch.firstDirMove <= 2 ){
					
					if( dirSwitch.firstDirMove < 1 ){
						
						
						if( this.turn ? this.turn === 'right' : this.monsterDir() === 'right'  ){
							this.changeRightFn( true )
							dirSwitch.right = true;
						}else{ 
							this.changeLeftFn( true );
							dirSwitch.left = true;
						}
						
					}else if( dirSwitch.firstDirMove === 2 ){	
						var state = objMovement.distance ? "idle" : dirSwitch.approchingState ;
				
						scope[ this.object.stateStorage ].set( this.object.label, state );
						dirSwitch.reset(); 
					}
					
					
					dirSwitch.firstDirMove++;
				}
				
				return dirSwitch.attackState ;
			}
		
			this.performAttackRandomBehaviour = function( attackFrame ){
				
				var count = 0, selectedProp, selectedFrame = {},
				fn = function( obj, callback ){
					for( var ii in obj ){
						if ( !obj[ii].unique
							&& ( Math.random() * 100 ) <= obj[ii].chance 
							&& obj[ii].delay <= 0 ){
							
							count++;
							
							selectedFrame[ii] = obj[ii]
							callback && callback.call( {}, ii );
						}
					}
				};
				fn( attackFrame );
				
				var random = scope.random( count, 1 ); // count length of frames
				
				
				count = 0;
				fn( selectedFrame, function( ii ){
					if( random === count ){
						selectedProp = ii;
					}
				})
				
				return selectedProp
				
							
				
			}
		
		}
		
		// skills and buff are added here	
		this.AI.skillBehaviour = function(  options, rigBody ){
			
			var objSkill = { 
				operators : {
					"+" : function( obj, a, b ){
						obj[a] += b;
					},
					"-" : function( obj, a, b ){
						obj[a] -= b;
					}
					
				},
				cloneOriginParams : function( objParams ){
					if( !objParams.originalParams ){
						objParams.originalParams = {};
						scope.extend( objParams.originalParams, objParams , true)
					};
				},
				gatherObjectFromParty : function( objectParams, target, isBossObjectRequired ){
					
					var tempParams = [], 
					pawns = target.boss ? target.boss.pions : 
					  target.object.pions instanceof Array ?  target.object.pions : [];
					 
					isBossObjectRequired && tempParams.push( target.object );
					
					pawns.forEach(function( object ){
						var isReg = true;
						for( var ii = 0; ii < tempParams.length ; ii++ ){ // prevent duplicate object
							if( tempParams[ii].label === object.label || object.deleted ){
								isReg = false;
								break
							}
						}
						isReg && tempParams.push( object )
					})
					
					
					for( var kk = 0, ll = tempParams; kk < ll.length ; kk ++ ){
						objectParams.push( ll[kk].rigBody.monsterParameters );
					}
					
					tempParams.length = 0;
					
				},
				forceSelectedFrame : function( parent, selectedFrame, selecteStorage ){
					parent.dirSwitch.firstDirMove = 3;
					parent.dirSwitch.forceAttackFrame = true;
					parent.dirSwitch.selectedFrame = selectedFrame;
					selecteStorage && scope[ parent.object.stateStorage ].set( parent.object.label, selecteStorage );
				},
				registerBuff : function( obj, statParameters, buffName ){
					var fn = function( param ){
						
						param && param.object.rigBody.buff.register({
							seletedBuff : statParameters.buffSkill, // attacker
							paramsTarget : param, // target
							paramsAttacker : statParameters, // attacker
						})
					}
					
					if( obj instanceof Array ){
						
						for( var kk = 0, ll = obj; kk < ll.length ; kk ++ ){
							fn( ll[kk] );
						}
						
					}else{
						
						fn( obj );
						
					}
					
					
				},
				singleDmg : function( targetParams, propSkill, attackerRigBody ){
					
					
					if( targetParams && attackerRigBody.isEnemyFn( targetParams.object.label ) ){
					
						var dmgSkill = scope.random( propSkill.damageMax, propSkill.damageMin ),
						attackerParams = attackerRigBody.object.statParameters,
						isLongrange = attackerParams.attackType === "long-range",
						attackerDamageMax = isLongrange ? attackerParams.attackRangeMax : attackerParams.attackMax,
						attackerDamageMin = isLongrange ? attackerParams.attackRangeMin : attackerParams.attackMin,
						damageAttacker = scope.random( attackerDamageMax, attackerDamageMin ),
						objTarget = targetParams.object,
						rigBody = objTarget.rigBody,
						isVisible = objTarget.visible,
						returnDamage = 0,
						damageState = true;
						 
						if( propSkill.damageType === "magic" ){
							var monsterDefMagicRandom = scope.random( targetParams.magicDefenseMax, targetParams.magicDefenseMin ),
							damage = dmgSkill + damageAttacker - monsterDefMagicRandom;
						}else{
							var monsterDefVitRandom = scope.random( targetParams.defenseMax, targetParams.defenseMin ),
							damage = dmgSkill + damageAttacker - monsterDefVitRandom;
						};
						
						
						//critical skill available
						var optionalCritical = {};
						optionalCritical.criticalChanceMax = 0;
						optionalCritical.critical = 0;
						
						if( propSkill.criticalChanceMax )
							optionalCritical.criticalChance = scope.random( propSkill.criticalChanceMax, propSkill.criticalChanceMin );
						
						if( propSkill.criticalMax )
							optionalCritical.critical = scope.random( propSkill.criticalMax, propSkill.criticalMin );
						
						//critical
						var criticalDamage = rigBody.abilityCritical( attackerParams, damage, optionalCritical ),
						criticalState = ( criticalDamage > 0 );
						
						damage += criticalDamage; 
						 
						//targetAbilities
						var targetAbilities = rigBody.attackerAbilities( objTarget.statParameters  );
							
						for(var kk = 0, ll = targetAbilities.length; kk < ll ; kk++ ){
							if( targetAbilities[kk] === 'block' ){
								scope.playAudio('shiled-blocking')
								isVisible && rigBody.hitNumber.push( new scope.hitNumber( 'block' ) );
								damageState = false;
							}else if( targetAbilities[kk] === 'avoid' ){
								isVisible && rigBody.hitNumber.push( new scope.hitNumber( 'miss' ) );
								damageState = false;
								break;
							}
						}
						 
						if( damageState ){
							
							var damage = damage > 0 ? damage : Math.round( scope.random( 100, 50 ) / 2 ),
							tempHealth = targetParams.health - damage;
							
							if( targetParams.health ){
								
								if( isVisible ){
									
									if( criticalState ){
										
										rigBody.hitNumber.push( new scope.hitNumber( damage, "critical" ) );
						
									}else{
										
										if( rigBody.objTranslate.effect || rigBody.isHero ){ 
										
											rigBody.hitNumber.push( new scope.hitNumber( damage ) );
										
										}
									
										 rigBody.healthBar &&
											( rigBody.healthBar.tick = rigBody.healthBar.tickUpdate );
										
									}
									
								} 
								 
								
								if( tempHealth < 0 ){
									targetParams.health = 0;
									returnDamage = 0;
								}else{
									targetParams.health -= damage;
									returnDamage = damage;
								}
							}else{
								returnDamage = 0;
							}
							 
							
							if( !rigBody.characterState ){ // AI only
							
							
								var attacker = attackerParams.object.label;
								if( attackerParams.object.label !== rigBody.boss.label ){
									rigBody.partyRandomHelp.update( rigBody );
									rigBody.hitterNotTarget( attacker );
								};
								
								rigBody.behave !== "attack" && rigBody.forceObjectToAttack( attackerParams.object, true );
							}
							 
							//hero gui
							if( rigBody.updateHpBar || rigBody.cureSelf.gui ) 
								rigBody.updateHpBar ? rigBody.updateHpBar() : rigBody.cureSelf.updateBar( 'hp-inner-line-bar' );
							 
							scope.playAudio(['stab'])
								
							
							if( scope.random( 3, 1 ) === 1 ){
								scope.hitEffect({
									object :  objTarget,
									parent : "",
									alpha : true
								})
							}
							
						
						}
						 
						rigBody.buff.register({
							seletedBuff : attackerParams.buffSkill,
							paramsTarget : rigBody.monsterParameters,
							paramsAttacker : attackerParams 
						})
						
						return returnDamage;
					
					}else{
						
						return 0;
						
					}
					
				},
				areaDmg : function( prop ){
					
					var target = prop.target,  
					parent =  prop.parent,
					width = prop.width,
					height = prop.height,
					propSkill = prop.propSkill;
					
					var areaPool = parent.createAreaDamagePool({
						target : target,
						width : width,
						height : height,
						caster : parent.object.label
					});
					
					if( areaPool.length ){
									
						var monsterRig = areaPool[0].object.rigBody;
						
						for( var kk = 0, ll = areaPool; kk < ll.length ; kk ++ ){ 
						
							this.singleDmg( ll[kk], propSkill, parent )
							
						}
					
					}
					
					return areaPool;
					
				},
				damageBuff : function( propSkill, buff ){
					
					var dmgRandom = scope.random( propSkill.damageMax, propSkill.damageMin ),
					monsterDefRandom = scope.random( buff.paramsTarget.magicDefenseMax, buff.paramsTarget.magicDefenseMax ),
					damage = dmgRandom - monsterDefRandom,
					damage = damage > 0 ? damage : Math.round( scope.random( 100, 50 ) / 2 );
					tempHealth = buff.paramsTarget.health - damage,
					objTarget = buff.paramsTarget.object,
					rigBody = objTarget.rigBody,
					returnDamage = 0;
					
					if( buff.paramsTarget.health ){
						
						//hero gui
						if( rigBody.updateHpBar || rigBody.cureSelf.gui ) 
							rigBody.updateHpBar ? rigBody.updateHpBar() : rigBody.cureSelf.updateBar( 'hp-inner-line-bar' );
						 
						
						objTarget.visible && rigBody.hitNumber.push( new scope.hitNumber( damage ) )
						if( tempHealth < 0 ){
							buff.paramsTarget.health = 0;
							returnDamage = 0;
						}else{
							buff.paramsTarget.health -= damage;
							returnDamage = damage;
						}
					}else{
						returnDamage = 0;
					}
					
					return returnDamage;
					
				},
				buffModifierAbilities : function( params ){
					
					var modifierInitial = params.modifierInitial,
					initial = params.initial,
					buff = params.buff,
					paramsTarget = buff.paramsTarget,
					propSkill = params.propSkill,
					op = params.op;
				
					if( initial === "register" ){
						switch( modifierInitial ){
							case "block" : 
								buff[ modifierInitial ] = scope.random( propSkill.blockMax, propSkill.blockMin );
								break;
							case "avoid" : 
								buff[ modifierInitial ] = scope.random( propSkill.avoidMax, propSkill.avoidMin );
								break;
							case "critical" : 
								buff[ modifierInitial ] = scope.random( propSkill.criticalMax, propSkill.criticalMin );
								break;
							case "criticalChance" : 
								buff[ modifierInitial ] = scope.random( propSkill.criticalChanceMax, propSkill.criticalChanceMin );
								break;		
						}
						
						
					}
					 
					if( !paramsTarget.modifierAbilities ){
						paramsTarget.modifierAbilities = {};
					}
					
					if( !paramsTarget.modifierAbilities[ modifierInitial ] ){
						var newObj = {}
						newObj[ modifierInitial ] = 0;
						
						scope.extend( paramsTarget.modifierAbilities, newObj , true );
						
					}
					
					
					//if( modifierInitial == "avoid" )
					//console.log( paramsTarget.object.label+' '+ paramsTarget.modifierAbilities.avoid +' '+op+' '+buff[ modifierInitial ] );
				
						
					this.operators[ op ]( paramsTarget.modifierAbilities, modifierInitial, buff[ modifierInitial ] )
					
					//if( modifierInitial == "avoid" )
					//console.log( paramsTarget.object.label+' '+ op +' '+buff[ modifierInitial ]+' '+paramsTarget.modifierAbilities.avoid );
				},
				buffSpeedPlusChara : function(  propSkill, buff, init ){
					
					if( init === "register" ){
					
						buff.rigBodyTarget = buff.paramsTarget.object.rigBody; 
													
						if( buff.paramsTarget.mainCharacter ){
							
							if( !buff.rigBodyTarget.originX ){
								buff.rigBodyTarget.originX = buff.rigBodyTarget.moveReplaceX; // replace to its rigid
								buff.rigBodyTarget.originY =  buff.rigBodyTarget.moveReplaceY;
							}	
							buff.reduceMovementX = buff.rigBodyTarget.originX - ( buff.rigBodyTarget.originX * propSkill.reduceMovement );
							buff.reduceMovementY =  buff.rigBodyTarget.originY - ( buff.rigBodyTarget.originY * propSkill.reduceMovement );
							
							//replace movement value
							buff.rigBodyTarget.moveReplaceY = buff.reduceMovementX;
							buff.rigBodyTarget.moveReplaceX = buff.reduceMovementY;
							buff.rigBodyTarget.moveStaticX = buff.reduceMovementX;
							buff.rigBodyTarget.moveStaticY = buff.reduceMovementY;
							buff.rigBodyTarget.moveSpeed = buff.rigBodyTarget.moveSpeed >= 0 ? buff.reduceMovementX : -buff.reduceMovementX;
							
							buff.rigBodyAI = buff.rigBodyTarget.rigBodyAI.rigBody;
							buff.label = buff.paramsTarget.object.label;
							
						}else{
							
							if( !buff.rigBodyTarget.originSpeedAttack ){
								buff.rigBodyTarget.originSpeedAttack = buff.rigBodyTarget.moveSpeedAttack; // replace to its rigid
								buff.rigBodyTarget.originSpeedNormal =  buff.rigBodyTarget.moveSpeedNormal;
							}
							 
							buff.reduceSpeedAttack = buff.rigBodyTarget.originSpeedAttack - ( buff.rigBodyTarget.originSpeedAttack * propSkill.reduceMovement );
							buff.reduceSpeedNormal =  buff.rigBodyTarget.originSpeedNormal - ( buff.rigBodyTarget.originSpeedNormal * propSkill.reduceMovement );
							 
							buff.rigBodyTarget.moveSpeedAttack = buff.reduceSpeedAttack;
							buff.rigBodyTarget.moveSpeedNormal = buff.reduceSpeedNormal;
							buff.rigBodyTarget.moveSpeed = buff.rigBodyTarget.moveSpeed >= 0 ? buff.reduceSpeedAttack : -buff.reduceSpeedAttack;
						
						}
						
					}else{
						
						if( buff.rigBodyTarget.originX ){ // indicate character's params
												
							var originX = buff.rigBodyTarget.originX,
							originY = buff.rigBodyTarget.originX;
							
							if( originX && originY ){// prevent NAN
								//replace movement value
								
								var rigBodyAI = buff.rigBodyTarget.rigBodyAI.rigBody
								
								if( buff.label === buff.rigBodyTarget.object.label ){
									buff.rigBodyTarget.moveReplaceY = originX;
									buff.rigBodyTarget.moveReplaceX = originY;
									buff.rigBodyTarget.moveStaticX = originX;
									buff.rigBodyTarget.moveStaticY = originY;
									buff.rigBodyTarget.moveSpeed = buff.rigBodyTarget.moveSpeed >= 0 ? originX : -originX;
								}else{
									
									buff.rigBodyAI.moveSpeedAttack = originX;
									buff.rigBodyAI.moveSpeedNormal = originX;
									buff.rigBodyAI.moveSpeed = buff.rigBodyAI.moveSpeed >= 0 ?  originX : - originX;
									
								}
							}
						}else{
							
							var originSpeedAttack = buff.rigBodyTarget.originSpeedAttack,
							originSpeedNormal = buff.rigBodyTarget.originSpeedNormal;
							
							if( originSpeedAttack && originSpeedNormal ){// prevent NAN
							
								//replace movement value
								buff.rigBodyTarget.moveSpeedAttack = originSpeedAttack;
								buff.rigBodyTarget.moveSpeedNormal = originSpeedNormal;
								buff.rigBodyTarget.moveSpeed = buff.rigBodyTarget.moveSpeed >= 0 ?  originSpeedAttack : - originSpeedAttack;
								
								if( !buff.rigBodyTarget.rigState ){
									//update moveSpeed
									var rigCharacter = scope.characterControl;
									rigCharacter.moveReplaceX = originSpeedAttack;
									rigCharacter.moveReplaceY = originSpeedAttack - ( originSpeedAttack * 0.222 );
									rigCharacter.moveStaticX = originSpeedAttack;
									rigCharacter.moveStaticY = originSpeedAttack - ( originSpeedAttack * 0.222 );
									rigCharacter.moveSpeed = rigCharacter.moveSpeed >= 0 ? originSpeedAttack : -originSpeedAttack;
								}
							}
							
						} 
						
					}
					
				},
				buffSpeed : function( propSkill, buff, init ){
					 
					var targetRig =  buff.paramsTarget.object.rigBody
					 
					if( init === "register" ){
						
						buff.tempSpeedAttack = targetRig.moveSpeedAttack;
						buff.tempSpeedNormal = targetRig.moveSpeedNormal;
						
						targetRig.moveSpeedAttack = propSkill.speedIncrease;
						targetRig.moveSpeedNormal = propSkill.speedIncrease;
						targetRig.moveSpeed = targetRig.moveSpeed >= 0 
							? propSkill.speedIncrease : -propSkill.speedIncrease;
						
					}else{
						targetRig.moveSpeedAttack = buff.tempSpeedAttack;
						targetRig.moveSpeedNormal = buff.tempSpeedNormal;
						targetRig.moveSpeed = targetRig.moveSpeed >= 0 
							? buff.tempSpeedAttack : -buff.tempSpeedAttack;
					}
											
					
				},
				buffAttack : function( propSkill, buff, init, op ){
						
					this.cloneOriginParams( buff.paramsTarget );
					
					var originalParams = buff.paramsTarget.originalParams;
					
					if( init === "register" ){
						
						var percentageIncrease =  scope.random( propSkill.damageIncreaseMax, propSkill.damageIncreaseMin ),
						attackMax =  originalParams.attackMax * percentageIncrease / 100,
						attackMin =  originalParams.attackMin * percentageIncrease / 100;
						
						buff.paramsTarget.attackMax += attackMax;
						buff.paramsTarget.attackMin += attackMin;
						
						buff.attackMax = attackMax;
						buff.attackMin = attackMin;
						
					}else{
						
						buff.paramsTarget.attackMax -= buff.attackMax;
						buff.paramsTarget.attackMin -= buff.attackMin
					}
											 
				},
				buffDefenseVitallity : function( propSkill, buff, init, op ){
					
					this.cloneOriginParams( buff.paramsTarget );
					
					var originalParams = buff.paramsTarget.originalParams;
					
					if( init === "register" ){
						
						var defenseMax =  originalParams.defenseMax * propSkill.defenseRateMax / 100,
						defenseMin =  originalParams.defenseMin * propSkill.defenseRateMin / 100;
						
						this.operators[ op ]( buff.paramsTarget, "defenseMax", defenseMax );
						this.operators[ op ]( buff.paramsTarget, "defenseMin", defenseMin );
						 
						buff.defenseMax = defenseMax;
						buff.defenseMin = defenseMin;	
					
					}else{
						
						this.operators[ op ]( buff.paramsTarget, "defenseMax", buff.defenseMax );
						this.operators[ op ]( buff.paramsTarget, "defenseMin", buff.defenseMin );
						
					}
				},
				buffDefenseMagic : function( propSkill, buff, init, op ){
					
					this.cloneOriginParams( buff.paramsTarget );
					
					var originalParams = buff.paramsTarget.originalParams;
					
					if( init === "register" ){
						
						var magicDefenseMax =  buff.paramsTarget.magicDefenseMax * propSkill.defenseRateMax / 100,
						magicDefenseMin =  buff.paramsTarget.magicDefenseMin * propSkill.defenseRateMin / 100;
						
						this.operators[ op ]( buff.paramsTarget, "magicDefenseMax", magicDefenseMax );
						this.operators[ op ]( buff.paramsTarget, "magicDefenseMin", magicDefenseMin );
						 
						buff.magicDefenseMax = magicDefenseMax;
						buff.magicDefenseMin = magicDefenseMin;	
					
					}else{
						 		
						this.operators[ op ]( buff.paramsTarget, "magicDefenseMax", buff.magicDefenseMax );
						this.operators[ op ]( buff.paramsTarget, "magicDefenseMin", buff.magicDefenseMin );
						
						
					}
				}
			}
			
			if( options ){
				 
				if( options.throwBoom || options.character ){
					this.throwBoom = function( parent, propSkill ){
						this.boomType = propSkill.triggerName;
						this.parent = parent;
						this.name = "throwBoom";
						this.buffName = "";
						
						this.selectedSkillFrame = /hero/i.test( this.parent.object.label ) ? "throwBoom":"attack";
						
						this.throwLife = 15;
						this.explodeLife = 14;
						this.initExplode = false;
						this.particlePositions = [];
						this.needExplode = this.boomType === "explosionNormalBoom" ? false : true;
						this.update = function( parent ){
							 
							//boom with exploding
							if( this.initExplode ){	
								
								if( this.draw() ){
									
									if( this.explodeLife ){
										
										var pPos =  this.particlePositions; // particle will be pushed when particle is zero
								
										if( pPos.length && ( this.explodeLife % 2 === 0 ) ){
										
											var selectedPPos = pPos.pop();
											
											scope.playAudio("explosion")
											
											scope.glowEffect({
												object : selectedPPos,
												urlInner : 'red-ring-cyrcle.png',
												parent : "",
												alpha : true,
												life : 15,
												isShake : ( this.explodeLife > 4 ),
												scaleSpeed : 3,
												opacityLoss : 0.08,
												bind : false
											});
											
											objSkill.areaDmg({ 
												target : selectedPPos,  
												parent :  this.parent,
												width : 200,
												height : 300,
												propSkill : propSkill
											}) ;
											
										}  
										
										this.explodeLife--;
										
									}else{
										  
										this.buffReg && delete this.buffReg[ this.buffName ]; 
										 
										return true;
									}
									
									
								}
							//single boom	
							}else if( this.throwLife ){
								 
								if( this.throwLife === 15  ){
									
									this.parent.object.visible && scope.playAudio("throw");
						
									if( this.parent.turn ? this.parent.turn === 'right' : this.parent.monsterDir() === 'right' ){
										this.parent.changeRightFn( true );
									}else{ 
										this.parent.changeLeftFn( true);
									}
									
								}else if( this.throwLife === 10 ){
									
									 //call trajectory
									 this.parent.trajectoryInit.createSkillTrajectory({
										parent : this.parent,
										callback : function( bindExplode ){
											//let boom explode first then register buff if required 
													
											var buffName = propSkill.buffName,
												statParameters = this.parent.object.statParameters,
												buffReg =  statParameters.buffSkill ;
											
											if( !buffReg[ buffName ] && buffName ){
												 
												buffReg[ buffName ]  = new scope.items['value'].buffSkills[ buffName ];
											 
												if( /redBoom/i.test( this.boomType ) ){
													
													buffReg[ buffName ].chance = 50;
													
													buffReg[ buffName ].callbackStart = function( buff ){
														 
														objSkill.damageBuff( propSkill, buff );
														
													};
													
													buffReg[ buffName ].icon = 'burningEffectSmall.png';

												}else if( /blueBoom/i.test( this.boomType ) ){
													
													buffReg[ buffName ].chance = scope.random( propSkill.stunMax, propSkill.stunMin );
													
													buffReg[ buffName ].callbackStart = function( buff ){
															
															
															if( !buff.register ){
																var paramsTarget = buff.paramsTarget,
																rigBody = paramsTarget.object.rigBody; 
																rigBody.hitNumber.push( new scope.hitNumber( "stun" ) );
																buff.register =  true;
																rigBody.stunEffect.fn( "long", paramsTarget.object );
															}
															 
														
													};
													
													buffReg[ buffName ].callbackEnd = function( buff ){}; 
													 
													buffReg[ buffName ].icon = 'blue-boom-small.png';

												};
												
												this.buffReg = buffReg;
												this.buffName = buffName;
												  
											}
											  
											if( this.needExplode ){
												
												this.initExplode = true;
												//extend explode particles
												scope.extend( this, new scope.createExplosiveParticle( bindExplode, 30 ), true );
												
											}else{
												scope.explosiveA({
													object : bindExplode,
													parent : "",
													alpha : true
												})
												
												scope.playAudio("explosion");
												
												objSkill.areaDmg({ 
													target : bindExplode,  
													parent :  this.parent,
													width : 200,
													height : 300,
													propSkill : propSkill
												});
												
												this.buffReg && delete this.buffReg[ this.buffName ];
											
											} 
											
										}.bind(this)
										 
									 }); //create trajectory

								}else if( this.throwLife === 1 ){
									//reset frame when frame throwBoom is finish
									parent.dirSwitch.reset();
									parent.dirSwitch.selectedFrame = "normal";
								}else{
									 
									objSkill.forceSelectedFrame( parent, "throwBoom", this.selectedSkillFrame )	
								}
								
								if( this.throwLife ){
									this.throwLife--;
								}
								
							}else if( !this.needExplode && !this.throwLife ){ //init single boom
								return true;
							}
								 
						}
						
					}
				}
				
				if( options.arrowRain || options.character ){
					this.arrowRain = function(  target, propSkill ){
						
						this.rainNum = 15;
						 
						scope.extend( this, new scope.createArrowRainParticle( target, this.rainNum ), true )
						
						this.parent = "";
						
						this.update = function( parent ){
							
							this.parent = parent;
							
							var particlesEnd = this.particlesEnd; // these particles aleardy hitted the ground;
							
							for(var ii = 0; ii < particlesEnd.length ; ii++ ){
								
								var p =  particlesEnd[ii].position;
								
								objSkill.areaDmg({ 
									target : {
										position : {
											x : p.x,
											y : p.y
										}
									},  
									parent :  this.parent,
									width : 100,
									height : 150,
									propSkill : propSkill
								});
								
								particlesEnd.splice( ii, 1 )
								
							}
							
							return this.draw();
							
						}
						
						 
					}
				}
				
				if( options.powerAgility || options.powerAgilityII || options.powerAgilityIII ){
					this.powerAgility = function( parent, propSkill ){
						this.parent = parent;
						this.object = parent.object;
						this.buffName = propSkill.name;
						this.life = 15;
						
						this.object.visible && scope.playAudio("Scary impact");
						
						this.update = function( parent ){
							
							if( this.life === 15 ){ 
								
								var statParameters = this.parent.object.statParameters,
								buffReg =  statParameters.buffSkill ;
								   
								if( !buffReg[ this.buffName ] ){
									
									buffReg[ this.buffName ] = new scope.items['value'].buffSkills[ this.buffName ]; 
									 
									buffReg[ this.buffName ].icon = propSkill.icon;
									
									buffReg[ this.buffName ].castedToAlly = true;
									
									buffReg[ this.buffName ].callbackStart = function( buff ){
										
										if( !buff.isRegisted ){ 
										
											objSkill.buffDefenseMagic( propSkill, buff, "register", "+" );
											objSkill.buffModifierAbilities({
												modifierInitial : "avoid",
												initial : "register",
												buff : buff,
												propSkill : propSkill,
												op : "+"
											});
											objSkill.buffModifierAbilities({
												modifierInitial : "critical",
												initial : "register",
												buff : buff,
												propSkill : propSkill,
												op : "+"
											});
											objSkill.buffModifierAbilities({
												modifierInitial : "criticalChance",
												initial : "register",
												buff : buff,
												propSkill : propSkill,
												op : "+"
											});
											buff.isRegisted = true;
										}
										
									};
									
									buffReg[ this.buffName ].callbackEnd = function( buff ){
										
										if( buff.isRegisted ){
											 
											objSkill.buffDefenseMagic( propSkill, buff, "unregister", "-" );
											objSkill.buffModifierAbilities({
												modifierInitial : "avoid",
												initial : "unregister",
												buff : buff,
												propSkill : propSkill,
												op : "-"
											});
											objSkill.buffModifierAbilities({
												modifierInitial : "critical",
												initial : "unregister",
												buff : buff,
												propSkill : propSkill,
												op : "-"
											});
											
											objSkill.buffModifierAbilities({
												modifierInitial : "criticalChance",
												initial : "unregister",
												buff : buff,
												propSkill : propSkill,
												op : "-"
											});
										}
										
									};
									
									objSkill.registerBuff( statParameters, statParameters, this.buffName );
									
									delete buffReg[ this.buffName ];
									
								}
							
								scope.explosiveA({
									object : this.object,
									parent : "",
									alpha : true,
									isShake : false
								})
							}
							
							if( this.life ){
								objSkill.forceSelectedFrame( this.parent, propSkill.name, "idle" );
								this.life--;
							} else{
								this.parent.dirSwitch.reset();
								this.parent.dirSwitch.selectedFrame = "normal";
								return true;
							}
							
						}
					}
				}
				 
				if( options.powerDefenese || options.powerDefeneseII || options.powerDefeneseIII  ){
					this.powerDefenese = function( parent, propSkill ){
						this.parent = parent;
						this.object = parent.object;
						this.buffName = propSkill.name;
						this.life = 30;
						
						this.object.visible && scope.playAudio("Scary impact");
						
						this.update = function( parent ){
							
							if( this.life === 15 ){ 
							
								var statParameters = this.parent.object.statParameters,
								buffReg =  statParameters.buffSkill ;
								   
								if( !buffReg[ this.buffName ] ){
									
									buffReg[ this.buffName ] = new scope.items['value'].buffSkills[ this.buffName ]; 
									 
									buffReg[ this.buffName ].icon = propSkill.icon;
									
									buffReg[ this.buffName ].castedToAlly = true;
									
									buffReg[ this.buffName ].callbackStart = function( buff ){
										
										if( !buff.isRegisted ){ 
										
											objSkill.buffDefenseVitallity( propSkill, buff, "register", "+" );
											objSkill.buffModifierAbilities({
												modifierInitial : "block",
												initial : "register",
												buff : buff,
												propSkill : propSkill,
												op : "+"
											})
											objSkill.buffModifierAbilities({
												modifierInitial : "critical",
												initial : "register",
												buff : buff,
												propSkill : propSkill,
												op : "+"
											});
											objSkill.buffModifierAbilities({
												modifierInitial : "criticalChance",
												initial : "register",
												buff : buff,
												propSkill : propSkill,
												op : "+"
											});
											
											buff.isRegisted = true;
										}
										
									};
									
									buffReg[ this.buffName ].callbackEnd = function( buff ){
										
										if( buff.isRegisted ){
											 
											objSkill.buffDefenseVitallity( propSkill, buff, "unregister", "-" );
											objSkill.buffModifierAbilities({
												modifierInitial : "block",
												initial : "unregister",
												buff : buff,
												propSkill : propSkill,
												op : "-"
											})
											objSkill.buffModifierAbilities({
												modifierInitial : "critical",
												initial : "unregister",
												buff : buff,
												propSkill : propSkill,
												op : "-"
											});
											
											objSkill.buffModifierAbilities({
												modifierInitial : "criticalChance",
												initial : "unregister",
												buff : buff,
												propSkill : propSkill,
												op : "-"
											});
										}
										
									};
									
									objSkill.registerBuff( statParameters, statParameters, this.buffName );
									
									delete buffReg[ this.buffName ];
								}
							
								scope.explosiveA({
									object : this.object,
									parent : "",
									alpha : true,
									isShake : false
								})
							}
							
							if( this.life ){
								objSkill.forceSelectedFrame( this.parent, this.buffName);
								this.life--;
							} else{
								this.parent.dirSwitch.reset();
								this.parent.dirSwitch.selectedFrame = "normal";
								return true;
							}
							
						}
					}
				}
				
				if( options.teleport ){
					
					this.teleport = function( parent, propSkill ){
						this.parent = parent;
						this.object = parent.object;
						this.target = parent.character;
						this.opacity = 1;
						this.spawnPos = function(){
							var x = scope.random(1,0) ? -50 : 50;
							return {
								x :this.target.position.x + x,
								y :this.target.position.y
							}
						}
						
						this.object.visible && scope.playAudio("evil-swish");
						
						this.update = function( parent ){
							
							if( !this.spawnInit && this.opacity > 0 ){
								 
								objSkill.forceSelectedFrame( this.parent, propSkill.frameStart, propSkill.frameSkillStart );
								
								this.opacity -= propSkill.opacityStart;
								this.object.opacity = this.opacity;
								
							}else{
								
								if( !this.spawnInit ){
									
									this.object.opacity = this.opacity = 0;
									scope.Body.setPosition( this.object, this.spawnPos() );
									this.spawnInit = true;
									parent.dirSwitch.reset();
									parent.dirSwitch.selectedFrame = "normal";
									
						
								} 
								
								if( this.opacity < 1 ){
									
									this.opacity += propSkill.opacityEnd;
									 
									this.object.opacity = this.opacity; 
									
								}else{
									
									this.object.opacity = 1;
									this.target.opacity = 1;
									return true;
								}
								
							}
						}
					}
				}
				
				if( options.mindControl ){
					this.mindControl = function( parent, propSkill ){
						this.parent = parent;
						this.object = parent.object;
						this.buffName = "mindControl";
						this.objectControl = [];
						this.objectGlowParticle = [];
						this.life = 30;
						
						this.object.visible && scope.playAudio(["teleport-swish"]);
						
						this.update = function( parent ){
							
							if( this.life === 15 ){ 
								 
								var statParameters = this.parent.object.statParameters,
								buffReg =  statParameters.buffSkill ;
								
								objSkill.gatherObjectFromParty( this.objectControl,  this.parent, false ); 
										  
								if( !buffReg[ this.buffName ] ){
									
									buffReg[ this.buffName ] = new scope.items['value'].buffSkills[ this.buffName ]; 
									 
									buffReg[ this.buffName ].icon = 'mind-control-small.png';
									
									buffReg[ this.buffName ].castedToAlly = true;
									
									buffReg[ this.buffName ].callbackStart = function( buff ){
										
										var affectedIntimidation = false;
										
										for(var ii = 0; ii < buff.affected.length ; ii++ ){
											
											if( buff.affected[ii].skill.toLowerCase() === "intimidation" ){
												affectedIntimidation = true;
												break;
											}
											
										}
										
										!affectedIntimidation && buff.paramsTarget.object.rigBody.forceObjectToAttack( parent.character );
										
									}; 
									
									objSkill.registerBuff( this.objectControl, statParameters, this.buffName );
									
								} 
								
								scope.explosiveA({
									object : this.object,
									parent : "",
									alpha : true,
									isShake : false
								})
								
								this.objectControl.forEach(function( params ){
									this.objectGlowParticle.push( scope.extend( {}, new scope.createGlowParticle(  params.object , propSkill.life, 10, "purple-cycrle-ring.png", true ), true ) );
									
								}.bind(this));
									
								this.objectControl.length = 0;
								
							}
							 
							 
							if( this.life ){
								objSkill.forceSelectedFrame( this.parent, "mindControl", "skill" );
								if( this.life === 1 ){
									this.parent.dirSwitch.reset();
									this.parent.dirSwitch.selectedFrame = "normal";
								}
								this.life--
							} 
							
							if( this.life < 15 ){ 
							
								var glowP = this.objectGlowParticle;
								
								if( glowP.length ){
									
									for( var ii = 0; ii < glowP.length ; ii++ ){
										if( glowP[ii].draw() ){
											glowP.splice( ii, 1 );
										}
									}
								
								}else{
									return true;
								} 
							}
							
						}
						
					}
				}
				
				if( options.beresekYeti ){
					 
					this.bereseker = function( parent, propSkill ){
						
						var png = {
							shield : scope.path+'red-ring.png',
							innerShield : scope.path+'beresek-shield.png'
						},
						additionalHeight = 30;
						
						this.parent = parent;
						
						this.buffProp = new scope.items['value'].buffSkills.bereseker;
						
						this.object = parent.object;
						
						scope.extend( this, new scope.createShieldParticle( this.object, this.buffProp.tick, png, additionalHeight ), true )
						
						this.lifeSkill = 30;
						
						this.update = function( parent ){
							
							if( !this.beresekInstall ){
								
								this.parent.dirSwitch.approchingState = "run";
								
								this.object.visible && scope.playAudio("evil-crack");
								
								scope.explosiveA({
									object : this.object,
									parent : "",
									alpha : true,
									isShake : false
								})
								
								var statParameters = this.object.statParameters,
								buffReg =  statParameters.buffSkill ;
										  
								if( !buffReg.bereseker ){
									
									buffReg.bereseker = this.buffProp;
									 
									buffReg.bereseker.icon = 'beresek-small.png';
									
									buffReg.bereseker.castedToAlly = true;
									
									buffReg.bereseker.callbackStart = function( buff ){
										
										if( !buff.isRegisted ){ 
										 
											objSkill.buffSpeed( propSkill, buff, "register" );
											objSkill.buffAttack( propSkill, buff, "register" );
											
											buff.isRegisted = true;
										}
										
										
									}.bind(this); 
									
									buffReg.bereseker.callbackEnd = function( buff ){
										
										if( buff.isRegisted ){
											
											objSkill.buffSpeed( propSkill, buff, "unregister" );
											objSkill.buffAttack( propSkill, buff, "unregister" );
											
										}
										
									}.bind(this); 
									
									// self register
									objSkill.registerBuff( statParameters, statParameters, "bereseker" );
								 
									delete buffReg[ "bereseker" ];
								}  
								
								this.beresekInstall =  true;
							}
							
							if( this.lifeSkill > 0 ){
								
								objSkill.forceSelectedFrame( parent, "beresekYeti", "skill" );
								this.lifeSkill--;
								
							}else if( this.lifeSkill === 0 ){
								
								this.parent.dirSwitch.reset();
								this.parent.dirSwitch.selectedFrame = "normal";
								this.lifeSkill--;
								
							}
							 
							if( this.draw() ){
								this.parent.dirSwitch.reset();
								this.parent.dirSwitch.selectedFrame = "normal";
								this.parent.dirSwitch.approchingState = "walk";
								return true;
							}
							
						}
						
					}
					
				}
				
				if( options.healing ){
					
					this.healing = function( parent, propSkill ){
						
						this.parent = parent;
						this.object = parent.object;  
						this.life = 30;
						this.update = function( parent ){
							
							objSkill.forceSelectedFrame( parent, propSkill.name, "skill" );
							
							if( this.life === 15 ){
							
								this.object.visible && scope.playAudio(["healing"]);
							
								scope.glowEffect({
									object : this.object,
									parent : "",
									alpha : true,
									life : 25,
									scaleSpeed : 4
								})
								 
							}else if( this.life < 14 ){
								
								
								var statParameters = this.parent.object.statParameters,
								buffReg =  statParameters.buffSkill ;
										  
								if( !buffReg.healing ){
									
									buffReg.healing = new scope.items['value'].buffSkills.healing; 
									  
									buffReg.healing.castedToAlly = true;
									
									buffReg.healing.callbackStart = function( buff ){
										
											
										var health = scope.random( propSkill.healthIncreaseMax, propSkill.healthIncreaseMin )
										
										if( buff.paramsTarget.health + health < buff.paramsTarget.maxHealth ){
											
											buff.paramsTarget.object.visible && scope.playAudio("heartbeat-1");
							 
											var objTarget = buff.paramsTarget.object;
											objTarget.visible && objTarget.rigBody.hitNumber.push( new scope.hitNumber( health, "heal" ) )
						
											buff.paramsTarget.health += health;
										
										}else{
											
											buff.paramsTarget.health = buff.paramsTarget.maxHealth;
											
										}
										
									};
									
									objSkill.registerBuff( statParameters, statParameters, "healing" );
									
									
									delete buffReg.healing;
									
								
								} 
								
							}
							
							
							
							if( this.life ){
								this.life--;
							}else{
								
								parent.dirSwitch.reset()
								parent.dirSwitch.selectedFrame = "normal";
								return true;
							}
						}
						
					}
				
				}
				
				if( options.massHealing ){
					  
					this.massHealing = function( parent, propSkill ){
						
						this.parent = parent;
						this.object = parent.object;  
						this.objectHeal = [];
						this.life = 30;
						this.update = function( parent ){
							
							objSkill.forceSelectedFrame( parent, propSkill.name, "skill" );
							
							if( this.life === 15 ){
								
								this.object.visible && scope.playAudio("healspell2");
								
								objSkill.gatherObjectFromParty( this.objectHeal,  this.parent, true );
							 
								for( var kk = 0, ll = this.objectHeal; kk < ll.length ; kk ++ ){
									scope.glowEffect({
										object : ll[kk].object,
										parent : "",
										alpha : true,
										life : 25,
										scaleSpeed : 4
									})
								} 
								
							}else if( this.life < 14 ){
								
								
								var statParameters = this.parent.object.statParameters,
								buffReg =  statParameters.buffSkill ;
										  
								if( !buffReg.massHealing ){
									
									buffReg.massHealing = new scope.items['value'].buffSkills.massHealing; 
									  
									buffReg.massHealing.castedToAlly = true;
									
									buffReg.massHealing.callbackStart = function( buff ){
										
											
										var health = scope.random( propSkill.healthIncreaseMax, propSkill.healthIncreaseMin )
										
										if( buff.paramsTarget.health + health < buff.paramsTarget.maxHealth ){
											
											buff.paramsTarget.object.visible && scope.playAudio("heartbeat-1");
											
											var objTarget = buff.paramsTarget.object;
											objTarget.visible && objTarget.rigBody.hitNumber.push( new scope.hitNumber( health, "heal" ) )
						
											buff.paramsTarget.health += health;
										
										}else{
											
											buff.paramsTarget.health = buff.paramsTarget.maxHealth;
											
										}
										
									};
									  
									objSkill.registerBuff( this.objectHeal, statParameters, "massHealing" ); 
										 
									delete buffReg.massHealing;
									
								
								} 
								
							}
							 
							
							if( this.life ){
								this.life--;
							}else{
								
								parent.dirSwitch.reset()
								parent.dirSwitch.selectedFrame = "normal";
								return true;
							}
						}
						
					}
				
				}
				
				if( options.earthQuake ){
					
					this.earthQuake = function( parent, propSkill ){
						
						this.parent = parent;
						
						this.object = parent.object; 
						
						this.life = 64;
						
						this.update = function(){
							
							objSkill.forceSelectedFrame( parent, "earthQuake", "attack" );
							
							if( this.life % 13 === 0 ){
								 
								this.object.visible && scope.playAudio("explosion");
								
								objSkill.areaDmg({ 
									target : this.object,  
									parent :  this.parent,
									width : 300,
									height : 250,
									propSkill : propSkill
								});
								 
								scope.explosiveA({
									object : this.object,
									parent : "",
									alpha : true,
									isShake : true,
									shakeNum : 1
								})
								parent.dirSwitch.reset()
								
							}
							
							if( this.life ){
								this.life--;
							}else{
								parent.dirSwitch.reset()
								parent.dirSwitch.selectedFrame = "normal";
								return true;
							}
							
						}
					}
					
				}
				
				if( options.earthShake ){
					
					this.earthShake = function( parent, propSkill ){
						this.parent = parent;
						
						this.object = parent.object; 
						
						this.life = 40;
						this.scaleSpeed = 5;
						
						this.update = function( parent ){
								
							objSkill.forceSelectedFrame( parent, "earthShake", "attackB" );
							
							if(  this.life <= 13 && this.life >= 5  && ( this.life % 3 === 0 ) ){
								
								
								this.object.visible && scope.playAudio("explosion");
								
								objSkill.areaDmg({ 
									target : this.object,  
									parent :  this.parent,
									width : 300,
									height : 250,
									propSkill : propSkill
								});
								
								scope.objTranslate["value"].isShake.createShake( 1 );
								
								scope.glowEffect({
									object : this.object,
									parent : "",
									alpha : true,
									life : 3,
									scaleSpeed : this.scaleSpeed--,
									urlInner : "grey-cycrle.png",
									opacityLoss :0.05
								})
							}
							
							if( this.life ){
								this.life--;
							}else{
								parent.dirSwitch.reset()
								parent.dirSwitch.selectedFrame = "normal";
								return true;
							}
							
						}
					}
				}
				
				if( options.defenseSteal || options.abilitiesSteal ){
					
					this[ options.defenseSteal ? "defenseSteal" : "abilitiesSteal" ] = function( parent,  propSkill ){
						this.parent = parent;
						
						this.object = parent.object;
						
						this.target = parent.character;
						
						this.buffName = propSkill.name;
						
						this.life = propSkill.life;
						
						this.object.visible && scope.playAudio(["phazed-bang"]);
						
						this.update = function( parent ){
							
							objSkill.forceSelectedFrame( parent, this.buffName, "attack" )
							
							if( this.life === 5 ){
								 
								if( this.parent.turn ? this.parent.turn === 'right' : this.parent.monsterDir() === 'right' ){
									this.parent.changeRightFn( true );
								}else{ 
									this.parent.changeLeftFn( true);
								}
								
								scope.glowEffect({
									object : this.object,
									parent : "",
									alpha : true,
									life : 10,
									scaleSpeed : 3,
									urlInner : "black-cycrle.png"
								})
								
								scope.glowEffect({
									object : this.target ,
									parent : "",
									alpha : true,
									life : propSkill.life,
									scaleSpeed : 3,
									urlInner : "black-cycrle.png"
								})
								 
								var statParameters = this.parent.object.statParameters,
								buffReg =  statParameters.buffSkill ;
										  
								if( !buffReg[ this.buffName ] ){
									
									buffReg[ this.buffName ] = new scope.items['value'].buffSkills[ this.buffName ];
									
									buffReg[ this.buffName ].icon = propSkill.icon
									
									buffReg[ this.buffName ].callbackStart = function( buff ){
										
										if( !buff.isRegisted ){  
										
											if( this.buffName === "defenseSteal" ){
												
												objSkill.buffDefenseVitallity( propSkill, buff, "register", "-" );
												objSkill.buffDefenseMagic( propSkill, buff, "register", "-" ); 
												
											}else if( this.buffName === "abilitiesSteal" ){
					
					
												objSkill.buffModifierAbilities({
													modifierInitial : "avoid",
													initial : "register",
													buff : buff,
													propSkill : propSkill,
													op : "-"
												});
												
												objSkill.buffModifierAbilities({
													modifierInitial : "block",
													initial : "register",
													buff : buff,
													propSkill : propSkill,
													op : "-"
												});
												
											}
											buff.isRegisted = true;
										}
										
										
									}.bind(this) ;
									
									buffReg[ this.buffName ].callbackEnd = function( buff ){
										
										if( buff.isRegisted ){
											 
											 if( this.buffName === "defenseSteal" ){
												
												objSkill.buffDefenseVitallity( propSkill, buff, "unregister", "+"  );
												objSkill.buffDefenseMagic( propSkill, buff, "unregister", "+" );  
												
											}else if( this.buffName === "abilitiesSteal" ){
												
												objSkill.buffModifierAbilities({
													modifierInitial : "avoid",
													initial : "unregister",
													buff : buff,
													propSkill : propSkill,
													op : "+"
												});
												
												objSkill.buffModifierAbilities({
													modifierInitial : "block",
													initial : "unregister",
													buff : buff,
													propSkill : propSkill,
													op : "+"
												});
												
											}
											 
										}
										
									}.bind(this);
									
									
									
									// self register
									objSkill.registerBuff( this.target.statParameters, statParameters, this.buffName );
								
									delete buffReg[ this.buffName ];//prevent object casting a buff when hit other enemy
								 
								} 
							
								
							}
							
							if( this.life ){
								this.life--;
							}else{
								parent.dirSwitch.reset()
								parent.dirSwitch.selectedFrame = "normal";
								return true;
							}
							
							
						}
					}
				}
				
				if( options.bodyCharge ){
					this.bodyCharge = function( parent, propSkill ){
						this.parent = parent;
						this.object = parent.object;
						this.target = parent.character;
						this.speed = 5;
						this.life = 50;
						this.vec = "";
						
						this.update = function( parent ){
							if( !this.install ){
								this.vec = scope.moveVector2dWithVelocity( this.object, this.target, this.speed );
								this.install = true;
									
							}else{
								
								objSkill.forceSelectedFrame( parent, "bodyCharge")
								
								if( this.life ){
									
									if( this.life % 5 === 0 ) {
										
										this.object.visible && scope.playAudio(["swing","swing2","swing3"]);
										
										objSkill.areaDmg({ 
											target : this.object,  
											parent :  this.parent,
											width : 200,
											height : 150,
											propSkill : propSkill
										});
										
									}
									
									scope.Body.setPosition( this.object, {
										x : this.object.position.x + this.vec.x,
										y : this.object.position.y + this.vec.y
									})
									this.life--;
								}else{
									
									parent.dirSwitch.reset()
									parent.dirSwitch.selectedFrame = "normal";
									return true;
								}
								
							}
						}
					}
				}
				
				if( options.growHowl ){
					
					this.growHowl = function( parent, propSkill ){
						this.parent = parent;
						
						this.object = parent.object;
						
						this.buffName = "growHowl";
						
						this.life = 30;
						
						this.object.visible && scope.playAudio(["evil-crack"]);
						
						this.update = function( parent ){
							
							if( this.life === 20 ){
								
								scope.explosiveA({
									object : this.object,
									parent : "",
									alpha : false,
									isShake : false
								})
								
								var areaPool = this.parent.createAreaDamagePool({
									target : this.parent.object,
									width : 500,
									height : 500,
									caster : this.parent.object.label
								}), 
								
								statParameters = this.parent.object.statParameters,
								buffReg =  statParameters.buffSkill ;
										  
								if( !buffReg.growHowl ){
									
									buffReg.growHowl = new scope.items['value'].buffSkills[ this.buffName ];
									
									buffReg.growHowl.castedToAlly = true;
									
									buffReg.growHowl.icon = 'grow-howl-small.png';
									
									buffReg.growHowl.callbackStart = function( buff ){
										
										if( !buff.isRegisted ){
										
											
											objSkill.buffAttack( propSkill, buff, "register" );
											
											buff.isRegisted = true
										}
										
										
									};
									
									buffReg.growHowl.callbackEnd = function( buff ){
										
										if( buff.isRegisted ){
											 
											 objSkill.buffAttack( propSkill, buff, "unregister" );
										
										}
										
									}; 
									
									//register buff to ally
									objSkill.registerBuff( areaPool, statParameters, this.buffName );
									
									// self register
									objSkill.registerBuff( statParameters, statParameters, this.buffName );
									
									
									delete buffReg[ this.buffName ];
								 
								} 
							
								
							}
							
							objSkill.forceSelectedFrame( parent, this.buffName, this.buffName )
							
							if( this.life ){
								this.life--;
							}else{
								parent.dirSwitch.reset()
								parent.dirSwitch.selectedFrame = "normal";
								return true;
							}
							
						}
					}
				}
				
				if( options.summoning || options.golemSummoner || options.sekletonSummoner ){
					
					 this.summoning = function(  parent, target, propSkill  ){
						 
						 this.parent = parent;
						 
						 this.target = target;
						 
						 this.spawnTick = propSkill.spawnTick;
						 
						   
						 this.skillTick = 30;
						 
						 this.isBeastArmor =  /beastArmor/i.test( this.parent.object.label );
						 
						 this.selectedSkillFrame = this.isBeastArmor ? "growHowl" : propSkill.selectedSkillFrame;
						
						 this.update = function(){
							 
							 if( !this.installParent ){
								 
									var initialParams = propSkill.initialParams;
									 
									this.parent.object.visible && scope.playAudio("spawn");
									
									initialParams.aIParent = this.parent.initialSpawn;
									initialParams.spawn.x = this.target.position.x + scope.random( 250, -250 );
									initialParams.spawn.y = this.target.position.y + scope.random( 100, -100 );
									initialParams.objBoss = this.parent.object;
									initialParams.visible = true;
									initialParams.objPawns = [];
									
									scope.monsterControl.createAINpc( initialParams );
									
									scope.orderObjectFn['value']()
									
									scope.extend( this, new scope.createGlowParticle(  propSkill.initialParams , propSkill.life ), true );
									
									initialParams.objPawns.forEach(function( obj ){
										//force to attack to prevent idle onload
										obj.rigBody.forceObjectToAttack( this.target )
									}.bind(this))
									
									scope.glowEffect({
										object : this.parent.object,
										parent : "",
										alpha : false,
										life : 25,
										scaleSpeed : 4
									})
									
									this.installParent = true;
								 
							 }else{
								 
								 
								var objPawns = propSkill.initialParams.objPawns,
								selectedFrame = "";
 
								if( this.spawnTick ){
									
									objPawns.forEach(function( obj ){
										objSkill.forceSelectedFrame( obj.rigBody, "summon", "summon" );
									}.bind(this))
									
									if( this.spawnTick === 1 ){
										objPawns.forEach(function( obj ){
											obj.rigBody.behaveRandomFn(1);
										})
									}
									
									this.spawnTick--;
								}
								
								if( this.skillTick ){
									//for temporary solution
									 
									objSkill.forceSelectedFrame( this.parent, propSkill.name, this.selectedSkillFrame );
									this.skillTick--;
								}else if( !this.resetFrame ){
									
									this.parent.dirSwitch.reset()
									this.parent.dirSwitch.selectedFrame = "normal";
									this.resetFrame = true; 
								}
									
								if( this.draw() ){ 
								
									objPawns.forEach(function( obj ){
										obj.rigBody.forceObjectToAttack( this.target );
										obj.rigBody.dirSwitch.reset()
										obj.rigBody.dirSwitch.selectedFrame = "normal";
									}.bind(this));
									
										
									objPawns.length = 0
									return true
								}
							 
							}
						 }
						 
					 }
					
				}
				
				if( options.createBlue  || options.createRed ){ //AI only
				 
					 this[ options.createBlue ? "createBlue" : "createRed" ] = function(  parent, propSkill ){
						 
						 var staticPos = { x : 0, y : -170};
						 
						 scope.extend( this, new scope.createBlueParticle( parent.object, propSkill.tick, staticPos, propSkill.particleParams ), true );
						 
						 this.parent = parent;
						 
						 this.name = propSkill.name;
						 
						 this.update = function( parent){ 
							
							this.parent = parent;
							 
							var drawProp = this.draw(); 
							 
							if ( drawProp.hit  ){
									
								var target;	
								
									
								if( this.targetEnd ){
									
									var areaPool = this.parent.createAreaDamagePool({
										target : this.targetEnd,
										width : 300,
										height : 300,
										caster : this.parent.object.label
									});
									
									
									for( var kk = 0, ll = areaPool; kk < ll.length ; kk ++ ){
										this.parent.characterDamagePool({
											objectAttacker : this.parent.object,
											objectTarget : ll[kk].object
										});
									}
								
									
									
									target = "random";
									
								}else{
									target = "nearest";
								}
								
								
								this.targetEnd = this.parent.AISelectTarget( 800, 400 , target );
								
							}
							
							return drawProp.life;
							
						}
						 
					 }
					
				}
				
				if( options.piercingSpear || options.piercingSpeed  || options.piercingSword ){ //AI only
					
					this.piercingObject = function( parent, propSkill ){
						
						this.parent = parent;
						this.object = parent.object;
						this.target = parent.character;
						this.install = false;
						this.speed = propSkill.speed;
						this.life = 20;
							
						this.update = function( parent ){
							
							if( !this.install ){
								this.install = true;
								this.vec = scope.moveVector2dWithVelocity( this.object, this.target, this.speed );
								parent.dirSwitch.reset()
								
							}else{
								 
								objSkill.forceSelectedFrame( parent, propSkill.uniqueFrame, propSkill.selectedFrame )
									
								if( this.life > 14 ){
									
									this.life--;
								}else if( this.life > 11  ){
									
									scope.Body.setPosition( this.object, {
										x : this.object.position.x + this.vec.x,
										y : this.object.position.y + this.vec.y
									})
									
									this.life--;
									
								}else if( this.life === 9 ){
									
									this.object.visible && scope.playAudio(["hitfreeze"]);
									
									objSkill.singleDmg( this.target.statParameters, propSkill, this.parent );
									
									this.life--;
									
								}else if( this.life ){
									
									this.life--;
									
								}else{
									
									parent.dirSwitch.reset()
									parent.dirSwitch.selectedFrame = "normal";
									return true;
								}
								
								 
							}
							
						}
						
					}
					
				}
				
				if( options.bindingRoot ){
					
					this.bindingRoot = function( parent, target, propSkill ){
						this.parent = parent;
						
						this.object = this.parent.object;
						
						this.target = target.statParameters;
						
						this.buffName = "bindingRoot";
						
						this.life = 20;
						
						this.object.visible && scope.playAudio(["teleport-swish"]);
						
						this.update = function( parent ){
							
							var frame = /human/i.test( this.object.label ) ? "bindingRoot" : "attackB";
							
							objSkill.forceSelectedFrame( parent, "bindingRoot", frame );
							
							if( this.life === 5 ){
								
								
								if( this.parent.turn ? this.parent.turn === 'right' : this.parent.monsterDir() === 'right' ){
									this.parent.changeRightFn( true );
								}else{ 
									this.parent.changeLeftFn( true);
								}
								
								scope.explosiveA({
									object : this.object,
									parent : "",
									alpha : true,
									isShake : false
								})
								
								var statParameters = this.parent.object.statParameters,
								buffReg =  statParameters.buffSkill ;
										  
								if( !buffReg.bindingRoot ){
									
									buffReg.bindingRoot = new scope.items['value'].buffSkills[ this.buffName ];
									
									buffReg.bindingRoot.icon = 'binding-root-small.png';
									
									buffReg.bindingRoot.callbackStart = function( buff ){
										
										if( !buff.isRegisted ){  
										
											objSkill.buffSpeedPlusChara( propSkill, buff, "register" );
											
											buff.isRegisted = true;
											
										}
										
										
									};
									
									buffReg.bindingRoot.callbackEnd = function( buff ){
										
										if( buff.isRegisted ){ 
										 
											objSkill.buffSpeedPlusChara( propSkill, buff, "unregister" );
											
										}
										
									}; 
									  
									// self register
									objSkill.registerBuff( this.target, statParameters, this.buffName );
									
									delete buffReg.bindingRoot;
								} 
							
								
							}
							
							if( this.life ){
								this.life--;
							}else{
								parent.dirSwitch.reset()
								parent.dirSwitch.selectedFrame = "normal";
								return true;
							}
							
						}
					}
				}
				 
				if( options.bloodDrain ){ //AI only
					
					this.bloodDrain = function(  bind, propSkill ){
						
						var png = {
							shield : scope.path+'red-ring.png',
							innerShield : scope.path+'blood-drain.png'
						},
						additionalHeight = 55
						
						scope.extend( this, new scope.createShieldParticle( bind, propSkill.tick, png, additionalHeight), true )
						
						this.parent = bind.rigBody, tickUpdate = 100;
						
						this.buffName = "bloodDrain";
						
						this.tick = 0;
						
						this.parent.object.visible && scope.playAudio("evil-crack");
						
						this.updateBloodDrain = function(){
							
							var areaPool = this.parent.createAreaDamagePool({
								target : this.parent.object,
								width : 500,
								height : 500,
								caster : this.parent.object.label
							}), 
							
							statParameters = this.parent.object.statParameters,
							buffReg =  statParameters.buffSkill ;
									  
							if( !buffReg.bloodDrain ){
								
								buffReg.bloodDrain = new scope.items['value'].buffSkills.bloodDrain;
								
								buffReg.bloodDrain.icon = 'bloodDrainSmall.png';
								
								buffReg.bloodDrain.callbackStart = function( buff ){
									 
								 
									var health = Math.round( objSkill.damageBuff( propSkill, buff ) * ( propSkill.healthConvertion / 100 ) );
									
									if( buff.paramsAttacker.health + health < buff.paramsAttacker.maxHealth){
									
										buff.paramsAttacker.health += health;
									
									}
									
								};
							
							} 

							//register buff
							
							objSkill.registerBuff( areaPool, statParameters, this.buffName );
							
							
						}
						
						this.update = function( parent ){
							
							this.parent = parent
							
							if( this.tick ){
								this.tick--
							}else{
								this.tick = tickUpdate;
								this.updateBloodDrain();
							}
						
							return this.draw()
						
						}
						
					}
					
				}
				
				if( options.intimidation || options.character ){
					
					this.intimidation = function( parent, propSkill ){
						
						this.parent = parent, tickUpdate = 100;
						
						this.object = parent.object;
						
						var png = {
							shield : scope.path+'red-ring.png',
							innerShield : scope.path+'protection-shield.png'
						},
						additionalHeight = 45;
						
						this.object.visible && scope.playAudio("evil-crack");
						
						this.buffProp = new scope.items['value'].buffSkills.intimidation;
						
						scope.extend( this, new scope.createShieldParticle( this.object, this.buffProp.tick, png, additionalHeight ), true )
						
						
						this.buffName = "intimidation";
						
						this.tick = 0;
						
						this.selfIntimidation = function(){
							
							var statParameters = this.parent.object.statParameters,
							buffReg =  statParameters.buffSkill,
							parent = this.parent;
							
							if( !buffReg.selfIntimidation ){
								
								buffReg.selfIntimidation = new scope.items['value'].buffSkills.intimidation;
								
								buffReg.selfIntimidation.icon = 'intimidationSmall.png';
								
								buffReg.selfIntimidation.name = 'selfIntimidation';
								
								buffReg.selfIntimidation.castedToAlly = true;
								 
								buffReg.selfIntimidation.callbackStart = function( buff ){
									
									buff.paramsTarget.object.rigBody.forceObjectToAttack( this.parent.object );
									
									if( !buff.isRegisted ){
										
										objSkill.buffDefenseVitallity( propSkill, buff, "register", "+" );
										objSkill.buffDefenseMagic( propSkill, buff, "register", "+" );
										objSkill.buffModifierAbilities({
											modifierInitial : "block",
											initial : "register",
											buff : buff,
											propSkill : propSkill,
											op : "+"
										})
										 
										buff.isRegisted = true;
									}
									
								}.bind( this );
								
								buffReg.selfIntimidation.callbackEnd = function( buff ){
									
									if( buff.isRegisted ){
										
										objSkill.buffDefenseVitallity( propSkill, buff, "unregister", "-" );
										objSkill.buffDefenseMagic( propSkill, buff, "unregister", "-" );
										objSkill.buffModifierAbilities({
											modifierInitial : "block",
											initial : "unregister",
											buff : buff,
											propSkill : propSkill,
											op : "-"
										})
										
									}
									
								}.bind( this );
								 
								objSkill.registerBuff( statParameters, statParameters, "selfIntimidation" );
								
							}
							
							delete buffReg[ "selfIntimidation"  ];
							
						}
						
						this.updateIntimidation = function(){
							
							var areaPool = this.parent.createAreaDamagePool({
								target : this.parent.object,
								width : 500,
								height : 500,
								caster : this.parent.object.label
							}), 
							
							statParameters = this.parent.object.statParameters,
							buffReg =  statParameters.buffSkill,
							parent = this.parent;
							
							//remove ally and self
							for( var ii = 0; ii < areaPool.length; ii++ ){
								
								if( !this.parent.isEnemyFn( areaPool[ii].object.label ) 
									|| areaPool[ii].object.label === this.object.label ){
									areaPool.splice( ii, 1 );
								}
							}
							
							
							if( !this.updateSelfbuff ){
								this.selfIntimidation();
								this.updateSelfbuff =  true;
							}
							
									  
							if( !buffReg.intimidation ){
								
								buffReg.intimidation = this.buffProp; 
								
								buffReg.intimidation.icon = 'intimidationSmall.png';
								  
								buffReg.intimidation.callbackStart = function( buff ){
									
									buff.paramsTarget.object.rigBody.forceObjectToAttack( this.parent.object );
									
									if( !buff.isRegisted ){
										 
										buff.isRegisted = true;
									}
									
								}.bind( this ); 
								
							} 
							
							//register buff
							objSkill.registerBuff( areaPool, statParameters, this.buffName );
							
							delete buffReg[ this.buffName ];
							
						}
						
						this.update = function( parent ){
							
							this.parent = parent
							
							if( this.tick ){
								this.tick--
							}else{
								this.tick = tickUpdate;
								this.updateIntimidation( );
							}
						
							return this.draw()
						
						}
					
					}
				}
				
				if( options.rollingAttack || options.character ){
					
					this.rollingAttack = function( parent, propSkill ){
						
						this.parent = parent;
						this.selectedFrame = propSkill.name
						this.life = 20;
						this.delayAreaPool = this.lifePhysic = 10;
						this.trajectoryY = true;
						this.trajectoryX = true;
						
						
						scope.extend( 
							this, new scope.physicsComponent.objectTrajectory( this.parent.object, this.lifePhysic ) , true 
						)
						
						parent.forceToSwitchTurn()
						
						this.update = function( parent ){
							
							this.parent = parent;
							
							if( this.selectedFrame !== this.parent.dirSwitch.selectedFrame ) return true;
							
							if( this.parent.isAttacking || this.parent.behave === "attack" ){
								
								if( this.life ){
									
									if( this.life <= this.lifePhysic ){
										
										this.updatePhysic( this.trajectoryX, this.trajectoryY );
										
										this.delayAreaPool--;
										
										if( this.delayAreaPool % 3 === 0 ) {
											
											this.parent.object.visible && scope.playAudio(["swing","swing2","swing3"]);
						 
											objSkill.areaDmg({ 
												target : this.parent.object,  
												parent :  this.parent,
												width : 200,
												height : 175,
												propSkill : propSkill
											});
											
										}
										
									
									}
									
									this.life--
								}else{
									parent.dirSwitch.resetWhenFrameEnd = true;
									return true
								}
								
							}else{
								parent.dirSwitch.resetWhenFrameEnd = true;
								return true;
							}
						}
						
					}
					
				}
 			
				if( options.teleportation   ){
					this.teleportation = function( object, target, init ){
						this.object = object;
						this.target = target;
						this.isOval = object.label === scope.oval["value"].label;
						this.ovalIterate = 0;
						this.opacity = 0;
						this.spawnInit = false;
						this.objTranslate = scope.objTranslate["value"];
						
						this.object.visible && scope.playAudio("evil-swish");
						
						this.translateOvalOnly = function( pos ){
							
							if( this.isOval  ){
								
								this.objTranslate.staticObjMoveX = pos.x;
								this.objTranslate.staticObjMoveY = pos.y;
								
							}
							
						}
						this.spawnPos = function(){
							var rand = scope.random(1,0);
							var x = rand ? -50 : 50;
							return {
								x :this.target.position.x + x,
								y :this.target.position.y
							}
						}
						
						
						this.update = function( parent ){
							if( init === "approching" ){
								
								if( !this.spawnInit ){
									var pos = this.spawnPos();
									scope.Body.setPosition( this.object, pos );
									this.translateOvalOnly( pos );
									this.spawnInit = true;
									parent.dirSwitch.reset()
									parent.dirSwitch.dirBlock.reset()
								}else{
									
									if( this.isOval && this.ovalIterate < 2){
										var pos = {
											x : this.object.rigBody.moveReplaceX,
											y : this.object.rigBody.moveReplaceY
										}
										this.translateOvalOnly( pos );
									}else{
										
										
										parent.dirSwitch.selectedFrame = "normal";
								
										if( this.opacity <= 1 ){
											this.opacity += 0.09;
											this.object.opacity = this.opacity;
										}else{
											this.target.opacity = 1;
											return true;
										}
									}
								
								}
								
								this.ovalIterate++;
							}
						}
					}
				}
				
				if( options.sliceAttack || options.character ){
					
					this.sliceAttack = function( parent, propSkill ){
						
						this.parent = parent;
						this.selectedFrame = propSkill.name;
						
						this.life = 10; 
						 
						parent.forceToSwitchTurn()
						
						this.update  = function( parent ){
							
							this.parent = parent;
							
							if( this.selectedFrame !== this.parent.dirSwitch.selectedFrame ) return true;
							
							if( !this.life ){
								
								objSkill.areaDmg({ 
									target : this.parent.object,  
									parent :  this.parent,
									width : 400,
									height : 350,
									propSkill : propSkill
								});
								 
								scope.playAudio("heat-impact")
								
								scope.explosiveA({
									object :  this.parent.object,
									parent : "",
									alpha : true
								})
								
								parent.dirSwitch.resetWhenFrameEnd = true;
								return true
								
							}
			
							this.life--
						}
					}
					
				}
				
				if( options.upperAttack || options.character ){
					
					this.upperAttack = function( parent, propSkill ){
						
						this.parent = parent;
						this.selectedFrame = propSkill.name;
						
						this.life = 20;
						this.delayAreaPool = this.lifePhysic = 6;
						this.trajectoryY = false;
						this.trajectoryX = true;
						
						scope.extend( 
							this, new scope.physicsComponent.objectTrajectory( this.parent.object, this.lifePhysic ) , true 
						)
						
						parent.forceToSwitchTurn()
						
						this.update = function( parent ){
							
							this.parent = parent;
							
							if( this.selectedFrame !== this.parent.dirSwitch.selectedFrame ) return true;
							
							if( this.parent.isAttacking || this.parent.behave === "attack" ){
								
								if( this.life ){
									
									if( this.life <= this.lifePhysic ){
										
										this.updatePhysic( this.trajectoryX, this.trajectoryY );
										
										this.delayAreaPool--;
										
										if( this.delayAreaPool % 3 === 0 ) {
 
											this.parent.object.visible && scope.playAudio(["swing","swing2","swing3"]);
											
											objSkill.areaDmg({ 
												target : this.parent.object,  
												parent :  this.parent,
												width : 200,
												height : 175,
												propSkill : propSkill
											});
											
										}
										
									
									}
									
									this.life--
								}else{
									parent.dirSwitch.resetWhenFrameEnd = true;
									return true
								}
								
							}else{
								parent.dirSwitch.resetWhenFrameEnd = true;
								return true;
							}
						}
						
					}
					
																 
																
				}
				
			}
			 
			this.skillRequirement = function( objectSkill ){
				
				var inventory = scope.characterInventoryBag['value'].get( this.object.label ) ;
				switch( objectSkill.name ) {
						
						case "throwBoom" : 
								
							var isNormalBoom = true,
							indexBagArr = [];
							
							//item index collection
							for(var ii = 0, len = inventory.length; ii < len; ii++ ){
								
								var item = inventory[ii],
								initial = item.name.toLowerCase();
								
								if( item.type === "equipmentThrowBoom" && 
									initial.indexOf( objectSkill.stringRequired ) !== -1 ){
									
									var index = typeof item.indexBagLocation !== "undefined"  ? item.indexBagLocation : "bagUnreg";
									 
									indexBagArr.push( index );
								}
							}
							
							//sorting
							indexBagArr.sort( function( a, b ){return a - b } );
							 
							//selecting item from the lowest index
							self : for(var ii = 0, index = indexBagArr[0] , len = inventory.length; ii < len; ii++ ){
								
								var item = inventory[ii];
								
								// indexBagLocation of equipmentThrowBoom is registered or unregistered
								 
								if( item.type === "equipmentThrowBoom" && ( 
									item.indexBagLocation === index 
									&& index !== "bagUnreg" || index === "bagUnreg" ) ){ 
									 
									if( /redBoom/i.test( item.name ) ){
										
										objectSkill.triggerName = item.name.toLowerCase();
										objectSkill.damageMax = item.damageMax;
										objectSkill.damageMin = item.damageMin;
										objectSkill.buffName = "burningEffect";
										
									
									}else if( /blueBoom/i.test( item.name ) ){
											
										objectSkill.triggerName = item.name.toLowerCase();
										objectSkill.damageMax = item.damageMax;
										objectSkill.damageMin = item.damageMin;
										objectSkill.stunMax = item.stunMax;
										objectSkill.stunMin = item.stunMin;
										objectSkill.reduceMovement = item.reduceMovement;
										objectSkill.buffName = "stunEffect";
										 
									}
									 
									isNormalBoom = false;
									 
								
									item.quantity--;
									if( !item.quantity ){ // isZero;
										inventory.splice( ii, 1 );
									}
									
									break self;
									
								}
								
							}
							
							indexBagArr.length = 0;
							
							
							if( isNormalBoom ){
								objectSkill.triggerName = "explosionNormalBoom";
								objectSkill.buffName = "burningEffect";
								objectSkill.damageMax = this.object.statParameters.attackRangeMax;
								objectSkill.damageMin = this.object.statParameters.attackRangeMin;
							}
							
						break;
				}
				
			}
			
			this.triggerUniqueSkill = function( obj, objectSkill ){
				var statParameters = this.object.statParameters;
				if( statParameters.mp > objectSkill.mp && objectSkill.state && function(){
					return objectSkill.enemyTolerance ? false : this.attackTolerance(); //enemy filter ex createBlue need this
				}.bind(this) ){ 
					
					obj.install();
					obj.guiInitLoading();
					this.skillRequirement( objectSkill );
											
					var requireMp = objectSkill.mp,
					parent = this,
					triggerSkillToIntervalList = function( prop ){
						
						scope.intervalList[ objectSkill.label ] = {
							always : true,
							tick : prop.tick, // 8 m
							tickUpdate : prop.tick,
							alreadyExecuted : false,
							fn : function(){
								
								if( prop.isCustom ){
									
									if( function(){
										
										return prop.conditional ? prop.conditional() : true;
									
									}() ){
									
										if ( prop.isCustom === "customExecute" ){
										
											prop.callback( this )
											
										}else{
											if( !this.alreadyExecuted ){
												 
												prop.callback()
										
												parent.dirSwitch.reset();
												this.always = false;
												this.alreadyExecuted = true;
												this.tick = 0;
											 
											}
										}
									}
									
								}else{	
								
									if( !this.alreadyExecuted && function(){
										
										var attackTolerance = true;
										if( parent.object.statParameters.attackType === "melee" ){
											
											//character 
											if( parent.characterState ){
												
												attackTolerance = parent.attackTolerance() 
												&& !parent.dirSwitch.forceAttackFrame 	
													&& !parent.moveLeft 
													&& !parent.moveRight 
													&& !parent.moveUp 
													&& !parent.moveDown;
											}else{
											//npc	
												attackTolerance = parent.attackTolerance() && !parent.dirSwitch.forceAttackFrame ;
											
											}
											
										}else{
											
										}
										
										return  attackTolerance; //melee need attack tolerance
										
									}()){
									
										this.always = false;
										this.alreadyExecuted = true;
															   //VVV longrange movement
										/*if( !parent.rigBody && 
											!/piercingShoot|arrowRain/i.test( prop.frameSkill ) && 
											!parent.dirSwitch.forceAttackFrame ){
											parent.dirSwitch.reset()
											parent.dirSwitch.selectedFrame = prop.frameSkill;
											prop.callback();
										}else{ */
											parent.dirSwitch.prior.push({
												selectedFrame : prop.frameSkill,
												label : objectSkill.label,
												fn : prop.callback 
											});
										//}
									
									}
								
								}
									
								
							} 
						}
						
					};
					
					if( statParameters.mp > 0 ) statParameters.mp -= requireMp;
					else statParameters.mp = 0;
						
					switch( objectSkill.name ) {
						
						case "powerAgilityIII" :
						case "powerAgilityII" :
						case "powerAgility" :
							
							triggerSkillToIntervalList({
								isCustom : true,
								frameSkill : objectSkill.name,
								tick : 1,
								callback : function(){
									obj.initLoading();
									parent.cntActiveSkill.push( 
										new parent.powerAgility( parent, objectSkill )
									)
								}
							})
							
							break;
						
						
						case "powerDefeneseIII" :
						case "powerDefeneseII" : 
						case "powerDefenese" :
							
							triggerSkillToIntervalList({
								isCustom : true,
								frameSkill : objectSkill.name,
								tick : 1,
								callback : function(){
									obj.initLoading();
									parent.cntActiveSkill.push( 
										new parent.powerDefenese( parent, objectSkill )
									)
								}
							})
							
							break;
						
						case "abilitiesSteal" :
						case 'defenseSteal' :
						case 'bodyCharge' : 
						case 'massHealing' :
						case 'healing' :
						case 'earthShake' : 
						case "mindControl" :
						case "earthQuake" :
						case "teleport" :
						case 'growHowl' :
						case 'intimidation' :	
						case 'createRed' : 
						case 'createBlue' :  						
							
							triggerSkillToIntervalList({
								isCustom : true,
								frameSkill : objectSkill.name,
								tick : 1,
								callback : function(){
									
									obj.initLoading();
									parent.cntActiveSkill.push( 
										new parent[  objectSkill.name ]( parent, objectSkill )
									)
								}
							})
							
							break;
						
						case "beresekYeti" :
							
							triggerSkillToIntervalList({
								isCustom : true,
								frameSkill : "beresekYeti",
								tick : 1,
								callback : function(){
									obj.initLoading();
									parent.cntActiveSkill.push( 
										new parent.bereseker( parent, objectSkill )
									)
								}
							})
							
							break;
							
						
						case "sekletonSummoner" :	
						case "golemSummoner" :
							
							triggerSkillToIntervalList({
								isCustom : true,
								frameSkill : objectSkill.name,
								tick : 1,
								callback : function( objInterval ){
									var enemy = parent.characterState ? parent.monsterParameters.object : parent.character;
									
									obj.initLoading();
									parent.cntActiveSkill.push( 
										new parent.summoning( parent, enemy, objectSkill  )
									)
								}
							})
							
							break;
			  
						case 'bindingRoot' :
						
							triggerSkillToIntervalList({
								isCustom : true,
								frameSkill : "bindingRoot",
								tick : 1,
								callback : function(){ 
									var enemy = parent.characterState ? parent.monsterParameters.object : parent.character;
																				
									obj.initLoading();
									parent.cntActiveSkill.push( 
										new parent.bindingRoot( parent, enemy, objectSkill )
									)
									
								}
							})
							
							break;	
						 
						
						case 'piercingSword' :
						case 'piercingSpeed' : 
						case 'piercingSpear' :
							
							triggerSkillToIntervalList({
								isCustom : true,
								frameSkill : objectSkill.name,
								tick : 1,
								callback : function( objInterval ){
									
									obj.initLoading();
									parent.cntActiveSkill.push( 
										new parent.piercingObject( parent, objectSkill )
									)
								
								}
							})	
						
							break;
							
						case 'bloodDrain' :
							
							parent.cntActiveSkill.push( 
								new parent.bloodDrain( parent.object, objectSkill ) 
							)
						
							obj.initLoading()
							
							break;
						 	
							
						case "teleportation" :
							
							triggerSkillToIntervalList({
								isCustom : "customExecute",
								frameSkill : "teleportation",
								tick : 1,
								callback : function(  objInterval  ){
									
									if( !objInterval.alreadyExecuted ){
										
										if( parent.object.opacity > 0 ){
											parent.dirSwitch.firstDirMove = 3;//freeze @AI.performAttackFrame  prevent stateStorage changing to walk
											scope[ parent.object.stateStorage ].set( parent.object.label, 'teleportation' );
									
											parent.object.opacity -= 0.09;
											if( parent.object.opacity  < 0 ){
												parent.object.opacity = 0;
											}
										}
										
										if( parent.object.opacity  <= 0 ){
											
											var enemy = parent.characterState ? parent.monsterParameters.object : parent.character;
											
											parent.dirSwitch.firstDirMove = 0; //reset
											obj.initLoading();
											parent.cntActiveSkill.push( 
												new parent.teleportation( parent.object, enemy, "approching" )
											)
											objInterval.always = false;
											objInterval.alreadyExecuted = true;
											objInterval.tick = 0;
										}
										
									}
								}
							})	
							
							
							break;
				  
						case 'arrowRain' : 
						
							triggerSkillToIntervalList({
								isCustom : false,
								frameSkill : "arrowRain",
								tick : 30,
								callback : function(){
									obj.initLoading();
									
									var enemy = parent.characterState ? parent.monsterParameters.object : parent.character;
									
									parent.cntActiveSkill.push( 
										new parent.arrowRain( enemy, objectSkill )
									)
								}
							})	
							
							break;
						
						case 'sliceAttack' :  
							triggerSkillToIntervalList({
								isCustom : false,
								frameSkill : "sliceAttack",
								tick : 30,
								callback : function(){
									obj.initLoading();
									parent.dirSwitch.forceAttackFrame = true;
									parent.cntActiveSkill.push( 
										new parent.sliceAttack( parent, objectSkill ) 
									)
								}
							})	
							
							break;
							
						case 'rollingAttack' : 
							triggerSkillToIntervalList({
								isCustom : false,
								frameSkill : "rollingAttack",
								tick : 30,
								callback : function(){
									obj.initLoading();
									parent.dirSwitch.forceAttackFrame = true;
									parent.cntActiveSkill.push( 
										new parent.rollingAttack( parent, objectSkill ) 
									)
									
								}
							})	
						
							break;
							
						case "upperAttack" : 
							triggerSkillToIntervalList({
								isCustom : false,
								frameSkill : "upperAttack",
								tick : 30,
								callback : function(){
									obj.initLoading();
									parent.dirSwitch.forceAttackFrame = true;
									parent.cntActiveSkill.push( 
										new parent.upperAttack( parent, objectSkill ) 
									)
								}
							})	
						
							break;
							
						case "throwBoom" : 
						
							var statParams = parent.object.statParameters;
							
							triggerSkillToIntervalList({
								isCustom : true,
								frameSkill : "throwBoom",
								tick : 1,
								conditional : function(){
									
									if( parent.attackTolerance() && parent.dirSwitch.tempTarget.isSpotted ){
									
										var mainCharacter = statParams.mainCharacter,
										pass =  true;
										
										if( mainCharacter ){
											var execute =  ( !parent.moveLeft && !parent.moveRight && !parent.moveUp && !parent.moveDown ),
											pass = parent.attackTolerance() && execute;
											execute && pass && parent.dirSwitch.reset();
										}
										
										return pass;
									}else{
										return false;
									}
								},
								callback : function(){
									
									parent.cntActiveSkill.push( 
										new parent.throwBoom( parent, objectSkill )
									)
									
									obj.initLoading();
								}
							})
							break;
							
						case "piercingShoot" :
							triggerSkillToIntervalList({
								isCustom : false,
								frameSkill : "piercingShoot",
								tick : 30,
								callback : function(){
									obj.initLoading();
								}
							})	
							break;	
					} 
				}
			}
			
			this.updateRegisterSkillFn = function(){
				var cnt = this.cntActiveSkill,
				len = cnt.length;
				
				if( len ){
					for(var ii = 0; ii < len ; ii++){
						var skill = cnt[ii];
						if( skill && skill.update( this ) ){
							cnt.splice( ii, 1 );
						}
					}
				}
			} 
		
		};
		
		//player only
		this.AI.playerProperies = function(){
			
			this.specialItems = new function(){
				
				this.cntItem = [];
				this.updateRegisterItemFn = function(){
					var cnt = this.cntItem
					len = cnt.length;
					
					if( len ){
						for(var ii = 0; ii < len ; ii++){
							var item = cnt[ii];
							if( item && item.update() ){
								cnt.splice( ii, 1 );
							}
						}
					}
				} 
				this.register = function( object, itemProp ){
				
					var parent = this, 
					rigBody = object.rigBody,
					objItem = {
						forceSelectedFrame : function( rigBody, selectedFrame, selecteStorage ){
							rigBody.dirSwitch.firstDirMove = 3;
							rigBody.dirSwitch.forceAttackFrame = true;
							rigBody.dirSwitch.selectedFrame = selectedFrame;
							
							selecteStorage && scope[ rigBody.object.stateStorage ].set( rigBody.object.label, selecteStorage );
						 
						},
						registerToIntervalList : function( prop ){
								
							parent.cntItem.push({
								always : true,
								tick : 1, 
								tickEnd : prop.tickEnd,
								update : function(){
									 
									prop.callback();
									
									this.tick++;
									if( this.tick >= this.tickEnd ){
										return true
									}
								} 
							})
							
						}
					}
					
					switch( itemProp.name ){

						case "sekletonSummoner" : 
						case "golemSummoner" : 
							 
							var initialParams = itemProp.initialParams,
							particle = {};
							
							if( object.pions.length < initialParams.maximumPawns ){
								
								object.visible && scope.playAudio("spawn");
								 
								initialParams.aIParent = rigBody.initialSpawn;
								initialParams.spawn.x = object.position.x + scope.random( 250, -250 );
								initialParams.spawn.y = object.position.y + scope.random( 100, -100 );
								initialParams.objBoss = object;
								initialParams.visible = true;
								initialParams.objPawns = [];
								
								scope.monsterControl.createAINpc( initialParams );
								
								scope.orderObjectFn['value']()
								
								scope.extend( particle, new scope.createGlowParticle(  itemProp.initialParams , itemProp.life ), true );
								
								initialParams.objPawns.forEach(function( obj ){
									//force to attack to prevent idle onload
									obj.rigBody.forceObjectToAttack( object );
									
									obj.rigBody.enemyPass = itemProp.name;
								})
								
								
								scope.glowEffect({
									object : object,
									parent : "",
									alpha : true,
									life : 25,
									scaleSpeed : 4
								})
								
								objItem.registerToIntervalList({ 
									tickEnd : itemProp.life,
									tickSpawn : itemProp.spawnTick,
									callback : function(  ){
										
										if( this.tickSpawn ){
											 
											initialParams.objPawns.forEach(function( obj ){
												objItem.forceSelectedFrame( obj.rigBody, "summon", "summon" );
											})
											
											if( this.tickSpawn === 1 ){
												initialParams.objPawns.forEach(function( obj ){
													obj.rigBody.behaveRandomFn(1);
												})
											}
											
											this.tickSpawn--;
										}
										
										
										if( particle.draw() ){ 
										
											initialParams.objPawns.forEach(function( obj ){
												obj.rigBody.dirSwitch.reset()
												obj.rigBody.dirSwitch.selectedFrame = "normal";
											}); 
											
											initialParams.objPawns.length = 0
											
										}
										
									}
								})
							  
								itemProp.quantity--;
							
							
								//update monsterProp if the leader have a special item
								scope.globalObjectGUI["value"].autoUpdateEffectItemLeader();
							
							}else{
								
								scope.pushMsgText['value']( owlData.lang.fn( "gui", "pawnLimit", "detail" ) , 100 );
							}
										 
						break;
					}
				}
			
			}
		}
		 
		this.AI.pathFinding = function(){
			this.initialPathFinding = new function(){ 
				this.reset = function(){
					this.pos.x = 0;
					this.pos.y = 0;
					this.tick = 2;
				}
				this.temp = {
					x : 0, y : 0
				};
				this.pos = {
					x : 0, y : 0
				}
				this.state = false;
				this.getPath = false;
				this.tick = 2;
				this.tolerance = 2;
				this.globalTranslate = new scope.objGlobalTranslate;
				
				this.update =  function( x, y ){
					
					var pos = this.pos;
					
					this.globalTranslate.reverse( pos )
					
					this.tick--;
					if( this.tick < 0 ){
						
						var temp = this.temp, initX, initY, tesX, tesY, tolerance = this.tolerance ;
						
						initX = Math.abs(  this.temp.x - Math.abs( x + pos.x ) );
						initY = Math.abs(  this.temp.y - Math.abs( y + pos.y ) );
						
						tesX = Math.abs( x + pos.x );
						tesY = Math.abs( y + pos.y );
						
						
						if( initX < tolerance &&  initY < tolerance ){
							this.getPath  = 0;
							this.state = true;
							return true;
						}
						
						this.temp.x = tesX;
						this.temp.y = tesY;
						
						this.tick = 2;
					}
					this.state = false;
					return false;
				}
			}
			
		}
		
		this.AI.setVertiecsByPoint = function(){
		
			this.position = {
				center : '',
				previousVerts : [],
				wholeVerts : []
			}
			
			
			this.getPosition = function( cPoint, nVec ){
				
				var cPointX = Math.round( cPoint.x ),
				cPointY = Math.round( cPoint.y ),
				xVec = Math.round( nVec.x ),
				yVec = Math.round( nVec.y );
				
				
				//devide vertec by position
				if( cPointX === xVec && cPointY > yVec ){ // top
				
					return "top";
					
				}else if( cPointX < xVec && cPointY > yVec ){ // rightTop
					
					return "rightTop";
					
				}else if( cPointX < xVec && cPointY === yVec ){ // right
					
					return "right";
					
				}else if( cPointX < xVec && cPointY < yVec ){ // rightBottom
					
					return "rightBottom";
					
				}else if( cPointX === xVec && cPointY < yVec ){ // Bottom
					
					return "Bottom";
					
				}else if( cPointX > xVec && cPointY < yVec ){ // leftBottom
					
					return "leftBottom";
					
				}else if( cPointX > xVec && cPointY === yVec ){ // left
					
					return "left";
					
				}else if( cPointX > xVec && cPointY > yVec ){ // leftTop
					
					return "leftTop";
					
				}
				
				
			}
			
			this.setPosition = function( cPoint, nVec ){
				
				var outterWall = scope.staticWallOutter['value'](),
				yMin = outterWall[0].bounds.max.y, // top
				yMax = outterWall[1].bounds.min.y, // bottom
				xMax = outterWall[2].bounds.min.x, // right
				xMin = outterWall[3].bounds.max.x; // left
				 
				if( nVec.y > yMin && nVec.y < yMax && nVec.x < xMax  && nVec.x > xMin  ){
					nVec.innerWall = true
				}else{
					nVec.innerWall = false;
				}
				
				switch ( this.getPosition( cPoint, nVec ) ) {
					case "top" : nVec.positionByCenter = "top"; break;
					case "rightTop" : nVec.positionByCenter = "rightTop"; break;
					case "right" : nVec.positionByCenter = "right" ; break;
					case "rightBottom" : nVec.positionByCenter = "rightBottom"; break;
					case "bottom" : nVec.positionByCenter = "bottom"; break;
					case "leftBottom": nVec.positionByCenter = "leftBottom"; break;
					case "left" : nVec.positionByCenter = "left"; break;
					case "leftTop" : nVec.positionByCenter = "leftTop"; break;
				}
				
				var pass = false;
				for( var ii = 0, jj = this.position.wholeVerts; ii < jj.length; ii++ ){
					if( Math.floor( jj[ii].x ) === Math.floor( nVec.x )
						&& Math.floor( jj[ii].y ) === Math.floor( nVec.y )){
						pass = true;
					}
				}
				
				this.position.center = cPoint;
				!pass && this.position.wholeVerts.push( nVec )
				
				
				
			}
			
			this.createDirBlock = function ( options ){
				this.install = true;
				this.tick =  scope.random( 300, 150 );
				this.reset = function(){
					this.tick = scope.random( 300, 150 );
					this.state = false;
					this.sortedVerts.length = 0;
					this.rangeProp.dummyState = false;
					this.previousVertex = "";
					//long range only
					var tempTarget = this.object.rigBody.dirSwitch.tempTarget ;
					tempTarget.init = true;
					tempTarget.position.x = this.object.position.x;
					tempTarget.position.y =  this.object.position.y;
				}
				this.sortedVerts = options.sortedVerts;
				this.sortedVertsAlternate = options.sortedVertsAlternate;
				this.object = options.target;
				this.previousVertex = "";
				this.changeDir = function( target, destination ){
					
					if( destination ){
						var posX = Math.round( target.x - destination.x );
					}else if( this.previousVertex ){
						var posX = Math.round( target.x - this.previousVertex[0].x );
					}else{
						var posX = Math.round( target.x - this.object.position.x );
					}	
					
					if( posX > 0 ) {
						setTimeout( function(){
							this.object.rigBody.changeRightFn( true );
						}.bind(this), 2 )
					}else{
						setTimeout( function(){
							this.object.rigBody.changeLeftFn( true );
						}.bind(this), 2 )
					}
				}
					
				this.storedDir = { prev : "" }
				this.dir = function( vert ){
					
					if( this.storedDir.prev !== vert.indexGl ){
						
						
						if( !vert.innerWall ){
							this.sortedVerts = this.sortedVertsAlternate; // swap when object counter vert innerWall
						}
						
						
						//this.scale.fn( vert );
						this.changeDir( vert );
						this.storedDir.prev = vert.indexGl;
					
					}
				
				};
				this.state = true;
				this.scale = {
					center : options.center,
					x : 0,
					y : 0,
					sub : function(vectorA, vectorB ) {
						var output = {};
						output.x = vectorA.x - vectorB.x;
						output.y = vectorA.y - vectorB.y;
						return output;
					},
					fn : function( vertex ){
						var center = this.center,
						dummyCenter = {
							x : center.x,
							y : center.y,
						},
						dummyVert = {
							x : vertex.x,
							y : vertex.y,
						},
						scaleX = scaleY = 2,
						delta = this.sub( vertex, center );
						this.x = center.x + delta.x * scaleX;
						this.y = center.y + delta.y * scaleY;
						
						
						var tempX = this.x - vertex.x,
						tempY = this.y - vertex.y;
						
						tempX =  tempX > 70 ? 70 : tempX < -70 ? -70 : tempX;
						tempY =  tempY > 70 ? 70 : tempY < -70 ? -70 : tempY;
						
						this.x = tempX ;
						this.y = tempY;
						
						
					}
				} 
				this.targetDummy = { position : {} };
				this.rangeProp = {
					dummyState : false,
					state : false,
					destEnd : ""
				};
				this.fn = function( isAttacking ){
					var object = this.object,
					objPos = object.position,		
					rigBody = object.rigBody,
					targetDummy = this.targetDummy,			
					statePathFinding = rigBody.initialPathFinding,	
					vertLen = this.sortedVerts.length,
					pass = true;
					
					//improve preceptions
					if( this.tick ){
						this.tick--;
					}else{
						vertLen = this.sortedVerts.length = 0;
					}
					
					
					statePathFinding.update( objPos.x, objPos.y );
					
					if( statePathFinding.state ){
						pass = false;
					}
					
					if( vertLen  ){ //&& !statePathFinding.state
						
						if( pass ){
							
							var vert = this.sortedVerts[0],
							speed = Math.abs( rigBody.moveSpeed );
							
							this.dir( vert );
							
							targetDummy.position.x = vert.x;
							targetDummy.position.y = vert.y ;
							
							var vec = scope.moveVector2dWithVelocity( object, targetDummy, speed );
							
							vec.x = isNaN( vec.x ) ? 0 : vec.x;
							vec.y = isNaN( vec.y ) ? 0 : vec.y;
							
							scope.Body.setPosition( object, 
								{ x :  objPos.x +  vec.x  ,
								 y :  objPos.y +  vec.y ,									
							})
							
							if( vec.distance < 10 ){
								this.previousVertex = this.sortedVerts.splice( 0 , 1 );
							}
							
							//tell attackBehaviour when dirBlock is active
							this.state = true;
							
							//state for long-range
							if( this.rangeProp.dummyState ){
								
								var targetPos = this.rangeProp.destEnd.position;
								
								//update object's tempTarget/targetDummy it will be executed at AI.attackBehaviour
								rigBody.dirSwitch.tempTarget.position.x = objPos.x;
								rigBody.dirSwitch.tempTarget.position.y = objPos.y;
								
							}
							
							return {
								init : false,
								x : vec.x,
								y : vec.y 
							};
							
						}else{
							var vec = {}
							vec.x = 0;
							vec.y = 0;
							
							// update path finding
							statePathFinding.reset();
							// reset dirBlock
							this.reset();
							
						}
						
						return {
							init : false,
							x : 0,
							y : 0
						};
						
						
					
					}else{
						
						//rigid
						if( rigBody.behave === "attack" ){
							this.changeDir( rigBody.character.position, this.object.position )
						}else if( this.object.statParameters.mainCharacter ){
							this.changeDir( rigBody.monsterParameters.object.position, this.object.position )
						}
						
						// update path finding
						statePathFinding.reset();
						// reset dirBlock
						this.reset();
						
						return  {
							init : false,
							x : 0,
							y : 0
						};
					
					}
				}
			}
			 
			this.path = function(){
				this.pointA = [];
				this.pointB = [];
				this.distanceA = 0;
				this.distanceB = 0;
			};
			
			this.generatePreviousVertices = function( selectedVertices ){
				
				this.position.previousVerts = [];
				
				for(var ii = 0, jj = selectedVertices, len = jj.length; ii < len; ii++ ){
					this.position.previousVerts.push( jj[ii].indexGl )
				}
			}
			
			this.isPreviousVertices = function( selectedVertices ){
				
				var previousVertices = this.position.previousVerts;
				
				
				if( previousVertices.length === selectedVertices.length ){
					var count = 0;
					for(var ii = 0, jj = selectedVertices, len = jj.length; ii < len; ii++ ){
						self : for(var kk = 0, ll = previousVertices, lenB = ll.length; kk < lenB; kk++ ){
							if( jj[ii].indexGl === ll[kk] ){
								count++;
								break self;
							}
						}
					}
					
					if( count === selectedVertices.length ){
						return true;
					}
					
				}
				
				return false;
				
			};
			
			this.generatePath = function( options, target ){
										
				var path = new this.path,
				wholeVerts = this.position.wholeVerts,
				 
				//sorting vertices position by target
				sortedVerts = scope.AI.sortestEnemy( wholeVerts, options.targetPosition ),
				
				destinationPoint = options.destinationPoint,
				
				pointA = sortedVerts[0];
				pointB = sortedVerts[1];
				
				self : for(var ii = pointA.indexGl, 
					jj = wholeVerts.length, 
					kk = 0, 
					statePointA = false;  ii < jj ;  ii++ ){
						
					var vect = wholeVerts[ii];
						
						if( destinationPoint.indexGl !== vect.indexGl && !statePointA ){
							path.pointA.push( vect )
							
						}else if( destinationPoint.indexGl !== vect.indexGl){
							
							path.pointB.push( vect )
							
						}else{
							
							statePointA = true;
						}
					
					
					if( kk + pointA.indexGl === jj - 1 ){
						for( var ll = 0, len = pointA.indexGl; ll < len ; ll++){
							var vect = wholeVerts[ll];
						
							if( destinationPoint.indexGl !== vect.indexGl && !statePointA ){
								
								path.pointA.push( vect )
								
							}else if( destinationPoint.indexGl !== vect.indexGl ){
								
								path.pointB.push( vect )
								
							}else{
								
								statePointA = true;
							}
							
						}
					}
					
					
					kk++
					
				}
				
				path.pointB.reverse() // need reversed it is used to track left dir
				
				// if path point is empty push destinationPoint
				if( path.pointA.length <= 1 ) path.pointA = [ destinationPoint ];
				else path.pointA.push( destinationPoint );
				
				if( path.pointB.length <= 1 ) path.pointB = [ destinationPoint ];
				else path.pointB.push( destinationPoint );
				
				
				return path;
				
			}
			
			this.generateDistance = function( path, pathPoint, pathDistance ){
					
				
				//track distance for both path
				
				for( var ii = 0, jj = path[ pathPoint ], len = jj.length; ii < len; ii++ ){
				
					if( jj[ ii + 1 ] ) {
						
						path[ pathDistance ]  +=  scope.distanceAndAngleBetweenTwoPoints( jj[ii].x, jj[ii].y, jj[ ii + 1 ].x, jj[ ii + 1 ].y ).distance;
					
					}
					
				}
				
				
			}
			
			this.removeVertexNotNeighbor = function( path, options ){
			
				var notNeighbor = function( vertexA, vertexB ){
					var test = Math.abs( vertexA.indexGl - vertexB.indexGl );
					return test > 1 || test < 1; // pass 0 and  > 1
				};
				
				for(var ii = 0, jj =path; ii < jj.length ; ii++ ){
					
					
					if( path.length >= 2 ){
							
						var p = jj[ ii + 1 ] ? jj[ ii + 1 ] : jj[ 0 ],
						m = jj[ ii - 1 ] ? jj[ ii - 1 ] : jj[ path.length - 1 ];
						
						if(  notNeighbor( jj[ii], p ) && notNeighbor( jj[ii], m ) ){
							
							if( path.length > 2 ) {
									
								jj.splice( ii, 1 );
								
							}else {
								
								var destPoint = options.destinationPoint,
								
								pPoint = Math.abs( scope.distanceAndAngleBetweenTwoPoints( p.x, p.y, destPoint.x, destPoint.y ).distance ),
								mPoint = Math.abs( scope.distanceAndAngleBetweenTwoPoints( m.x, m.y, destPoint.x, destPoint.y ).distance )
								
								indexRemove = pPoint > mPoint ? p.indexGl : m.indexGl;
								
								jj.splice( indexRemove, 0 );
							}
						}
					}
					
				}
				
			}
			
			this.removeVerticesWhenTooFarFromTarget = function( path, options ){
				if( path.length > 1 ){
					for(var ii = 0; ii <  path.length ;  ii++ ){
						
						var destPost = options.targetDestinationPos,
						targetTovertex = Math.abs( scope.distanceAndAngleBetweenTwoPoints( path[ii].x, path[ii].y, destPost.x, destPost.y ).distance ),
						targetToDestinationPoint = Math.abs( scope.distanceAndAngleBetweenTwoPoints( options.targetPosition.x, options.targetPosition.y, destPost.x, destPost.y ).distance )
						
						if( targetTovertex > targetToDestinationPoint ){
							path.splice( ii, 1 );
							
						}
					}
					
					
				}
				return path
			}
			
			this.createRandDestinationVertexByDir =  function( options ){
				
				var vertsByPosition = {
					right : [],
					left : []
				};
				for(var ii = 0, jj = this.position.wholeVerts, kk = jj.length ; ii < kk ; ii++ ){
					
					if( jj[ii].positionByCenter.indexOf( "right" ) !== -1 ){
						vertsByPosition.right.push( jj[ii] )
					}else{
						vertsByPosition.left.push( jj[ii] )
					}
				}
				
				var verticesByDir = vertsByPosition[ options.objectDir ];
				
				if( verticesByDir ){
					return verticesByDir[ scope.random( verticesByDir.length - 1, 0 ) ];
				}else{
					return false
				}
			}
			
			this.getTargetByRandDestPoint = function( target ){
				var rigBody = target.rigBody,
				targetDir = rigBody.turn ? rigBody.turn : rigBody.latestDir,
				wholeVerts = this.position.wholeVerts,
				sortedVerts = scope.AI.sortestEnemy( wholeVerts, target.position ),
				targetPosition = sortedVerts[0],
				destinationPoint = this.createRandDestinationVertexByDir({
					objectDir : targetDir
				})
				
				
				
				if( /hero/i.test( target.label ) ){
					//console.log( rigBody.latestDir )
				}
				
				
				var path = this.generatePath({
					targetPosition : targetPosition,
					destinationPoint : destinationPoint
				}, true ) 
				
				//remove unexpected vertex
				this.removeVertexNotNeighbor( path.pointA, { destinationPoint : destinationPoint } );
				this.removeVertexNotNeighbor( path.pointB, { destinationPoint : destinationPoint } );
				
				
				//generate distance
				this.generateDistance( path, "pointA", "distanceA" )
				this.generateDistance( path, "pointB", "distanceB" )
				
				
				var pathTarget = path.distanceA < path.distanceB ? "pointA" : "pointB";
				
				/*
				selectedVertices = this.removeVerticesWhenTooFarFromTarget( path[ pathTarget ], {
					targetPosition : targetPosition,
					targetDestinationPos : destinationPoint,
				})*/
				
				var selectedVertices = path[ pathTarget ],
				sortedVerticesAlternate = path[ pathTarget === "pointA" ? "pointB" : "pointA" ],
				dirSwitch = rigBody.dirSwitch;
				
				/*
				if( this.isPreviousVertices( selectedVertices ) ){
					selectedVertices = path[ pathTarget === "pointA" ? "pointB" : "pointA"]; //swap
				}
					
				this.generatePreviousVertices( selectedVertices );
				*/
				
				rigBody.turnState = scope.random( 300, 100 );
				
				if ( !dirSwitch.dirBlock.install ){
					//replace dirBlock dummy 
					dirSwitch.dirBlock = new this.createDirBlock({
						sortedVerts : selectedVertices,
						sortedVertsAlternate : sortedVerticesAlternate,
						target : target,
						center : this.position.center
					});
					
				}else{
					dirSwitch.dirBlock.sortedVerts = selectedVertices;
					dirSwitch.dirBlock.sortedVertsAlternate = sortedVerticesAlternate;
					dirSwitch.dirBlock.target = target;
					dirSwitch.dirBlock.state = true;
					dirSwitch.dirBlock.previousVertex = "";
					dirSwitch.dirBlock.tick = scope.random( 300, 150 );
				}
				
				
			}
			
			this.getTarget = function( target, reArrangeVert ){
				
				var targetPosition = reArrangeVert ? target : target.position,
				
				//vertsDir = this.getPosition( this.position.center, target.position ),
				//vertsPosition = this.position[ vertsDir ],
				targetDestinationPos = reArrangeVert ? reArrangeVert : target.rigBody.behave === "attack" 
					? target.rigBody.character.position : target.rigBody.pointMove.position, // left / right;
				wholeVerts = this.position.wholeVerts,
				
				//sorting vertices position by target's destination
				destinationPoint =  reArrangeVert ? reArrangeVert : scope.AI.sortestEnemy( wholeVerts, targetDestinationPos )[0];
				
				//find the shortest ways to target to find the destination point
				var path = this.generatePath({
					targetPosition : targetPosition,
					destinationPoint : destinationPoint
				}, target ) 
				
				//remove unexpected vertex
				this.removeVertexNotNeighbor( path.pointA, { destinationPoint : destinationPoint } );
				this.removeVertexNotNeighbor( path.pointB, { destinationPoint : destinationPoint } );
				
				
				//generate distance
				this.generateDistance( path, "pointA", "distanceA" );
				this.generateDistance( path, "pointB", "distanceB" );
				
				
				
				var pathTarget = path.distanceA < path.distanceB ? "pointA" : "pointB",
				selectedVertices = path[ pathTarget ],
				sortedVerticesAlternate = path[ pathTarget === "pointA" ? "pointB" : "pointA" ];
				
				
				//console.log( path.pointA )
				//console.log( path.pointB )
				//console.log( pathTarget )
				
				//console.log( selectedVertices )
				
				
				//update dirBlock
				if( !reArrangeVert ){
					var dirSwitch = target.rigBody.dirSwitch,
					rangeProp = dirSwitch.dirBlock.rangeProp;
				}
				
				//long-range only // rearrange when end target > dest target
				if( !reArrangeVert && target.rigBody.monsterParameters.attackType === "long-range"){
					
					var end = selectedVertices[ selectedVertices.length - 1 ];
					
					
					if( !rangeProp.state  ){
						
						if( end.y > targetDestinationPos.y ){
							
							rangeProp.dummyState = rangeProp.state = true;
							
							rangeProp.destEnd = target.rigBody.character;
							
							
							var destPoint = wholeVerts[ scope.AI.boundVertexToIndex( wholeVerts ).min.y ];
							
							var temp = this.getTarget( end , destPoint );
							
							selectedVertices =   selectedVertices.concat( temp ) ;
							
							this.removeVertexNotNeighbor( selectedVertices, { destinationPoint : destinationPoint } )
							
						}
					}
					
					
					rangeProp.state = false;
					
				} else {
					// improve path finding preceptions only for melee movement
					//remove vertices from path if too far from target
					var selectedVertices = this.removeVerticesWhenTooFarFromTarget( selectedVertices, {
						targetPosition : targetPosition,
						targetDestinationPos : targetDestinationPos,
					})
					
					var sortedVerticesAlternate = this.removeVerticesWhenTooFarFromTarget( sortedVerticesAlternate, {
						targetPosition : targetPosition,
						targetDestinationPos : targetDestinationPos,
					})
					
				
				}
				
				
				
				if( !reArrangeVert ){
					
					/*
					//improve preceptions if seleceted vertices were failed then swap
					if( this.isPreviousVertices( selectedVertices ) ){
						selectedVertices = path[ pathTarget === "pointA" ? "pointB" : "pointA"]; //swap
					}
						
					this.generatePreviousVertices( selectedVertices ); */
					
					
					
					if ( !dirSwitch.dirBlock.install ){
						//replace dirBlock dummy 
						dirSwitch.dirBlock = new this.createDirBlock({
							sortedVerts : selectedVertices,
							sortedVertsAlternate : sortedVerticesAlternate,
							target : target,
							center : this.position.center
						});
						
					}else{
						dirSwitch.dirBlock.sortedVerts = selectedVertices;
						dirSwitch.dirBlock.sortedVertsAlternate = sortedVerticesAlternate;
						dirSwitch.dirBlock.target = target;
						dirSwitch.dirBlock.state = true;
						dirSwitch.dirBlock.previousVertex = "";
						dirSwitch.dirBlock.tick = scope.random( 300, 150 );
					}
				
				}else{
					return selectedVertices;
				}
				
				
			}
		}
		
		this.AI.boundVertexToIndex = function( vertices ){
			
			var tempX = [], 
			tempY = [],
			bound = { max : {}, min : {} } ;
			
			for( var m = 0; m < vertices.length ; m++ ){
				tempX.push( vertices[m].x )
				tempY.push( vertices[m].y )
			}
			
			tempX.sort( function( a, b ){return a - b } );
			tempY.sort( function( a, b ){return a - b } );
			
			//to calculate match point between Matter.Body and origin vertices
			for( var n = 0; n < vertices.length ; n++ ){
				
				if( tempX[ tempX.length - 1 ] === vertices[n].x ){
					//n is farthest of origin x point of vertices
					bound.max.x = n;
				}
				
				if( tempX[ 0 ] === vertices[n].x ){
					//n is shortest of origin x point of vertices
					bound.min.x = n;
				}
				
				if( tempY[ tempY.length - 1 ] === vertices[n].y ){
					//n is shortest of origin y point of vertices
					bound.max.y = n;
				}
				
				if( tempY[ 0 ] === vertices[n].y ){
					//n is shortest of origin y point of vertices
					bound.min.y = n;
				}
				
			}
			
			return bound;
			
		}
		
		this.AI.verticesTail = function( object ){
			this.objectPos = object.position;
			this.tail = [];
			this.updateTailTick = 15;
			this.update = function(){
				var tail = this.tail,
				push = true;
				
				if( this.updateTailTick ){
					this.updateTailTick--;
					push = false;
				}else{
					this.updateTailTick = 15;
				}
				
				if( push ){
					if( tail.length > 9 ){
						tail.pop()
						tail.unshift({
							x : this.objectPos.x,
							y : this.objectPos.y
						})
						
					}else{
						tail.push({
							x : this.objectPos.x,
							y : this.objectPos.y
						})
					}
				}
				
				
			}
			
		}
	
	}
	 			
	_owlBird.component = function() {
		
		var scope = this;
		this.components = {};
		this.components.monster = function() {
			this.objectGetDamage = function( damage, attacker, tempHealth  ){
				
				//hero gui
				if( this.cureSelf.gui ) this.cureSelf.updateBar( 'hp-inner-line-bar' );
				  
				if( tempHealth < 0 ){
					this.monsterParameters.health = 0;
				}else{
					this.monsterParameters.health -= damage;
				}
				
				//update turn state when attacker still attacking
				this.turnState = scope.random( 600, 500 );
			 
				
				if( this.dirSwitch.previousTarget !== attacker ){ 
					this.dirSwitch.dirBlock.reset(); 
					this.dirSwitch.previousTarget = attacker; 
				}
				
				// hitter is boss 
				if( attacker !== this.boss.label){
					this.partyRandomHelp.update( this )
					this.hitterNotTarget( attacker )
					return true;
				}else{
					return false;
				}
			}
			this.healthBar =  {
				opacity : 0,
				tickUpdate : 100,
				tick : 0,
				hpTick : 0,
				staticDrawImage : scope.staticDrawImage["value"],
				update : function( gl, health, maxHealth, size, x, y ){
					
					if( this.tick > 0 ){
						
						
						if( this.tickUpdate === this.tick ){// hit indication
							 
							if( !this.health || this.health < health ){
							
									this.health = health;
							} 
							
						}
						 
						this.tick--;
						
						
						var staticDrawProp = this.staticDrawImage;
						 
						var draw = staticDrawProp.fn,
						width = staticDrawProp.hpMedTexture.textures.width,
						height =  staticDrawProp.hpMedTexture.textures.height;
						  
						if( this.tick  < 10 &&  this.opacity > 0 ){
							
							gl.useProgram( draw.glProp.program );
							gl.uniform1f( draw.glProp.alphaLocation, this.opacity -= 0.09 );
							
						}else if(  this.opacity < 0.9  ) {
							
							gl.useProgram( draw.glProp.program );
							gl.uniform1f( draw.glProp.alphaLocation, this.opacity += 0.09 );
						}
						 
						  
						draw.update({
							img : staticDrawProp.hpMedConver.textures,
							context : gl,
							ver : "v3",
							posX : 0,
							posY : 0,
							srcWidth : width, 
							srcHeight : height, 
							dstX : x - width / 2, 
							dstY : y - 20, 
							dstWidth : width, 
							dstHeight : height
							
						})
						
						
						var currentBar = Math.round( (  this.health / maxHealth ) * width ) ,
						textureBar = Math.round(  ( health / maxHealth ) * width ) ,
						dec = 40 + Math.round(  currentBar - textureBar  ) ;
						
						if( this.health >= health ){
							 this.health -= dec;
						}
						
						
						
						draw.update({
							img : staticDrawProp.hpMedTick.textures,
							context : gl,
							ver : "v3",
							posX : 0,
							posY : 0,
							srcWidth : width, 
							srcHeight : height, 
							dstX : x - width / 2, 
							dstY : y - 20, 
							dstWidth : currentBar, 
							dstHeight : height
							
						})
						
						
						draw.update({
							img : staticDrawProp.hpMedTexture.textures,
							context : gl,
							ver : "v3",
							posX : 0,
							posY : 0,
							srcWidth : width, 
							srcHeight : height, 
							dstX : x - width / 2, 
							dstY : y - 20, 
							dstWidth : textureBar, 
							dstHeight : height
							
						});
						
					}
					
				}
			}
			
			
			
			this.displayBar = function(){
				
				
				var object = this.object,
				healthBar = this.healthBar,
				additionalBoundsValue = object.additionalBoundsValue || 0 ;
					  
				object.visible && 
				!object.isHero && 
				healthBar.update(
						scope.context,
						this.monsterParameters.health,
						this.monsterParameters.maxHealth,
						this.hpSize ,
						object.position.x,
						object.bounds.min.y - additionalBoundsValue  )
			  
				if( object.monsterTarget ){
					 
					if( !this.installHealthGUI.state  ){
						this.monsterParameters.monsterLevel && this.installHealthGUI.fn( this.monsterParameters.name )
						this.installHealthGUI.state = true;
					};
					
					 healthBar.tick = healthBar.tickUpdate;
					
				}else if( this.installHealthGUI.state ){
					this.installHealthGUI.state = false;
				}
			}
			 
			this.stat = function( ){
					
				var damageParameters = this.monsterGetDamage;
				 
				if( damageParameters && damageParameters.length ){
					
					for( var ii = 0, jj = damageParameters.length ; ii < jj ; ii++)
					{	
						var objDmg = damageParameters[ii]
						attacker = objDmg && objDmg.attacker;
						if( this.monsterParameters.health && attacker && this.isEnemyFn( attacker ) ) { 
						 
							var damage = Math.round( damageParameters[ii].damage ),
							status =  damageParameters[ii].status,
							attackerAbilities =  damageParameters[ii].attackerAbilities,
							tempHealth = Math.round( this.monsterParameters.health ) - damage,
							attackerParameters = damageParameters[ii].attackerParameters,
							isVisible = this.object.visible;
							
							damageParameters.splice( ii, 1 );
							 
							var damageState = true,
							attackerLen = attackerAbilities.length,
							hitNumberState = true,
							hitNumberForStun = true;
							 
							var selfAbilities = this.attackerAbilities( this.monsterParameters  );
							
							for(var kk = 0, ll = selfAbilities.length; kk < ll ; kk++ ){
								if( selfAbilities[kk] === 'block' ){
									scope.playAudio('shiled-blocking')
									isVisible && this.hitNumber.push( new scope.hitNumber( 'block' ) );
									damageState = false
									hitNumberState = false;
									break;
								}else if( selfAbilities[kk] === 'avoid' ){
									isVisible && this.hitNumber.push( new scope.hitNumber( 'miss' ) );
									damageState = false
									hitNumberState = false;
									break;
								}
							}
							
							if( attackerLen && damageState ){
								for(var mm = 0, nn = attackerLen; mm < nn ; mm++ ){
									
									if( attackerAbilities[mm] === 'stun' ){
										hitNumberForStun = false;
										isVisible && this.hitNumber.push( new scope.hitNumber( 'stun' ) );
										this.stunEffect.fn( "short", this.object );
									} 
								}
							}
							
							
							//critical
							var criticalDamage = this.abilityCritical( attackerParameters, damage ),
							criticalState = ( criticalDamage > 0 );
							
							damage += criticalDamage;
							
							
							if( damageState && status === 'attack' && hitNumberState ){
								if( this.monsterParameters.classType === 'mage' ){
									damage = this.abilityMagicDefense( this.monsterParameters, damage );
								}else{
									damage = this.abilityDefense( this.monsterParameters, damage );
								}
								
								this.objectGetDamage( damage, attacker, tempHealth );
								
								if( isVisible ){
									
									var hitNum;
									
									if( criticalState ){
										hitNum = new scope.hitNumber( damage, "critical" );
									}else{
										
										this.healthBar.tick = this.healthBar.tickUpdate;
										 
										if( this.objTranslate.effect ){
											hitNum =  new scope.hitNumber( damage )
										}else{
									 
											hitNum =  this.object.isHero ? new scope.hitNumber( damage ) : "" ;
										}
									}

										
									if( hitNum && hitNumberForStun && hitNumberState ){
										
										this.hitNumber.push( hitNum )
										
										scope.hitEffect({
											object :  this.object,
											parent : "",
											alpha : true
										})
									}
									
									scope.playAudio(['stab']);
									
									
								}
								
							}
							
							if( !this.isStatic && !/attack|back/i.test( this.behave ) ){
								this.attacker = attacker;
								this.setTarget();
								
								//cleart dirBlock if needed 
								this.dirSwitch.dirBlock.reset();
								
								
							}
							
							if( attacker !== this.object.bossLabel && !/back/i.test( this.behave ) && !this.stunEffect.init ){
								//buffSkill
								
								this.buff.register({
									seletedBuff : attackerParameters.buffSkill,
									paramsTarget : this.monsterParameters,
									paramsAttacker : attackerParameters 
								})
								
								//if being hit is a boss
								if( this.pitboss ){
									this.object.attacker = this.attacker;
									this.object.needHelp = true;
								}
								
								//set help to all pions
								
								return true 
								
								
								
								
							}else{
								return false;
							}
						}else{
							damageParameters.length = 0;
						}
					}
				}
			
			}
			this.installHealthGUI = new function(){
				this.state = false;
				this.fn = function( name ){
					 
					scope.removeClass( scope.qs('monster-bar'), 'hidden' );
					var span = scope.qs("box-name-level").getElementsByTagName("span")[0];
					scope.text(span, name )
 
				}
			}
		}
		
		this.components.monsterDungeon = function( objParent ){ 
			this.remove = false;
			this.boss = '';
			this.rigState = true,
			this.pointMove = '';
			this.parentObject = '';
			this.character = scope.oval['value'];
			this.objTranslate = scope.objTranslate['value'];
			this.attacker = '';
			this.object = '';
			this.hpSize = 'medium';
			this.install = false;
			this.monsterAttribute = true;
			this.moveSpeed = 1; 
			this.moveIdle = 15;
			this.moveStrict = false;
			this.walkState = 100;
			this.idleAttackWalk = scope.random( 35, 5);
			this.rand = 0;
			this.randState = 0;
			this.behave = "walk";
			this.backRange = {
				state : false,
				x : 600,
				y : 300,
				normalX : 600,
				normalY : 300,
				backX : 300,
				backY : 150
			};
			this.backDelay = 25;
			this.behaveRandom = 10;
			this.behaveState = true;
			this.tick = 0; 
			this.dirSwitch = {
				prior : [],
				dirBlock : { state : false, sortedVerts : [], reset : function(){}, rangeProp : { state : false } },// dummy its used for path collide
				tickFrame : 0,
				forceAttackFrame : false,
				frameExtendCount : 0,
				frameCount : 0,
				firstDirMove : 0,
				previousTarget : '',
				attackDelay : 0,
				attackDelayPerFrame: 0,
				attackDelayPerFrameReplace : 28, // initialSpeedAttack
				approchingState : "walk",
				mainTurn : true,
				selectedFrame : "normal",
				turn : false, // collide outter wall
				targetDummyForMelee : {
					position : {
						x :0,
						y : 0 
					}
				},
				tempTarget : {
					position : {
						x : 0,
						y : 0
					},
					init : true
				},
				reset :function(){
					this.frameExtendCount = 0;
					this.frameCount = 0;
					this.tickFrame = 0;
					this.firstDirMove = 0;
					this.attackDelayPerFrame = 0;
					this.forceAttackFrame = false; 
				}
			}
			this.attackRangeX = 300;
			this.attackRangeY = -300;
			this.vector = { x : 0, y : 0 } // move forward
			this.turnState = -1;
			this.turn = 'right';
			this.hitNumber = [];
			this.stunEffect = { init : false }; //create dummy before it replaced by @component.objPropertyFn 
			this.objectPointing = {
				objTranslate : scope.objTranslate['value'],
				position :{
					x : 0,
					y : 0
				},
				translate : function(){
					if( this.objTranslate.staticObjStateX ){
						if( this.objTranslate.moveLeft ){
							this.position.x += this.objTranslate.staticObjMoveX;
						}else if( this.objTranslate.moveRight ){
							this.position.x += this.objTranslate.staticObjMoveX;
						}
					}
					

					if(  this.objTranslate.staticObjStateY ){
						if( this.objTranslate.moveUp ){
							this.position.y += this.objTranslate.staticObjMoveY;;
						}else if( this.objTranslate.moveDown ){
							this.position.y += -this.objTranslate.staticObjMoveY;;
						}
					}
					
				}
			}
			this.addSpeedForTurnAndWalk = function( vec, operators  ){

				var init = this.initialSpeedNormal, vMax, vMin, speed, moveSpeed ;
				
				
				if( vec === "x" ){
					vMax = init === "normal" ? 1.0 : init === "fast" ? 2.0 : 3.0; //extrafast, //x
					vMin = init === "normal" ? 0.8 : init === "fast" ? 1.0 : 2.0;
				}else{
					vMax = init === "normal" ? 0.9 : init === "fast" ? 1.5 : 2.5; //extrafast, //y
					vMin = init === "normal" ? 0.1 : init === "fast" ? 0.5 : 1.5;
				}
				
				
				
				var val = operators === "min" ? 
					-scope.randomFloat(  parseFloat( vMax ), parseFloat( vMin )  ) :
					scope.randomFloat(  parseFloat( vMax ), parseFloat( vMin )  )
				 
				return val;
			
			}
			this.addSpeed = function(){
				return  this.behave === 'attack' ? this.moveSpeedAttack : this.moveSpeedNormal;
			}
			this.monsterDir = function(){
				return this.character.position.x < this.object.position.x ? 'left' : 'right';
			};
			this.boundsWidthOperator = {
				left : 1,
				right : 1
			};
			this.changeLeftFn = function()
			{
				
				if( !this.dirSwitch.forceAttackFrame && this.monsterParameters.health ){ // stun effect came from @componen.stunEffect
					var  texture = this.object.initialName +'-left.png';
					this.turn = 'left';
					this.object.additionalBoundsWidthValue = this.boundsWidthOperator.left * Math.abs( this.object.additionalBoundsWidthValue );
					this.moveSpeed = -Math.abs( this.addSpeed() );
					scope[ this.object.stateStorage ].set( this.object.label, 'textureNeedChange|'+scope.path + texture );
				}
				
				
			};
			
			this.changeRightFn = function()
			{
				if( !this.dirSwitch.forceAttackFrame && this.monsterParameters.health   ){
					var texture = this.object.initialName +'-right.png';
					this.turn = 'right';
					this.object.additionalBoundsWidthValue = this.boundsWidthOperator.right * Math.abs( this.object.additionalBoundsWidthValue );
					this.moveSpeed = Math.abs( this.addSpeed() );
					scope[ this.object.stateStorage ].set( this.object.label, 'textureNeedChange|'+scope.path +  texture );		
				}
				
			};
			
			this.pathBack = []; 
			this.behaveRandomFn = function( state ){
				var randVal =  scope.random(1,0);
				randVal = ( state === 0 || state === 1 ) ? state : randVal;
				if( randVal === 0 ){
					this.object.behave = this.behave = 'walk';
					this.turnState = 0;
					scope[ this.object.stateStorage ].set( this.object.label, 'walk' );
					
				}else if(  randVal === 1 ) {
					this.turnState = scope.random( 200, 50 );
					this.object.behave = this.behave = 'idle';
					scope[ this.object.stateStorage ].set( this.object.label, 'idle' );
				}
				
				//boss only
				if( this.pitboss ){
					this.object.attacker = false;
					this.object.needHelp = false;
				}
				
				
				//cleart dirBlock if needed 
				this.dirSwitch.dirBlock.reset();
				
				this.behaveState = true;
				this.behaveRandom = scope.random( 15,10 );
				this.attackTick = 50;
				this.bugAttacker = false;
				
				this.attackTick = 0;
				this.idleAttackWalk = scope.random( 35, 5 );
				this.object.selected = false; // AI party
			};
			this.posCapture = {
				position : {
					x : 0,
					y : 0
				}
			};
			
			this.updateBossTickBack = false;
			this.updateIntervalBack = 600;
			this.loopDir = function( posX, pass ){
				
				if( !this.dirSwitch.dirBlock.state ){
					// setTimeout to prevent bug stateStorage was replaced by unknown
					if( posX > 0 ) {
						if( this.turn !== 'right' || pass ){
							setTimeout( function(){ 
								this.changeRightFn();
							}.bind(this),2 )
						}
					}else{
						if( this.turn !== 'left' || pass ){
							setTimeout( function(){
								this.changeLeftFn();
							}.bind(this),2 )
						}
					}
				
				}
			}

			this.backDir = function( allowX, allowY, moveToleranceX, moveToleranceY ){
				if( allowX < -moveToleranceX ){
					this.changeLeftFn()
					this.vector.x = -1
				}else if( allowX > moveToleranceX ){
					this.changeRightFn()
					this.vector.x = 1
				}
				if( allowY > moveToleranceY ){
					this.vector.y = 0.5
				}else if( allowY < -moveToleranceY ){
					this.vector.y = -0.5
				}
			}
			this.findBodies = function( target ){
				var bodies = scope.Composite.allBodies( scope.engine.world );
				for(var ii = 0, jj = bodies; ii < jj.length; ii++ ){
					if( jj[ii].label === target ){
						return jj[ii]
						break;
					}
				}
				return false;
			}
			this.AIParty = function( character ){
				if( this.behave !== 'attack' ){
					
					var enemyTarget
					// user
					if(  character.pions ){
						// if enemytarget is boss
						enemyTarget = [  character  ].concat(  character.pions );
					}else {
						// enemy target is pion
						var target =  this.findBodies(  character.bossLabel );
						if( target ){
							enemyTarget = [  character  ].concat(  target.pions );
						}else{
							enemyTarget = [  character  ]
						}
					}
				
					var sortestEnemy = scope.AI.sortestEnemy( enemyTarget, this.object );
				
					
					for(var ii = 0, jj = sortestEnemy; ii < jj.length ; ii ++ ){
						if( jj[ii].behave !== 'attack' && !jj[ii].selected ){
							jj[ii].selected = true;
							return jj[ii];
						}
					}
					
					
					var objectTarget = sortestEnemy[ scope.random( sortestEnemy.length - 1, 0) ];
					
					objectTarget.selected = true;
					
					return objectTarget;
					
				}
			}
			
			this.cntStateSkill = [];
			this.cntActiveSkill = [];
			
			this.skill = {
				parent : "",
				active : [],
				
				uniqueSkill : function( objSkill ){
						
					var enemy = this.parent.character,
					objectPos = this.parent.object.position,
					enemyPos = enemy.position,
					distance = scope.distanceAndAngleBetweenTwoPoints( objectPos.x, objectPos.y , enemyPos.x, enemyPos.y ).distance;
					
					switch ( objSkill.name ){
						case "piercingSpear" : state = ( distance < 250 );  break;
						case "teleport" :
						case "teleportation" : 
							 
							state = ( distance > 250 );  
							break;
						case "bodyCharge" : state = ( distance < 200 );  break;
						case "bindingRoot" : state = ( distance < this.parent.monsterParameters.range ); break;
						case "earthShake" :
						case "throwBoom" :
						case "earthQuake" :
						case "piercingSpeed" :  
						case "abilitiesSteal" : 
						case "defenseSteal" : 
							state = this.parent.attackTolerance();break;
						case "sekletonSummoner" :	
						case "golemSummoner" :
							
							if( !this.parent.object.pions ){
								this.parent.object.pions = [];
							}
							
							//+ 1 include leader 
							state = this.parent.object.pions.length + 1 < objSkill.initialParams.maximumPawns;
							
							break
							
						default : state = true; break;
					}
					
					
					
					if( this.parent.dirSwitch.forceAttackFrame ){ // means ai still use force frame
						return false;
					}else{
					
						return state;
					}
				
				},
				selectRandom : function( parent, cntStateSkill ){
					
					this.parent = parent;
					
					var skillLen = cntStateSkill.length,
					randSkill,
					self = this;
					
					
					if( skillLen ){
						
						
					
						var temp = [],
						randFn = function(){
							return cntStateSkill[ scope.random( skillLen - 1, 0 ) ];
						}
						
						while( skillLen !== temp.length ){
							randSkill = randFn();
							if( randSkill.state ){
								break
							}else{
								temp.push( randSkill );
								randSkill = null;
							}
						}
						
						temp.length = 0;
					 
						if( randSkill && this.uniqueSkill( randSkill  ) ){
							
							
							var obj = {
								install : function(){},
								initLoading : function(){
									self.active.push( randSkill );
									
								},
								guiInitLoading : function(){
									randSkill.state =  false;
								}
							} 
 
							parent.triggerUniqueSkill( obj, randSkill );

							
						}
						
					}
				},
				updateTick : function(){
					var active = this.active;			
					
					for( var jj = 0; jj <  active.length; jj++ ){
						var skill = active[jj];
						if( !skill.state ){
							if( skill.tickUpdate > 0 ){
								skill.tickUpdate--;
							}else{
								
								skill.state = true;
								skill.tickUpdate =  skill.tickOriginal && skill.tickOriginal || skill.tick;
								 
								this.active.splice( jj, 1 )
							}
						}
					}
				
					
				},
				reset : function( parent, cntStateSkill ){
					var len = cntStateSkill.length, active = parent.skill.active;
					for( var ii = 0; ii < len; ii ++ )
					{
						var isActive = false,
						stateSkill = cntStateSkill[ii];
						
						for( var jj = 0; jj < active.length ; jj++ ){
							var activeSkill = active[jj];
							if( stateSkill.label === activeSkill.label){
								isActive = true
							}
						}
						
						
						if( !stateSkill.state && !isActive )
						{
							scope.intervalList[ stateSkill.label ] && ( delete scope.intervalList[ stateSkill.label ] )
							stateSkill.state = true;
							stateSkill.tickUpdate = stateSkill.tick ;
						}
					}
					
					for( var jj = 0; jj < active.length ; jj++ ){
						var activeSkill = active[jj];
						//remove unexcpected skill
						if( activeSkill.tickUpdate >= activeSkill.tick && activeSkill.state ){
							active.splice( jj, 1 );
							
						}
					}
					
					parent.dirSwitch.selectedFrame = "";
					parent.dirSwitch.reset()
				}
			},
			
			this.manualUpdate = function(){
				// it will be executed 1s by setTimeout and will be triggered at animation.loading
				if( this.rigState ){ 
					//createBlue update 
					var activeSkill = this.cntActiveSkill;
					for(var ii = 0; ii < activeSkill.length; ii++ ){
						if( /createBlue|createRed/i.test( activeSkill[ii].name ) ){
							
							// if target end is empty
							//find shortest enemy within range 800 w and 400 h
							var targetEnd =  this.AISelectTarget( scope.browserWidthUpdate, scope.browserHeightUpdate * 2 , "random");
							if( targetEnd && activeSkill[ii].hitted ) activeSkill[ii].targetEnd = targetEnd;
						}
					}
					
					//uniqueSkill update
					( this.behave === "attack" ||  this.isStatic  ) && this.skill.selectRandom( this, this.cntStateSkill );
					
				}
				
				
			}
			this.AISelectTarget = function( width, height, target ){
				
				
				var selectedEnemy, temp = [],sortedEnemies = [];
				areaPool = this.createAreaDamagePool({
					target : this.object,
					width : width,
					height : height,
					caster : this.object.label
				});
				
				for( var ii = 0, jj = areaPool; ii < jj.length ; ii ++ ){
					temp.push( jj[ii].object );
				}
				
				for( var ii = 0, jj = scope.AI.sortestEnemy( temp, this.object ), len = jj.length ; ii < len ; ii ++ ){
					if( this.isEnemyFn( jj[ii].label ) ){
						sortedEnemies.push( jj[ii] )
					}
				}
				
				if( target === "nearest" ){
					selectedEnemy = sortedEnemies[0]
				}else if( target === "random" ){
					selectedEnemy = sortedEnemies[ scope.random( sortedEnemies.length - 1 , 0 ) ]
				}
				
				sortedEnemies.length = 0;
				
				return selectedEnemy;
				
			}
			this.forceObjectToAttack = function( object, pass ){
				
				if(  this.object.label !== object.label &&
					!this.stunEffect.init && ( this.character.label !== object.label || this.behave !== "attack"|| pass  ) ){
					
					if( !( this.character.position || this.object.position ) ){
						return; // prevent bug undefined
					}
					
					this.character = object;
					this.loopDir(  Math.round( this.character.position.x  - this.object.position.x ) );
					this.attacker = this.character.label;
					this.object.behave = this.behave = 'attack';
					
				}
			}
			this.setTarget = function(){
				var bodies = scope.Composite.allBodies( scope.engine.world );
				for(var ii = 0, jj = bodies; ii < jj.length; ii++ ){
					if( jj[ii].label === this.attacker ){
						// change attack target
						
						jj[ii].selected =  false; // AI party
						
						this.character = jj[ii];
						
						this.loopDir(  Math.round( this.character.position.x  - this.object.position.x ) );
						
						this.dirSwitch.selectedFrame = "";
						this.dirSwitch.reset();
						
						break;
					}
				}
			}
			this.hitterNotTargetTick = 0;
			
			this.hitterNotTarget = function( hitter ){
				if( this.attacker !== hitter && this.hitterNotTargetTick === 0 ){
					this.hitterNotTargetTick = scope.random( 10, 20 )
				}

				if( this.hitterNotTargetTick > 0){
					this.hitterNotTargetTick--;
					if( this.hitterNotTargetTick === 1 ){
						this.attacker = hitter;
						this.setTarget();
					}
				}
				
				
			}
			
			this.bossNeedHelp = function()
			{
				if( this.boss && this.boss.attacker && this.behave !== 'pointing' )
				{
					if( this.boss.attacker === 'die' ){
						
						this.objSpawn = this.boss.setObjectSpawn;
						this.pointMove = this.objSpawn;
						this.boss = '';
						this.object.behave = this.behave = 'attack';
						
					}else{
					
						if( this.boss.needHelp  && this.behave !== 'attack' )
						{
							//attacker first 
							this.attacker = this.boss.attacker;
							this.setTarget()
							
							var target = this.AIParty( this.character );
							this.forceObjectToAttack( target );
							this.boss.needHelp = false;
							
						}
						
					}
					
					this.updateBossTickBack = true;
				}else if( this.updateBossTickBack ){
					// pion monster tick back;
					this.updateBossTickBack = false;
				}
			
			}
			this.forceGravity = false;
			this.requireInstall = function( parentObject, posX, posY, object, interval, items, boss )
			{			
				
				this.x = posX;
				this.y = posY;
				this.object = object;
				this.object.statParameters = this.monsterParameters;
				this.label = object.label;
				this.rand = interval;
				this.items = items;	
				this.parentObject = parentObject;
				this.boss = boss && boss || '';
				this.object.bossLabel = this.boss && this.boss.label;
				this.monsterParameters.object = this.object;
				this.attacker = this.character.label;
				
				this.replaceObjectSpawnByRand.originObjSpawn = this.objSpawn.label; 
				
				this.pointMove = this.boss ? this.boss : this.objSpawn; //replace object spawn if it pion
				this.object.behave = this.behave = 'idle';
				this.forceGravity = this.object.forceGravity ? this.object.forceGravity : false;
				this.dungeonAttackRange = this.dungeonAttackRange - Math.abs( this.object.additionalBoundsWidthValue );
				
				scope.monsterParameters['value'].set( this.object.label, this.monsterParameters  );
				scope.Body.setPosition( object , { x : posX, y : posY } );
				scope[ this.object.stateStorage ].set(  this.object.label, 'idle' );
				
				//dir additionalBoundsWidthValue
				this.boundsWidthOperator.left = this.object.additionalBoundsWidthValue > 0  ? -1 : 1;
				this.boundsWidthOperator.right = this.object.additionalBoundsWidthValue > 0  ? 1 : -1;
				
				this.turnState = scope.random( 200, 100 );
				
				//prevent bug
				this.changeRightFn()
				
				if( !this.disableExtendMap ){
					var temp = {}, mapContent = scope.staticAllMap['value'][ this.location ];
					temp[ this.object.label ] = this.object;
					scope.extend( mapContent.content, temp, true  );
					
					//is this object a temporary spawn
					if( this.temporaryObjectSpawn ){
						!mapContent.content.temporaryObjectSpawn && ( mapContent.content.temporaryObjectSpawn = [] );
						mapContent.content.temporaryObjectSpawn.push( this.object );
					}else{
						// let remporaryObjSpawn be installed first
						setTimeout( function(){
							this.replaceObjectSpawnByRand.parent = this;
							this.replaceObjectSpawnByRand.update( this.location );
						}.bind( this ) , 100 )
					}
					
				}
				
				//register monsterGetDamage prop
				
				if( !scope.monsterGetDamage['value'].get( this.object.label ) ){
					
					//global scope
					scope.monsterGetDamage['value'].set( this.object.label, [] );
					
					//local scope
					this.monsterGetDamage = scope.monsterGetDamage['value'].get( this.object.label ) ;
				
				}
				
				
				
				
				scope.extend( this, new scope.components.objPropertyFn("monster") , true );
				
				scope.extend( this, new scope.components.buff, true );
				
				scope.extend( this, new scope.AI.skillBehaviour( this.monsterParameters.abilitySkill, this ) , true );
				
				this.objGlobalTranslate = new scope.objGlobalTranslate;
				 
				for( var ii in this.monsterParameters.abilitySkill ){
				   //is this skill registred
				   if( scope.items['value'].skills[ ii ] ){
					   this.cntStateSkill.push( new scope.items['value'].skills[ ii ] )
				   }
				}
				
				
				//load inventory		
				if( this.inventory.length && !scope.characterInventoryBag['value'].get( this.object.label ) ){
					
					var items = []
					for( var ii = 0, jj = this.inventory, len = jj.length ; ii < len ; ii++ ){
						items.push ( 
							new scope.items['value'][ jj[ii].root ? jj[ii].root : "magic" ][ jj[ii].item ]({ quantity : jj[ii].quantity })
						)
					}
					
					
					scope.characterInventoryBag['value'].set( this.object.label, items );
					
					this.cureSelf.loot = items;
					this.cureSelf.parameters = this.monsterParameters;
				
				}
				
				
				this.object.rigBody = this;
				
				
				
				//push pions object to boss's object property  it will be used for strategy party 
				if( this.boss ){
					if( this.boss.pions ){
						this.boss.pions.push( this.object )
					}else{
						this.boss.pions = [];
						this.boss.pions.push( this.object )
					}
					
					//mark this object as pawn	
					this.pionState = true;
					this.objSpawn = this.boss;
				}
				
				//force to switch hero
				if( this.hero ){
					
					scope.characterControl.switchCharacter( this.object );
					
					//let pawns being pushed first
					setTimeout( function(){
						
						var pions = this.object.pions;
						
						if( pions instanceof Array ){
							
							for( var ii = 0, jj = pions.length; ii < pions.length ; ii++ ){ // available gui only for 2 pions
								
								pions[ii].rigBody.cureSelf.gui = true
								
								pions[ii].rigBody.cureSelf.updateBar( 'hp-inner-line-bar' );
								pions[ii].rigBody.cureSelf.updateBar( 'mp-inner-line-bar' );
								pions[ii].rigBody.cureSelf.updateAvatar();
								
							}
							
						}
						
					}.bind( this ) , 100 )
					
				}
				
				this.install =  true;
			}	
			
			this.replaceObjectSpawnByRand = {
				originObjSpawn : "",
				parent : "",
				selectedObjSpawn : "",
				update : function( location ){
					
					var selectedObjSpawn = this.selectedObjSpawn;
					
					if( this.parent.pionState ){
						
						return this.parent.objSpawn;
						
					}else if( selectedObjSpawn && !selectedObjSpawn.deleted ){
						  
						return selectedObjSpawn;
						
					}else{
						
						var mapContent = scope.staticAllMap['value'][ location ].content,
						objSpawns = mapContent.temporaryObjectSpawn;
						
						if( mapContent.temporaryObjectSpawn && objSpawns.length ){
							 
							 
							this.selectedObjSpawn =	this.parent.pointMove = scope.AI.sortestEnemy( objSpawns, this.parent.object )[0];
							
							
						}else{
							
							this.selectedObjSpawn = this.parent.pointMove = this.parent.objSpawn;
						}
						  
						return this.selectedObjSpawn;
						
					}
					
				}
			}
			
			this.characterNotExist = function(){
				if( this.character.deleted ){
					//only for companions
					if( this.spell ){
						scope.oval['value'].attacker = false;
						scope.oval['value'].needHelp = false;
					}
					
					this.character = {};
					
					//prevent error 
					this.character[ 'position' ] = { x : 0, y : 0 };
					this.character[ 'bounds' ] = { max : { x : 0, y : 0 }, min : { x : 0, y : 0 } }
							
					this.attacker = false;
					this.behaveRandomFn( 1 );
			
					
				}else if( !this.character.label ){
					//prevent bug for sekleton
					this.attacker = false;
					this.character['label'] = 'dummy'
					this.behaveRandomFn( 1 );
				}else if( this.behave === "attack" && this.character.label === "dummy" ){
					
					this.behaveRandomFn( 1 );
				}

			}
			
			this.randomAttacking = scope.random(50,10);
			this.areaDamageHitter = [];
			
			this.areaDamageFn = function(){
				
				if( !this.rigState ) return true;
					
				this.areaDamageHitter.length = 0
				var areaDamage = scope.areaDmgPool['value'].storage;
				
				var objectBounds = this.object.position;
				self : for(var ii = 0, jj = areaDamage; ii < jj.length ; ii++ ){
					for( var kk = 0, ll = this.areaDamageHitter; kk < ll.length; kk++ ){
						if( jj[ii].status.label === ll[kk] ){
							break self;
						}							
					}	
					
					if(  objectBounds.x > jj[ii].status.bounds.min.x &&
					objectBounds.x < jj[ii].status.bounds.max.x &&
					objectBounds.y > jj[ii].status.bounds.min.y &&
					objectBounds.y < jj[ii].status.bounds.max.y && 
					this.aggresiveTo( jj[ii].status.caster ) && 
					jj[ii].status.caster !== this.object.label  ){
					
						jj[ii].status.monsterParameters.push( this.monsterParameters );
						this.areaDamageHitter.push( jj[ii].status.label );
					}
					
				}
			}
			
			this.toAggresive = function(){
				
				if( this.rigState && this.aggresive  && this.behave !== 'attack' && !this.spell ){ //spell is indicate of pion
					var enemyTarget = [];
					if( this.characterState ){
						
						var target = scope.oval['value'];
						if( target.behave !== 'die' ){
							enemyTarget = [  target  ].concat( target.pions );
						}
						
					}else{
						var bodies = scope.Composite.allBodies( scope.engine.world );
						for(var ii = 0, jj = bodies; ii < jj.length; ii++ ){
							for(var kk = 0, ll = this.aggresive.length ; kk < ll ; kk++ ){
								if( jj[ii].label.indexOf( this.aggresive[kk] ) !== -1 ){
									enemyTarget.push( jj[ii] )
								}
							}
						}
						
					}
					
					if( enemyTarget.length ){
						targetEnemy = scope.AI.sortestEnemy( enemyTarget, this.object )[0];
						
						var x1 = this.object.position.x,
						y1 = this.object.position.y,
						x2 = targetEnemy.position.x,
						y2 = targetEnemy.position.y,
						aggresiveDistance = 350;
						
						var targetDistance = scope.distanceAndAngleBetweenTwoPoints( x1, y1, x2, y2 ).distance;

						if( targetDistance < aggresiveDistance ){
							this.character = targetEnemy;
							this.loopDir(  Math.round( this.character.position.x  - this.object.position.x ) );
							this.attacker = targetEnemy.label;
							this.object.behave = this.behave = 'attack';
						}
					}
				}
				
			}
			
			this.hitNumberFn = function(){
				if( this.hitNumber.length ){
					for(var ii = 0; ii < this.hitNumber.length ; ii++ ){
						if( this.hitNumber[ii].update( scope.context, this.object ) )
							this.hitNumber.splice( ii, 1 )
					}
				}
				
			}
			this.cureSelf = {
				guiSupportAvailable : scope.guiSupportAvailable["value"],
				selectedGUI : false,
				gui : false,
				parameters : "",
				loot : "",
				hpSlot : "",
				mpSlot : "",
				reset : function(){
					
					if( this.gui ){
						
						this.gui = false;
							
						this.selectedGUI && this.guiSupportAvailable.push( this.selectedGUI )
						
						this.selectedGUI = false;
					}
					
				},
				updateAvatar : function(){
					if( this.gui ){
						
						var avaElement = scope.qs( this.selectedGUI ).querySelectorAll( ".avatar-support")[0];
						scope.css( avaElement,{
							"background" : "transparent url("+ scope.path + this.parameters.object.rigBody.avatar +") no-repeat top center",
							"background-size" : "100% auto"
						})
					}
				},
				updateBar : function( element, test ){
				 
					if( this.gui ){
						 
						if( !this.selectedGUI && this.guiSupportAvailable.length ){
							
							this.selectedGUI = this.guiSupportAvailable.splice( 0, 1 )[0];
							
						}
						
						var hpBar = scope.qs( this.selectedGUI ).querySelectorAll( "."+element )[0],
						width = element === 'hp-inner-line-bar' 
							? Math.round( this.parameters.health / this.parameters.maxHealth * 100 ) :
							 Math.round( this.parameters.mp / this.parameters.maxMp * 100 ) ;
						width = width < 1 ? 0 : width
						
						scope.css( hpBar, { "width" : width +'% ' })

						
					}
				},
				attachFn : function( slotType, init, label ){
					var loot = this.loot,
					hpItem = false,
					mpItem = false;
					
					for(var ii = 0; ii < loot.length; ii++ ){
						var item = loot[ii];
						
						if( init === "add" ){
							if( typeof item.cooldownTick !== "undefined" ){
								if( /healthpotion/i.test( slotType ) && /healthpotion/i.test( item.name ) ){
									this.hpSlot = item;
									hpItem = true;
									break
								}else if( /manapotion/i.test( slotType ) && /manapotion/i.test( item.name )  ){
									this.mpSlot = item;
									mpItem = true;
									break
								}
							}
						}else if( init === "remove" && item.label === label ){
							this.loot.splice( ii, 1 )
						}
					
					}
					
					if( !hpItem && /healthpotion/i.test( slotType )){
						this.hpSlot = "";
					}else if( !mpItem && /manapotion/i.test( slotType ) ){
						this.mpSlot = "";
					}
					
				},
				cure :  function( item, slotType ){
					
					var parameters = this.parameters;
					
					item.cooldownTick--;
					
					if( item.cooldownTick < 1 ){
					
						if( item.quantity > 1 ){
							
							/*if( slotType === "healthpotion") 
								console.log( item.name +' === '+ slotType +' && '+ parameters.health +' <  '+ parameters.maxHealthCure );
							*/
							if( slotType === "healthpotion" ){
								
								if( parameters.health < parameters.maxHealthCure ){
									item.quantity--;
									if( parameters.health + item.cure < parameters.maxHealth )
										parameters.health += item.cure;
									else 
										parameters.health = parameters.maxHealth;
								}	
								
								this.updateBar( 'hp-inner-line-bar' );
									
							}else if(  slotType === "manapotion"  ){
								
								if( parameters.mp  < parameters.maxMpCure ) {
									
									item.quantity--;
									if( parameters.mp + item.cure < parameters.maxMp ) 
										parameters.mp += item.cure;
									else 
										parameters.mp = parameters.maxMp;
								}
								
								this.updateBar( 'mp-inner-line-bar' );
								
							}
							
							item.cooldownTick = item.cooldown
							
						}else{
							
							this.attachFn( slotType, "remove", item.label )
						}
						
					}
					
				},
				update : function(){
					var hpPotion = this.hpSlot,
					mpPotion = this.mpSlot;
					
					if( hpPotion ){
						this.cure( hpPotion,"healthpotion" )
					}else{
						this.attachFn("healthpotion", "add" )
					}
					
					
					if( mpPotion ){
						this.cure( mpPotion,"manapotion" )
					}else{
						this.attachFn("manapotion", "add" )
					}
					
					
				}
			} 
			this.removeParamsWhenObjDeath = function( monsterParameters, object ){
				
				
				if( !monsterParameters.health && !this.hitNumber.length && !object.deleted ){
					 
					object.deleted = true;
					 
					setTimeout(function(){
					
						//trajectoriesUpdate		
						if( this.trajectoriesUpdate && this.trajectoriesUpdate.length ){
							for(var ii = 0; ii < this.trajectoriesUpdate.length ; ii++ ){
								if( this.trajectoriesUpdate[ii].update( 0, 0, 0, 0, this.turn, this.character, true ) )
									this.trajectoriesUpdate.splice( ii, 1 );
							}
						}
						 
						// remove self in boss object
						if( this.boss ){
							if( this.boss.pions && this.boss.pions.length ){
								for(var jj = 0; jj < this.boss.pions.length; jj++ ){
									
									if( this.boss.pions[jj].label === object.label ){
										this.boss.pions.splice( jj, 1 );
										break;
									}
									
									//sometimes boss array not splicing properly
									if( this.boss.pions[jj].deleted ){
										this.boss.pions.splice( jj, 1 );
									}
									
								}
							}
							
						} 
						
						//boss
						if( this.pitboss ){
							object.attacker = 'die';
							object.setObjectSpawn = this.objSpawn;
							object.deleted = true;
							
							if( object.pions && object.pions.length ){
								for(var jj = 0; jj < object.pions.length; jj++ ){
									object.pions[jj].rigBody.pionState = false;
									object.pions[jj].rigBody.boss = ""; //reupdate objSpawn by system
									
								}
							}
						}
						
						//spawn
						var mapContent = scope.staticAllMap['value'][ this.location ].content;
						
						delete mapContent[ object.label ];
						
						mapContent.temporaryObjectSpawn && function(){
							var obList = mapContent.temporaryObjectSpawn;
							if( obList.length ){
							
								for( var ii = 0, jj = obList; ii < jj.length; ii++ ){
									if( jj[ii].label === this.object.label ){
										jj.splice( ii, 1 )
									}
								}
							}else{
								delete mapContent.temporaryObjectSpawn
							}
						}.bind( this )();
						 
						//reset gui if available
						this.cureSelf.reset();
						
						//reset buff
						this.buff.affected.length = 0;
						 
						//set idle to attacker
						var enemyRig = this.character.rigBody
						if( enemyRig && enemyRig.characterState 
							&& enemyRig.monsterParameters.object.label === this.object.label
							&& !enemyRig.dirSwitch.forceAttackFrame 
							&& !enemyRig.isAttacking ){
							
							scope.monsterTarget = '';
							scope[  this.character.stateStorage ].set( this.character.label, "idle" );
							scope.addClass( scope.qs('monster-bar'), 'hidden' );
								
						}else if( enemyRig && enemyRig.behaveRandomFn ){
							enemyRig.behaveRandomFn( 1 );
						}
						 
						 	//reset enemy dirSwitch
						enemyRig && enemyRig.dirSwitch.reset();
						
						//add coin to hero;
						scope.addGoldToHero["value"]( this )
						
						//when hero leader died end game
						if( /hero/i.test( this.object.label ) ){
							if( this.pitboss ){//end game
							
								var remainingBox = scope.qs("remaining-box"),
								elmenateBox = scope.qs("eliminate-box");
								remainingContent = scope.qs("remaining-content"),
								remainingMsg = scope.qs("msg-remaining");

								remainingContent.innerHTML = "";
								
								scope.qs("button-remaining").setAttribute( "init", "reload" );
								
								scope.text( scope.qs("button-remaining"), owlData.lang.fn( "gui", "btnEndgame", "detail" ) )
								
								scope.text( remainingMsg, owlData.lang.fn( "gui", "leaderDied", "detail" ) )
								
								scope.removeClass( remainingBox, "hidden" );
								  
								scope.removeClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "towersLeft" ) );
								scope.removeClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "enemiesLeft" )  );
								scope.addClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "lose" ) );
								 
								scope.globalObjectGUI["value"].audioBackground.fn("end");
						
							} 
						}
						
						 
						/*
						if( this.monsterAttribute ){
							scope.characterUpdateQuest['value']( object.initialName );
							
							if( this.items ) this.items( this.parentObject, object, monsterParameters );
						}*/
						 
						this.remove = true;
						
						
						
						scope.removeTextureNpc( scope.context, object  );
						scope.World.remove( scope.engine.world, object);
						scope.monsterParameters['value'].remove( object.label );
						scope.monsterGetDamage['value'].remove( object.label );
						scope[ object.stateStorage ].remove( object.label );
						
						
						
					}.bind(this),1000);
					
					//bug attacker if character die
					
					if( !this.isStatic ) scope[ object.stateStorage ].set( object.label, 'die' );
					else{
						// tower died
						scope.pushMsgText['value']( owlData.lang.fn( "gui", "towerDied", "detail" ) , 100, "danger" );
						scope.infoLogFn['value']({
							title : 'regular-title',
							text : {
								yellow : owlData.lang.fn( "gui", "towerDied", "detail" )
							}
						})
						
						
					}
					
					object.behave = this.behave = 'die';
					
					this.audioDie && this.audioDie.length && scope.playAudio( this.audioDie );
					 
					if( !/sekleton/i.test( monsterParameters.object.label ) && this.monsterAttribute ){
						
						//scope.characterLevel['value']( monsterParameters, this.character.label )
						
					}
					
					return false;		
					
				}else if( object.deleted ){
					
					if( object.opacity >= 0 ){
						object.opacity -= 0.03;
					}else{
						object.opacity = 0;
					} 
					
					return false;
					
				}
				
				return true;

			}
			this.generalAIBehaviours = function( properties )
			{
				if( !this.rigState  ){ 
					return true;
				};
			  
				//boss need help 
				this.bossNeedHelp();
				this.characterNotExist();
				this.skill.updateTick();
				this.updateRegisterSkillFn();
				this.cureSelf.loot.length && this.cureSelf.update()
				
				
				var posPoint = this.pointMove.position,
				object = this.object,
				monsterPos = object.position,
				character = this.character,
				behave = this.behave,
				monsterParameters = this.monsterParameters;
				 
				if( this.removeParamsWhenObjDeath( monsterParameters, object ) ){
				
					this.tick ++;
					this.turnState--;
					
					
					var status = scope[ object.stateStorage ].get( object.label );
					
					
					if( !/back|attack/i.test( behave ) && this.tick > (  this.moveIdle ) ){
				 
						this.tick = 0;
						//random behave
						this.behaveRandom--;
						if( this.behaveRandom < 0 ){
							this.behaveRandomFn()
						}
					};
					 
					/* 
					if(  !(this.location.indexOf('Dungeon') !== -1) ){
						
						if( behave === 'walk' )
						{
							//prevent bug sprite walk
							( !/textureNeedChange|walk/i.test( status ) ) && scope[ object.stateStorage ].set( object.label, 'walk' );
							
							if( this.turnState < 0 )
							{
								if( this.turn === 'left'){
									this.changeLeftFn()
								}else if( this.turn === 'right' ){
									this.changeRightFn()
								}

								this.turn = this.turn === 'left' ? 'right' : 'left';
								this.turnState = scope.random( 600, 200 ); 
								this.behaveState = true;
							}
							
							scope.Body.translate( object, { x: this.moveSpeed  , y: 0   });
						
							
						}
						else if( behave === 'pointing' ){
							//prevent bug sprite walk
							this.objectPointing.translate();
							
							( !/textureNeedChange|walk/i.test( status ) ) && scope[ object.stateStorage ].set( object.label, 'walk' );
						
							var vec = scope.moveVector2dWithVelocity( object, this.objectPointing, 2 ),
							moveX = object.position.x + Math.round( vec.x ),
							posX = Math.abs( Math.round( this.objectPointing.position.x - object.position.x ) ),
							isBlock = true;
							
							if( posX < 20 ) isBlock = false;
							
							
							if( isBlock ){
								scope.Body.setPosition( object, 
									{ x : moveX,
									 y : object.position.y ,									
								})
							}else{
							
								this.behaveRandomFn( 1 )
							}
						}
						else if( behave === 'attack' )
						{
							
						}
					
					
					}else
					{ 
					}	*/
					
					var vec, position = character.position,
					allowX = this.pointMove.position.x - monsterPos.x,
					allowY = this.pointMove.position.y - monsterPos.y,
					backRange =  this.backRange,
					moveToleranceX = backRange.x,
					moveToleranceY = backRange.y,
					toleranceX = allowX > -moveToleranceX && allowX < moveToleranceX,
					toleranceY = allowY > -moveToleranceY && allowY < moveToleranceY,
					moveToleranceState = toleranceX && toleranceY;
					
					if( behave === 'back' )
					{	
				
						if( this.backDelay ){
							
							this.backDelay --;
							
							//prevent bug sprite walk
							( !/textureNeedChange|idle/i.test( status ) ) && scope[ object.stateStorage ].set( object.label, 'idle' );
							
							
						}else{
				
							//prevent bug sprite walk
							( !/textureNeedChange|walk/i.test( status ) ) && scope[ object.stateStorage ].set( object.label, 'walk' );
							
							 
							var objectSpawn = this.replaceObjectSpawnByRand.update( this.location ),
							posX = Math.round( objectSpawn.position.x -  monsterPos.x );
							
							if( !moveToleranceState && this.dirSwitch.dirBlock.state ){
								
								//this.turnState = 0;
								
								return this.dirSwitch.dirBlock.fn( this.pointMove.label )
								
							}else{
								
								this.dirSwitch.tempTarget.init = true;
								this.dirSwitch.reset();
								
								var vec = scope.moveVector2dWithVelocity( object, objectSpawn,  this.moveSpeedNormal ); 
								
								scope.Body.setPosition( object, 
									{ x : object.position.x + vec.x,
									 y : object.position.y + vec.y,									
								})
								
							
								if( moveToleranceState ){
									 
									if( backRange.state ){
										backRange.state = false;
										backRange.x = backRange.normalX;
										backRange.y = backRange.normalY;
									} 
 
									this.backDelay = scope.random( 25, 10 );
									this.behaveState = true;
									this.behaveRandomFn( 0 ) //force to walk
								}else{
									this.loopDir( posX )
								}
								
							}
						
						}
						
						
					}else if( status === 'turn' ){
						//reflect turn
						scope[ object.stateStorage ].set( object.label, 'walk' );
						object.behave = behave = 'walk';
						if( /left|right/i.test( object.outterWall ) ){
							this.vector.y = this.vector.y > 0 ? this.addSpeedForTurnAndWalk( "y", "min" )  : this.vector.y < 0 ? this.addSpeedForTurnAndWalk( "y", "max" ) : 0;
							this.vector.x = this.vector.x > 0 ? this.addSpeedForTurnAndWalk( "x", "min" ) : this.vector.x  < 0 ? this.addSpeedForTurnAndWalk( "x", "max" ) : 0;
							if( this.turn === 'right' ){
								this.changeLeftFn()
							}else{
								this.changeRightFn()
							};
							object.outterWall = '';
						}else{
							this.vector.y = this.vector.y > 0 ? this.addSpeedForTurnAndWalk( "y", "min" ) : this.vector.y < 0 ? this.addSpeedForTurnAndWalk( "y", "max" ) : 0;
						}
						
						this.dirSwitch.dirBlock.reset();
						this.dirSwitch.turn = true;
						
					}
					else if( behave === 'idle' ){
						
						( !/textureNeedChange|idle/i.test( status ) ) && scope[ object.stateStorage ].set( object.label, 'idle' );
					}
					else if( behave === 'pointing' ){
						//prevent bug sprite walk
						this.objectPointing.translate();
						
						( !/textureNeedChange|walk/i.test( status ) ) && scope[ object.stateStorage ].set( object.label, 'walk' );
					
						var vec = scope.moveVector2dWithVelocity( object, this.objectPointing, 2 ),
						moveX = object.position.x + Math.round( vec.x ),
						moveY = object.position.y + Math.round( vec.y ),
						posX = Math.abs( Math.round( this.objectPointing.position.x - object.position.x ) ),
						posY = Math.abs( Math.round( this.objectPointing.position.y - object.position.y ) ),
						isBlock = true;
						
						if( posX < 20 && posY < 20 ) isBlock = false;
						
						if( isBlock ){
							scope.Body.setPosition( object, 
								{ x : moveX,
								 y : moveY,									
							})
						}else{
							this.behaveRandomFn( 1 )
						}
					}
					else if( behave === 'walk' )
					{
						//prevent bug sprite walk
						( !/textureNeedChange|walk/i.test( status ) ) && scope[ object.stateStorage ].set( object.label, 'walk' );
						
						
						if( this.dirSwitch.dirBlock.state ){
							
							//set tur state to zero to update walk state if dirblock already finish
							this.turnState = 0;
							
							return this.dirSwitch.dirBlock.fn();
							
						}else{
							 
							if( this.turnState <= 0 )
							{	 
						
								var randX = this.turn === 'left' ?  
									this.addSpeedForTurnAndWalk( "x", "min" ) :  
									this.addSpeedForTurnAndWalk( "x", "plus" ),
								
								randY = scope.random( 1, 0 ) ?  
									this.addSpeedForTurnAndWalk( "y", "min" ) : 
									this.addSpeedForTurnAndWalk( "y", "plus" ) ;
									
								var randomX = Math.abs( 1 - ( randX > 0 ) ? Math.abs( randY ) : -Math.abs( randY ) ),
								randY = this.forceGravity ? 0 : randY;
								
								this.vector = { x : parseFloat(  randX  + ( ( randX > 0 ) ? randomX : -randomX ) / 2  ) , y : parseFloat( randY )  };

								this.loopDir( randX, true );
								
								
								this.turnState = scope.random( 600, 400 ); 
								this.behaveState = true;
								this.dirSwitch.dirBlock.reset();
								
							}
							
							if( this.walkState ){
								this.walkState--;
							}else{
								this.stateChange = true;
								this.walkState = scope.random(5,5);
							}
							
							scope.Body.setPosition( object, { 
								x : object.position.x + this.vector.x ,
								y : object.position.y + this.vector.y ,									
							})
							 
							if( !moveToleranceState  ){
								object.behave = this.behave = 'back' ;
								this.behaveState = false;
							}	 
						
						}
						
					}else if( behave === 'attack' )
					{
						 
						//this attribut will be used to track behave back
					
 
						//attack allowed only at pion 
						if( this.pionState && ( !toleranceY || !toleranceX ) ){ // resume back 
							 
							object.behave = this.behave = 'back' ;
							this.behaveState = false;
							 
							if( !moveToleranceState && 
								backRange.x === backRange.normalX && 
								backRange.y === backRange.normalY ){
								
								backRange.x = backRange.backX;
								backRange.y = backRange.backY;
								backRange.state = true;
							}
						
						}else{
							 
							var posX = Math.round( position.x - monsterPos.x ),
							posY = Math.round( position.y - monsterPos.y ),
							stateSkill = true;
							 
							if( this.isArcherOrMage ){
								
								var tempTarget = this.dirSwitch.tempTarget;
								
								var objMovement = this.rangeMovement({
									object : object,
									target : character,
									targetDummy : tempTarget,
									distanceY : this.dungeonAttackRangeY,
									distanceX : this.dungeonAttackRange,
									distY : posY,
									distX : posX,
									dirSwitch : this.dirSwitch,
									objTranslate : this.objTranslate,
									speed : Math.abs( this.moveSpeed )
								})
								
								objMovement.status = status;

								
								if( this.performAttackFrame( objMovement, this.dirSwitch.selectedFrame ) ){
									 
									this.turnState = scope.random( 600, 400 );
									
									stateSkill = this.dirSwitch.forceAttackFrame 
									
									if( monsterParameters.trajectoryProp.weaponEquip === "trajectory" && !stateSkill ){ // archer with trajectoy boom : ex
										this.trajectoryInit.createNormalTrajectory( this );
									}else if( monsterParameters.trajectoryProp.weaponEquip === "none" ){ // archer 
										this.characterDamagePool({
											objectAttacker : object,
											objectTarget : character 
											
										});
									}
									
								}
								
								if( !this.dirSwitch.mainTurn ){
									var posX = Math.round( tempTarget.position.x - monsterPos.x ),
									posY = Math.round( tempTarget.position.y - monsterPos.y )
								}
								
							
							}else{
								
								var objMovement = this.meleeMovement({
									object : object,
									target : character,
									range : this.dungeonAttackRange,
									distanceY : this.dungeonAttackRangeY.min,
									speed :  Math.abs( this.moveSpeed ),
									forceGravity : object.forceGravity,
									dirSwitch : this.dirSwitch
								});
								 
								stateSkill = this.dirSwitch.forceAttackFrame ;
								
								if( stateSkill ){
									objMovement.init = true;
								}
								stateSkill = !stateSkill;
								
								if( this.performAttackFrame( objMovement, this.dirSwitch.selectedFrame ) ){
									this.turnState = scope.random( 600, 400 );
									this.characterDamagePool({
										objectAttacker : object,
										objectTarget : character 
										
									});
								}
								
							}
							
							stateSkill && this.loopDir( posX )
							
							if( this.turnState < 0 && !this.attackTolerance( posX, posY ) ){	
								object.behave = this.behave = 'walk';
								scope[ object.stateStorage ].set( object.label, 'walk' );
							}
							 
						}
						
					}
				
					if( !this.updateIntervalBack-- ){ /// return 0
						 
						if( this.boss && !( moveToleranceState ) && !/back|attack/i.test( behave ) ){

							object.behave = this.behave = 'back' ;
							this.behaveState = false;
							this.updateIntervalBack = 600;
							this.backDir( allowX, allowY, moveToleranceX, moveToleranceY )
						} 
						
					}
					
					
					
				
				}
				
			}
		}

		this.components.attackFrameAttribute = function(){
			this.state = true;
			this.stateIndex = 0;
			this.fn = function( parent, selectedSkill ){
				
				if( !this[ selectedSkill ] ){
					parent.dirSwitch.selectedFrame = "normal";
					parent.dirSwitch.reset()
					selectedSkill = "normal"// prevent this[ selectedSkill ] undefined;
					
					
				}
				if( this.state ){
					this.stateIndex = scope.random( this[ selectedSkill ].frameContent.length - 1, 0 );
					this.state =  false;
				}
				
				
				var selectedFrame = this[ selectedSkill ].frameContent[ this.stateIndex ];
				 
				//to prevent undefined when player force to selecting a spesific frame
					
				return selectedFrame ? selectedFrame : this[ selectedSkill ].frameContent[ 0 ];
				
			}
		}
		
		this.components.items = function(){
			this.itemTemp = []; 
			this.item = new function(){
				this.create = function( x, y, itemName, texture, dropChara ){
				
					this.object = new  scope.createItem['value']( texture.name, texture.width, texture.height );
					this.object.isStatic = true;
					this.firstload = function(){
						
						scope.playAudio('item-pick')
						
						scope.Body.setPosition(
							this.object , {
							x : x,
							y : y
						} )
						
						scope.intervalList[ this.object.label ] = {
							tick : 1000, // 30 s
							fn : function(){ 
								scope.World.remove( scope.engine.world, this.object );
							}.bind( this )
						}
						
						return null;
					}.bind(this)();
					
					

					this.character = scope.oval['value'];
					this.update = function( object, character ){
						var pos = object.position,
						posChar = character.position,
						posX = pos.x,
						posY = pos.y,
						inventoryItemName, parent,
						rangeX = Math.abs( posX - posChar.x ),
						rangeY = Math.abs( posY - posChar.y );
						
						 
						if( rangeX < 40 && rangeY < 40 && function(){
							
							if( dropChara ){
								 
								//check is this item is for leader, classType or not
								var parent = dropChara.parent,
								inventoryItemName = dropChara.initial,
								itemDummy = new scope.items['value'][ parent ][ inventoryItemName ]({ quantity : 1 });
								
								
								if( !itemDummy.itemfor ){
									
									return true;
									
								}else if( object.itemException ){
									// this char is marked to not to pick this item
									for( var ii = 0, jj = object.itemException; ii < jj.length ; ii++ ){
										if( jj[ii] === character.label ){
											return false; 
										}
									}
									 
								}else{
									
									if( character.statParameters.classType === itemDummy.itemfor ||
										scope.characterControl.bossObject.label === character.label &&
										itemDummy.itemfor === "leader" ){
										 
										console.log( character.label )
										return true;
										 
									}else{
										
										console.log( object )
										
										object.itemException = [ character.label ];
										return false;
									}
								}
							}
							
							
											
							return true;
						}()){
							 
							
							if( object.itemVal ){
								scope.playAudio('item-drop')
								scope.infoLogFn['value']({
									title : 'regular-title',
									text : {
										white : character.statParameters.name + owlData.lang.fn( "gui", "accuredItem", "detail" ),
										chocolate : ' '+object.itemVal+' ',
										gold : itemName
									}
								})
							}
							
							//scope.characterUpdateQuest['value']( itemName.toLowerCase() );
							
							//character item discard 
							if( dropChara ){
								parent = dropChara.parent;
								inventoryItemName = dropChara.initial;
							}else{
								parent = 'dropMonster'
								switch( itemName.toLowerCase() ) {
									case "ness scale" : inventoryItemName = 'nessScale'; break;
									case "ness fang" : inventoryItemName = 'nessFang'; break;
									case "queen ness scale" : inventoryItemName = 'nessQueenScale'; break;
									case "meat" : inventoryItemName = 'meat'; break;
									case "gall boar fang" : inventoryItemName = 'gallBoarFang'; break;
									case "nortus green scale" : inventoryItemName = 'nortusGreenScale'; break;
									case "nortus red scale" : inventoryItemName = 'nortusRedScale'; break;
									case "light soul" : inventoryItemName = 'lightSoul'; break;
									case "basic magical plant" : inventoryItemName = 'basicMagicPlant'; break;
									case "basic herb plant" : inventoryItemName = 'basicHerbPlant'; break;
									case "goblin elixir" : inventoryItemName = 'goblinElixir'; break;
									case "bedrock meat" : inventoryItemName = 'bedrockMeat'; break;
									case "bedrock bone" : inventoryItemName = 'bedrockBone'; break;
									case "bedrock fang" : inventoryItemName = 'bedrockFang'; break;
									case "lapis fragment" : inventoryItemName = 'lapisFragment'; break;
									case "nortus tail heart" : inventoryItemName = 'nortusTailHeart'; break;
									case "nortus red tail scale" : inventoryItemName = 'nortusRedTailScale'; break;
									case "nortus green tail scale" : inventoryItemName = 'nortusGreenTailScale'; break;
									case "tainted gem" : inventoryItemName = 'taintedGem'; break;
									case "tainted soul" : inventoryItemName = 'taintedSoul'; break;
									default : inventoryItemName = ''; break;
								}
							}
							
							scope.intervalList[ object.label ] && ( delete scope.intervalList[ object.label ] )
							
							scope.pickUpDropItem['value']({
								parent : parent,
								initial : inventoryItemName,
								value : object.itemVal
							});
							
							scope.World.remove( scope.engine.world, object );
							
							return true;
						}
						return false;
					}
				};
			}
			
			this.coin = new function(){
				this.create = function( spawnX, spawnY,  isStatic ){
					
					this.object = new  scope.createItem['value']( 'Ness Scale', 74, 68 )
					
					this.firstload = function(){
						
						this.object.isStatic = true;
						
						scope.Body.setPosition(
							this.object , {
							x : spawnX,
							y : spawnY
						} )
						
						scope.intervalList[ this.object.label ] = {
							tick : 3600,
							fn : function(){ 
								scope.World.remove( scope.engine.world, this.object );
							}.bind( this )
						}
						
						return null;
					}.bind(this)();



					this.character = scope.oval['value'];
					this.update = function( object, character ){
						var pos = object.position,
						posChar = character.position,
						charparams = scope.characterParameters['value'],
						posX = pos.x,
						posY = pos.y;

						rangeX = Math.abs( posX - posChar.x )
						rangeY = Math.abs( posY - posChar.y )

						if( rangeX < 40 && rangeY < 40 ){
							
							if( object.coinVal ){
								charparams.gold += object.coinVal;
								scope.playAudio('Pickup_Gold_04')
								scope.infoLogFn['value']({
									title : 'regular-title',
									text : {
										white : 'Accured',
										chocolate : ' '+object.coinVal+' ',
										gold : 'Gold'
									}
								})
							}
							
							scope.World.remove( scope.engine.world, object );

							return true;
						}
						return false;
					}
				};
			}
		}
		
		this.components.buff = function(){
			
			this.buff = new function(){
				this.affected = [];
				this.isOval = false; 
				this.check = function( skillEffected, skillName ){
					
					for(var ll = 0; ll <  this.affected.length ; ll++){
						if( this.affected[ll].skill.toLowerCase() === skillName.toLowerCase() ){
							return true;
						}
					}
					
					return false;
				
				}
				this.gui = function( init, id, name ){
					if( init === 'add' ){
						var div = document.createElement('div')
						div.className = 'buff-skill '+name;
						div.id = id
						
						var span = document.createElement('span')
						div.appendChild( span )
						
						scope.buffBox.insertBefore( div, scope.buffBox.firstChild );
					}else if( init === 'remove' ){
						var cnt = scope.slice( scope.buffBox.getElementsByTagName('div') );
						for( var ii = 0 ; ii < cnt.length ; ii++ ){
							if ( cnt[ii].id === id ){
								cnt[ii].remove()
								break;
							}
						}
					}
				}
				this.guiGl = function(){
				
					var storage = this.affected, len = storage.length, centerX = 22, mean = ( len - 1 ) * 11;
					
					for(var ii = 0; ii < len ; ii++ ){
						var effectedIcon = storage[ii];
						effectedIcon.drawFn.update({
							gl : scope.context,
							image : effectedIcon.image.textures,
							posX : effectedIcon.target.x - ( ii * centerX ) +  mean,
							posY : effectedIcon.boundMin.y - effectedIcon.boundY,
							imagePosY : effectedIcon.imagePosY,
							imagePosX : effectedIcon.imagePosX,
							scaleX : effectedIcon.scaleX ,
							scaleY : effectedIcon.scaleY,
							offsetX : effectedIcon.offsetX,
							offsetY : effectedIcon.offsetY,
							scaleBefore : effectedIcon.scaleBefore
						})
					}
				}
				
				this.glProp = function( options, texture ){
						
						var objectTarget = options.paramsTarget.object;
						
						this.image = {
							textures : '',
							src : scope.path + texture
						},
						
						scope.getTexture( this.image, this.image.src )
						
						this.drawFn = new scope.draw.generalDrawImage();
						this.boundY =  objectTarget.additionalBoundsValue ? objectTarget.additionalBoundsValue : 0;
						this.imagePosY = -42;
						this.imagePosX =  0;
						this.scaleBefore = 0;
						this.scaleX = 0;
						this.scaleY = 0;
						this.offsetX = 0.1;
						this.offsetY = 0.1;
						this.boundMin = objectTarget.bounds.min;
						this.target = objectTarget.position;
					
				}
				
				this.unregister = function( buffSelected, index ){
					 
					for(var ii = 0, jj = buffSelected.paramsTarget.activeSkill; ii < jj.length ; ii++ )
						if( jj[ii] === buffSelected.skill ) jj.splice( ii, 1);
					
					delete buffSelected.paramsAttacker.buffSkill[ buffSelected.skill ];
					
					this.affected.splice( index, 1 );
					
					//gui for oval only
					if( this.isOval ){
						//this.gui( 'remove', buffSelected.id );
						//scope.buffGUI['value'].remove( buffSelected.skill );
					}
					
					
				}
				
				this.register = function( options ){
					
					if( options.paramsAttacker.buffSkill  ){
						
						var seletedBuff = options.seletedBuff,
						test = false;
						
						self : for( var ii in seletedBuff ){
							
							if( !options.paramsTarget.object || !options.paramsAttacker.object ) 
								continue self;
							
							var rigBodyTarget = options.paramsTarget.object.rigBody,
							rigBodyAttacker = options.paramsAttacker.object.rigBody,
							selectedBuff = seletedBuff[ii];
							 
							if(  this.check( selectedBuff, ii ) 
								|| !selectedBuff.icon 
								|| selectedBuff.chance <=  ( Math.random() * 100 )
								|| rigBodyTarget.isStatic //ignore when target is static object
								|| function(){ // casted to allies or enemies, set to false means buff is registered
									
									var isEnemy = rigBodyTarget.isEnemyFn( rigBodyAttacker.object.label );
									
									return selectedBuff.castedToAlly ? isEnemy : !isEnemy ;
								}() ){ 
								
								continue self;
							}
						
							var id = scope.uniqueId();
							
							options.paramsTarget.activeSkill.push( seletedBuff[ii].name )
							
							
							this.isOval = options.paramsTarget.object.label === scope.oval["value"].label ;
							
							//gui just for oval only
							if( this.isOval ){ 
								//this.gui( 'add', id, seletedBuff[ii].name );
							}
							
							var clone = {
								skill : selectedBuff.name,
								tick : selectedBuff.tick,
								id : id,
								interval : selectedBuff.interval,
								intervalUpdate : selectedBuff.intervalUpdate,
								callbackStart : selectedBuff.callbackStart ? selectedBuff.callbackStart : function(){},
								callbackEnd : selectedBuff.callbackEnd ? selectedBuff.callbackEnd : function(){},
								paramsTarget : options.paramsTarget,
								paramsAttacker : options.paramsAttacker,
								affected : this.affected
							}
							
							this.setDelayToAttacker( selectedBuff );
							
							//buff binding	
								 
							this.affected.push( scope.extend( clone, new this.glProp( options, selectedBuff.icon ) ) )
							
							
							return false;
					
						}
					}
					
					return true;
				
				}
				 
				this.setDelayToAttacker = function( buffSelected ){
					if( this.affected.length ){
						
						if( buffSelected.paramsAttacker ){
							var activeSkill = buffSelected.paramsAttacker.activeSkill;
							//set skill delay to attacker
							for(var kk = 0; kk < activeSkill.length ; kk++){
								if(activeSkill[kk] === buffSelected.skill ){
									return true;
								}
							}
							
							activeSkill.push( buffSelected.skill ); // init for monster delay skill
						}
						
						return true;
					}
					
				}
				
				this.update = function(){
					
					var buffArr = this.affected;
					
					if( buffArr.length ) this.guiGl();
					
					
					for(var ii = 0; ii < buffArr.length ; ii++ )
					{
						var buff = buffArr[ii];
						
						
						buff.tick--;
						
						/*if( this.isOval ){
							
							//scope.buffGUI['value'].set( buff.skill, {
							//	tick : buff.tick,
							//	id : buff.id
							//})
						//}*/
						
					
						if( buff.tick < 0 ){
							
							buff.callbackEnd( buff );
							this.setDelayToAttacker( buff ) 
							this.unregister( buff, ii )
							
						}else{
							
							buff.interval--
							
							if( buff.interval < 0 ){ 
							
								buff.callbackStart( buff );
								buff.interval = buff.intervalUpdate;
							}
							
						}
						
					}
					
				}
			}
									
			
		}
		
		this.components.objPropertyFn = function(){
			
			this.abilityCritical = function( attackerParameters, damage, optionalAttackerParams ){
				
				//critical chance
				var criticalPercentage = attackerParameters.modifierAbilities && attackerParameters.modifierAbilities["criticalChance"] ?
				attackerParameters.modifierAbilities["criticalChance"] : 0,
				optionalCriticalPercentage = optionalAttackerParams ? optionalAttackerParams.criticalPercentage : 0,
				optionalCritical = optionalAttackerParams ? optionalAttackerParams.critical : 0;
				
				if( ( criticalPercentage + optionalCriticalPercentage ) > 0 && 
					function(){ 
						return ( Math.random() * 100 ) <= ( criticalPercentage + optionalCriticalPercentage ) ;
					}() ) {
					
					//critical
					var critical = attackerParameters.modifierAbilities && attackerParameters.modifierAbilities["critical"] ?
					attackerParameters.modifierAbilities["critical"] : 0,
					criticalDamage = damage * ( critical + optionalCritical ) / 100,
					criticalState = ( criticalDamage > 0 );
					return Math.round( criticalDamage );
				
				}else{
					return 0;
				}
				
			}
			this.abilityBlock = function( monsterParameters ){
				var temp = [];
				//monster ability this.monsterParameters
				if( monsterParameters.abilitySkill ){
					var ability = monsterParameters.abilitySkill;
					for( var ii in ability ){
						if( ii === 'block'){
							var permut = ( Math.random() * 100 ) <= ability[ii] ;
							permut && temp.push( ii );
						}
					}
				}
				return temp;
			}
			this.abilityMagicDefense = function( monsterParameters, normalDamage ){
				var totalDemage = normalDamage;
				if( monsterParameters.abilitySkill 
					&& monsterParameters.abilitySkill.magicDefense ){
					var magicDefenseParams = monsterParameters.abilitySkill.magicDefense,
					magicDefenseRandom = scope.random( magicDefenseParams.max, magicDefenseParams.min ),
					percentage = normalDamage * magicDefenseRandom / 100,
					tempDemage = normalDamage - percentage,
					totalDemage = tempDemage > 0 ? tempDemage : Math.round( scope.random( 100, 50 ) / 2 );
				}
				return Math.round( totalDemage );
			}
			this.abilityDefense = function( monsterParameters, normalDamage ){
				var totalDemage = normalDamage;
				if( monsterParameters.abilitySkill 
					&& monsterParameters.abilitySkill.defense ){
					var defenseParams = monsterParameters.abilitySkill.defense,
					defenseRandom = scope.random( defenseParams.max, defenseParams.min ),	
					percentage = normalDamage * defenseRandom / 100,
					tempDemage = normalDamage - percentage,
					totalDemage = tempDemage > 0 ? tempDemage : Math.round( scope.random( 100, 50 ) / 2 );
				}
				return Math.round( totalDemage );
			}
			this.attackerAbilities = function( attckerParameters ){
				var temp = [];
				if( attckerParameters.modifierAbilities ){
					var ability = attckerParameters.modifierAbilities;
					for( var ii in ability ){
						var permut = ( Math.random() * 100 ) <= ability[ii] ;
						permut && temp.push( ii );
					}
				}
				return temp;
			}
			this.monsterDamagePool = function( options ){
				
				var objectAttacker = options.objectAttacker,
				objectTarget = options.objectTarget, 
				attackerParameters = objectAttacker.statParameters,
				targetParameters = objectTarget.statParameters,
				
				targetLabel = objectTarget.label;
			
				
				//monster attacker
				if( attackerParameters.attackType === 'melee' ){
					var atkRangeMax = attackerParameters.attackMax,
					atkRangeMin = attackerParameters.attackMin;
				}else if( attackerParameters.attackType === 'long-range' ){
					var atkRangeMax = attackerParameters.attackRangeMax,
					atkRangeMin = attackerParameters.attackRangeMin;
				}
				 
				//monster defenser
				var monsterDefMax = targetParameters.defenseMax,
				monsterDefMin =  targetParameters.defenseMin,
				status = 'attack', targetAbilities, attackerAbilities,
				monsterAtkRandom = scope.random( atkRangeMax, atkRangeMin ),
				charDefRandom = scope.random( monsterDefMax, monsterDefMin ),
				tempDemage, tempHealth, monsterGetDamage,
				tempDemage = monsterAtkRandom - charDefRandom;
			
				attackerAbilities = this.attackerAbilities( attackerParameters );// miss / stun from attacker
				
				monsterGetDamage = tempDemage > 0 ? tempDemage : Math.round( scope.random( 100, 50 ) / 2 );
				
				var monsterStat = scope.monsterGetDamage['value'].get( targetLabel )
				if( typeof monsterStat  === 'undefined' ){
					//scope.monsterGetDamage['value'].storage = [];
					scope.monsterGetDamage['value'].set( targetLabel, [] )
					var monsterStat = scope.monsterGetDamage['value'].get( targetLabel )
				};
				
				
				//bug attacker
				monsterStat.push({
					damage : monsterGetDamage,
					status : status,
					attackerAbilities : attackerAbilities,
					attacker : objectAttacker.label, 
					attackerParameters : attackerParameters
				})
			}
			
			this.forceToSwitchTurn = function(){
				 						
				var turn = ( this.turn ? this.turn === 'right' : this.monsterDir() === 'right' ) ?  "right" : "left";
				 
				if( turn === 'right' ){
					this.changeRightFn( true, true );
				}else{ 
					this.changeLeftFn( true, true );
				}	 
				 
			}
			
			
			this.previousEnemy = {
				state : true,
				name : false
			}
			
			this.aggresiveTo = function( target ){
				
				if( target ){ // caster area
				
					var charTolowercase = target.toLowerCase();
					
					for( var ii = 0, aggresive = this.aggresive, len = aggresive.length; ii < len ; ii++ ){
						if( charTolowercase.indexOf( aggresive[ii] ) !== -1 ){
							return true;
						}
					}
					
					
					return false;
				
				}else{ // self area
					
					return true;
					
				}
				
				
				
			}
			
			this.isEnemyFn = function( monsterTarget ){
						 
				if( this.previousEnemy.name !== monsterTarget ){
					 
					this.previousEnemy.name = monsterTarget;
					this.previousEnemy.state = this.isEnemy( monsterTarget );
				}
				
				return this.previousEnemy.state;
				
			}
			 
			this.isEnemy = function( attacker ){
 
		
				var party = [];
					
				if( this.isStatic ){
					var bossObject = scope.oval["value"].rigBody.bossObject;
					party = [ bossObject ].concat( bossObject.pions );
				}else if( this.characterState ){
					var party = [ this.bossObject ].concat( this.bossObject.pions );
				}else if( this.object.pions ){
					var party = [ this.object ].concat( this.object.pions );
				}else if( this.boss ){
					var party = [ this.boss ].concat( this.boss.pions );
				}
				
						
				//cancel when tower attack character allies
				if( /tower/i.test( attacker ) && /hero/i.test( this.object.label ) ||
					/tower/i.test( this.object.label ) && /hero/i.test( attacker ) ||
					this.boss && /tower/i.test( attacker ) && /hero/i.test( this.boss.label ) ){ //ally attack familiar
					return false;
				}
				 
				if( party.length ){
					for( var ii = 0; ii < party.length ; ii++){
						if( attacker === party[ii].label ){
							return false;
						}
					}
				}
				  
				return true;
				
				  
					
			}
			this.attackTolerance = function( posX, posY ){
				
				
				
				var dungeonAttackRangeY = this.dungeonAttackRangeY,
				dungeonAttackRangeX = this.dungeonAttackRange;
				
				
				if( !posX  ){
					
					if( !this.object ||  this.object.statParameters.mainCharacter && ( !this.monsterParameters.object || !this.monsterParameters ) ){// handling error
						return false
					}
					
					var pos = this.object.position,
					monsterPos = this.object.statParameters.mainCharacter ? this.monsterParameters.object.position : this.character.position,
					posX = Math.round( monsterPos.x - pos.x ),
					posY = Math.round( monsterPos.y - pos.y );
				}

				
			
				
				return posY >= dungeonAttackRangeY.max 
						&& posY < dungeonAttackRangeY.min 
						&& posX > -dungeonAttackRangeX
						&& posX < dungeonAttackRangeX
						
				
			}
			this.characterDamagePool = function( options ){
				
				if( options.objectTarget.statParameters.mainCharacter ){
					
					var damageMonster = scope.characterGetDamage['value'].get( options.objectTarget.label );
					 
					damageMonster.push( options.objectAttacker.statParameters );
					
					
					scope.characterGetDamage['value'].set( options.objectAttacker.label, damageMonster );
					
					
				}else{
					
					this.monsterDamagePool(  options )
				}
			}
			
			this.stunEffect = new function(){
				
				this.init = false;
				
				this.fn = function( init, target ){
				
					var self =  this,
					tick, targetRig = target.rigBody,
					enemy = targetRig.characterState ? targetRig.monsterParameters.object : targetRig.character;
					
					//prevent setInterval call multipe when call stun multipe time 
					
					self.init = true;
					target.behave = targetRig.behave = 'idle'; 
					scope[ target.stateStorage ].set( target.label, 'idle' );
			
					
					switch( init ){
						case "long" : tick = 100; break;
						case "short" : tick = 20; break
					}
					
					var prop =  scope.intervalList[ target.label ];
					
					if( prop ){
						
						 prop.tick = tick;
						
					}else{
						scope.intervalList[ target.label ] = {
							tick : tick, 
							fn : function(){
								
								self.init = false;
								targetRig.dirSwitch.reset(); 
								target.behave = targetRig.behave = 'attack'; 
								
							}
						}
					}
					
					
				}
				
			}
			
			this.createAreaDamagePool = function( options ){
				
				var target = options.target,
				areaDmg = scope.staticAreaDmg['value']( target.position, options.width, options.height);
				areaDmg.caster = options.caster;
					
				scope.areaDmgPool['value'].set( areaDmg.label, areaDmg );
			 
				scope.monsterControl.triggerMonsterFn('area');
				scope.characterControl.areaDamageFn();
				
				
				var areaPool = scope.areaDmgPool['value'].get( areaDmg.label );
				
				scope.areaDmgPool['value'].remove( areaDmg.label );
				
				return areaPool.monsterParameters;
				
			}
			 
			this.partyRandomHelp = new function(){ 
				this.partyRandomHelpTick = 0;
				this.update = function( parent ){
					 
					if( this.partyRandomHelpTick === 0 ){
						this.partyRandomHelpTick = scope.random( 7, 3 )
					}
					 
					if( this.partyRandomHelpTick > 0){
						this.partyRandomHelpTick--;
						if( this.partyRandomHelpTick === 1 )
						{
							 
							var party  = [];
							if( parent.boss ){ // npc
								party.push( parent.boss )
								if( parent.boss.pions ){
									party.concat( parent.boss.pions  )
								}
							} else if( parent.pitboss ){ // npc
								party.push( parent.object )
								if( parent.object.pions ){
									party.concat( parent.object.pions  )
								}
								
							} else if( parent.bossObject  ){ // character
								//character 
								party.push( parent.bossObject )
								if( parent.bossObject.pions ){
									party.concat( parent.object.pions  )
								}
							}
							 
							
							for(var ii = 0, jj = party; ii < jj.length; ii++){
								if( jj[ii].label === parent.object.label || jj[ii].behave === 'attack' ){
									jj.splice( ii, 1 )
								}
							}
							
							
							if( party.length ){
								var pionHelper = party[ scope.random( party.length - 1, 0) ];
								if( pionHelper.rigBody ){
									
									var enemy = parent.characterState ? parent.monsterParameters.object : parent.character;
									 
									pionHelper.rigBody.forceObjectToAttack( enemy, true )
									 
									pionHelper.rigBody.object.selected =  false; // AI party
									//force move dir
									pionHelper.rigBody.behaveState = true;
									  
								}
							}
						}
					}
				}
			}
			
			this.checkObjectOutterWall = function(){
				
				if( !this.isStatic ){
				
					var objPos = this.object.position, 
					outterWall = scope.staticWallOutter['value'](),
					yMin = outterWall[0].bounds.max.y, // top
					yMax = outterWall[1].bounds.min.y, // bottom
					xMax = outterWall[2].bounds.min.x, // right
					xMin = outterWall[3].bounds.max.x; // left
					
					if( !( objPos.y > yMin && objPos.y < yMax && objPos.x < xMax  && objPos.x > xMin ) ){
						var randX = scope.random( 100, -100),
						randY = scope.random( 100, -100),
						spawnObject = this.pointMove.position;
			 
						scope.Body.setPosition(
							this.object , {
							x : spawnObject.x + randX,
							y : spawnObject.y + randY 
						})
						
					} 
					
				}
				
				
			}
		}
		
		this.components.companions = function( option ){
			
			
			this.triggerMonsterFn = function( init ){
				var currentMap = scope.activeMap['value'],
				self = this,
				switchFn = function( objPlay ){
					switch( init ) {
						case "area" : objPlay.areaDamageFn(); break;
						case "aggresive" : objPlay.toAggresive(); break; 
						case "update" : 
							objPlay.manualUpdate(); 
							objPlay.checkObjectOutterWall();
						
						break; 
					}
				};
				
			
				for(var ii = 0, jj = this.objSpawnMonster; ii < jj.length; ii++ ){
					var  spawnObj = jj[ii];
					for( var kk = 0; kk < spawnObj.length ; kk++ )
					{
						var obj = spawnObj[kk];
						if( obj  ){
							if( obj.monsters ){
								if( currentMap === obj.location ){
									
									
									for(var ll = 0; ll < obj.monsters.length ; ll++ ){
 
										switchFn( obj.monsters[ll].play );
 	
									}
								}
							}else{
								 
								switchFn( obj.play );
							}
						}
					}
				}
			}
			
			
		
		}
		
		this.components.initArmored = function( options ){
			return function( onload ){
				//for companion
				if( onload.spell ){
					this.spell = options.spell;
					this.itemLabel = onload.itemLabel
					this.disableExtendMap = true;
				}
				this.avatar = options.avatar ? options.avatar : "chara.png";
				this.hero = options.hero; // return undefined or true
				this.aggresive = options.aggresive;
				this.isArcherOrMage = false;
				this.audioDie = options.audioDie;
				this.attackFrame =  options.attackFrame;
				this.pitboss = onload.pitboss;
				this.location = onload.location;
				this.inventory = options.inventory;
				this.objSpawn = onload.objSpawn;
				this.dungeonAttackRange  =  options.attackRange;
				this.dungeonAttackRangeY  = {
					max : -30,
					min : 30
				};
				this.moveSpeedAttack  = options.moveSpeedAttack;
				this.moveSpeedNormal= options.moveSpeedNormal;
				this.initialSpeedNormal = options.initialSpeedNormal;
				this.initialAttackDelay = options.initialAttackDelay;
				

				this.monsterParameters = {
					name : options.name,
					level : options.level, 
					monsterLevel : options.monsterLevel,
					gold : options.gold ? options.gold : 0, 
					
					health : options.maxHealth,
					maxHealth : options.maxHealth,
					maxHealthCure : options.maxHealth,
					mp : options.mp,
					maxMp : options.mp,
					maxMpCure : options.mp,
					
					range : options.attackRange,
					attackRangeMax : options.attackRangeMax,
					attackRangeMin :options.attackRangeMin,
					attackMax : options.attackMax,
					attackMin : options.attackMin ,
					defenseMax : options.defenseMax ,
					defenseMin : options.defenseMin,
					magicDefenseMax : options.magicDefenseMax,
					magicDefenseMin : options.magicDefenseMin,
					modifierAbilities : options.modifierAbilities ? scope.extend( {}, options.modifierAbilities, true ) : {},
					activeSkill : [],
					buffSkill : {},
					abilitySkill : options.abilitySkill ? scope.extend( {}, options.abilitySkill, true ) : {}, 
					coin : scope.monsterAttribute['value']( options.level, 'soul' ) || scope.random( 15, 5 ),
					item : options.item || '',
					exp : scope.monsterAttribute['value']( options.level, 'exp' )|| scope.random( 25, 50 ),
					attackType : 'melee',
					classType : "meleeArmor",
					object : ''
				}
				
				this.statInitial = function()
				{
					if( this.stat( options.hpBar ) ) // attack success
					{ 
						if( this.behave === 'back' ){
							//reset Path
							this.pathState = false;
							this.posCapture.position.y  = 0;
						}
						this.object.behave = this.behave = 'attack';
					}
				}
				
			
				this.update = function( parentObject, posX, posY, object, interval, items, boss )
				{
					if( !this.install ){
						
						scope.extend( this, new scope.components.monster, true );
						scope.extend( this, new scope.components.monsterDungeon( this ), true );
						scope.extend( this, new scope.AI.pathFinding, true );
						scope.extend( this, new scope.AI.attackBehaviour( "melee" ) , true );
						scope.extend( this.attackFrame,  new scope.components.attackFrameAttribute, true );
						
						this.initialSpeedAttack = options.initialSpeedAttack;
						
						this.dirSwitch.attackDelayPerFrameReplace = options.initialSpeedAttack;
						
						this.requireInstall(  parentObject, posX, posY, object, interval, items, boss  )
						
					}
				
					this.statInitial()
					this.generalAIBehaviours()
					
					return this.remove;
				}
			}
		}
		 
		this.components.initSpear = function( options ){
			return function( onload ){
				this.avatar = options.avatar ? options.avatar : "chara.png";
				this.hero = options.hero; // return undefined or true
				this.audioDie = options.audioDie;
				this.attackFrame = options.attackFrame;
				this.pitboss = onload.pitboss;
				this.location = onload.location;
				this.inventory = options.inventory;
				this.objSpawn = onload.objSpawn;
				this.dungeonAttackRange  = options.attackRange;
				this.dungeonAttackRangeY  = {
					max : -30,
					min : 30
				};
				this.aggresive = options.aggresive;
				this.isArcherOrMage = false;
				this.moveSpeedAttack  = options.moveSpeedAttack;
				this.moveSpeedNormal= options.moveSpeedNormal;
				this.initialSpeedNormal = options.initialSpeedNormal;
				this.initialAttackDelay = options.initialAttackDelay;
				
				this.monsterParameters = {
					name : options.name,
					level : options.level,
					monsterLevel : options.monsterLevel,
					gold : options.gold ? options.gold : 0, 
					
					
					health : options.maxHealth,
					maxHealth : options.maxHealth,
					maxHealthCure : options.maxHealth,
					mp : options.mp,
					maxMp : options.mp,
					maxMpCure : options.mp,
					
					
					range : options.attackRange,
					attackRangeMax : options.attackRangeMax,
					attackRangeMin :options.attackRangeMin,
					attackMax : options.attackMax,
					attackMin : options.attackMin,
					defenseMax : options.defenseMax,
					defenseMin : options.defenseMin,
					magicDefenseMax : options.magicDefenseMax,
					magicDefenseMin : options.magicDefenseMin,
					modifierAbilities :  options.modifierAbilities ? scope.extend( {}, options.modifierAbilities, true ) : {},
					activeSkill : [],
					buffSkill : {},
					abilitySkill : options.abilitySkill ? scope.extend( {}, options.abilitySkill, true ) : {}, 
					coin : scope.monsterAttribute['value']( options.level, 'soul' ),
					item : options.item || '',
					exp : scope.monsterAttribute['value']( options.level, 'exp' ),
					attackType : 'melee',
					classType : "meleeSpear",
					object : ''
				}
				 
				this.statInitial = function()
				{
					if( this.stat( options.hpBar ) ) // attack success
					{ 
						if( this.behave === 'back' ){
							//reset Path
							this.pathState = false;
							this.posCapture.position.y  = 0;
						}
						this.object.behave = this.behave = 'attack';
					}
				}
				
				this.update = function( parentObject, posX, posY, object, interval, items, boss )
				{
					if( !this.install ){
						
						scope.extend( this, new scope.components.monster, true );
						scope.extend( this, new scope.components.monsterDungeon( this ), true );
						scope.extend( this, new scope.AI.pathFinding, true );
						scope.extend( this, new scope.AI.attackBehaviour( "melee" ) , true );
						scope.extend( this.attackFrame,  new scope.components.attackFrameAttribute, true );
						
						this.initialSpeedAttack = options.initialSpeedAttack;
						
						this.dirSwitch.attackDelayPerFrameReplace = options.initialSpeedAttack;
						
						this.requireInstall(  parentObject, posX, posY, object, interval, items, boss  )
						
					}

					this.statInitial()
					this.generalAIBehaviours()
					
					return this.remove;
				}
				
			}
		}
		
		this.components.initMage = function( options ){
			return function( onload ){
				this.avatar = options.avatar ? options.avatar : "chara.png";
				this.hero = options.hero; // return undefined or true
				this.audioDie = options.audioDie;
				this.attackFrame = options.attackFrame;
				this.pitboss = onload.pitboss;
				this.location = onload.location;
				this.inventory = options.inventory;
				this.objSpawn = onload.objSpawn;
				this.aggresive = options.aggresive;
				this.isArcherOrMage = true;
				this.dungeonAttackRange  = function(){ 
					 var maxWidth = scope.browserWidthUpdate / 2;
					 return maxWidth < options.attackRange ? maxWidth : options.attackRange;
				}();
				this.dungeonAttackRangeY  = {
					max : -130,
					min : 130
				};
				this.moveSpeedAttack  = options.moveSpeedAttack;
				this.moveSpeedNormal= options.moveSpeedNormal;
				this.initialSpeedNormal = options.initialSpeedNormal;
				this.initialAttackDelay = options.initialAttackDelay;
				this.monsterParameters = {
					name : options.name,
					level : options.level,
					monsterLevel : options.monsterLevel,
					gold : options.gold ? options.gold : 0, 
					
					
					health : options.maxHealth,
					maxHealth : options.maxHealth,
					maxHealthCure : options.maxHealth,
					mp : options.mp,
					maxMp : options.mp,
					maxMpCure : options.mp,
					
					
					range : options.attackRange,
					attackRangeMax : options.attackRangeMax,
					attackRangeMin : options.attackRangeMin,
					attackMax : options.attackMax,
					attackMin : options.attackMin,
					defenseMax : options.defenseMax,
					defenseMin : options.defenseMin ,
					magicDefenseMax : options.magicDefenseMax,
					magicDefenseMin : options.magicDefenseMin,
					modifierAbilities :  options.modifierAbilities ? scope.extend( {}, options.modifierAbilities, true ) : {},
					coin : scope.monsterAttribute['value']( options.level, 'soul' ),
					item : options.item ,
					exp : scope.monsterAttribute['value']( options.level, 'exp' ),
					activeSkill : [],
					buffSkill : {},
					abilitySkill : options.abilitySkill ? scope.extend( {}, options.abilitySkill, true ) : {}, 
					attackType : 'long-range',
					classType : "mage",
					object : '',
					trajectoryProp : options.trajectoryProp
				}
				
				this.statInitial = function()
				{
					if( this.stat( options.hpBar ) ) // attack success
					{ 
						if( this.behave === 'back' ){
							//reset Path
							this.pathState = false;
							this.posCapture.position.y  = 0;
						}
						this.object.behave = this.behave = 'attack';
					}
				}
				
				
			
				this.update = function( parentObject, posX, posY, object, interval, items, boss )
				{
					if( !this.install ){
						
						scope.extend( this.attackFrame,  new scope.components.attackFrameAttribute, true )
						scope.extend( this, new scope.components.monster, true );
						scope.extend( this, new scope.components.monsterDungeon( this ), true );
						scope.extend( this, new scope.AI.pathFinding, true );
						scope.extend( this, new scope.AI.attackBehaviour( "range" ) , true );
					
						this.object.pionNeedHelp = false;
						
						this.initialSpeedAttack = options.initialSpeedAttack;
						
						this.dirSwitch.attackDelayPerFrameReplace = options.initialSpeedAttack;
						
						this.requireInstall(  parentObject, posX, posY, object, interval, items, boss  );
						
						
					}
					
					this.statInitial()
					this.generalAIBehaviours()

					return this.remove;
				}
			}
		}
		
		this.components.initArhcer = function( options ){
			return function( onload ){
				
				//for companion
				if( onload.spell ){
					this.spell = options.spell;
					this.itemLabel = onload.itemLabel
					this.disableExtendMap = true;
				}
				
				this.avatar = options.avatar ? options.avatar : "chara.png";
				this.hero = options.hero; // return undefined or true
				this.aggresive = options.aggresive;
				this.isArcherOrMage = true;
				this.audioDie = options.audioDie;
				this.attackFrame =  options.attackFrame;
				this.pitboss = onload.pitboss;
				this.location = onload.location;
				this.inventory = options.inventory;
				this.objSpawn = onload.objSpawn;
				this.dungeonAttackRange  = function(){ 
					 var maxWidth = scope.browserWidthUpdate / 2 ;
					 return maxWidth < 600 ? maxWidth : 600;
				}();
				this.dungeonAttackRangeY  = {
					max : 0,
					min : scope.random( 180, 100 )
				};
				this.moveSpeedAttack  = options.moveSpeedAttack;
				this.moveSpeedNormal= options.moveSpeedNormal;
				this.initialSpeedNormal = options.initialSpeedNormal;
				this.initialAttackDelay = options.initialAttackDelay;
				
				
				this.monsterParameters = {
					name : options.name,
					level : options.level,
					monsterLevel : options.monsterLevel,
					gold : options.gold ? options.gold : 0, 
					
					health : options.maxHealth,
					maxHealth : options.maxHealth,
					maxHealthCure : options.maxHealth,
					mp : options.mp,
					maxMp : options.mp,
					maxMpCure : options.mp,
					
					range : options.attackRange,
					attackRangeMax : options.attackRangeMax,
					attackRangeMin : options.attackRangeMin,
					attackMax : options.attackMax,
					attackMin : options.attackMin,
					defenseMax : options.defenseMax,
					defenseMin : options.defenseMin ,
					magicDefenseMax : options.magicDefenseMax,
					magicDefenseMin : options.magicDefenseMin,
					coin : scope.monsterAttribute['value']( options.level, 'soul' ),
					item : options.item ,
					exp : scope.monsterAttribute['value']( options.level, 'exp' ),
					activeSkill : [],
					buffSkill :{},
					abilitySkill : options.abilitySkill ? scope.extend( {}, options.abilitySkill, true ) : {}, 
					modifierAbilities :  options.modifierAbilities ? scope.extend( {}, options.modifierAbilities, true ) : {},
					attackType : 'long-range',
					classType : "archer",
					object : '',
					trajectoryProp : options.trajectoryProp
				}
				
				
				
				
				this.statInitial = function()
				{
					if( this.stat( options.hpBar ) ) // attack success
					{ 
						if( this.behave === 'back' ){
							//reset Path
							this.pathState = false;
							this.posCapture.position.y  = 0;
						}
						this.object.behave = this.behave = 'attack';
					}
				}
				
				this.update = function( parentObject, posX, posY, object, interval, items, boss )
				{
					if( !this.install ){
						
						scope.extend( this.attackFrame,  new scope.components.attackFrameAttribute, true )
						scope.extend( this, new scope.components.monster, true );
						scope.extend( this, new scope.components.monsterDungeon( this ), true );
						scope.extend( this, new scope.physicsComponent.itemTrajectoryComponent, true);
						scope.extend( this, new scope.AI.pathFinding, true );
						scope.extend( this, new scope.AI.attackBehaviour( "range" ) , true );
						
						this.initialSpeedAttack = options.initialSpeedAttack;
						
						this.dirSwitch.attackDelayPerFrameReplace = options.initialSpeedAttack;
						
						this.requireInstall(  parentObject, posX, posY, object, interval, items, boss  );
						
					}
					
					//trajectoriesUpdate		
					if( this.trajectoriesUpdate.length ){
						var objPos = this.object.position,
						trajectoryProp = this.object.statParameters.trajectoryProp,
						turn = this.turn,
						trajectoriesUpdate = this.trajectoriesUpdate,
						angle, posX, posY, angle;
						
						
						if( turn === 'right' ){
							posY = objPos.y - trajectoryProp.posY ;
							posX = objPos.x + trajectoryProp.posX ,
							angle =  110;
						}else{
							var posX = objPos.x - trajectoryProp.posX ,
							posY = objPos.y - trajectoryProp.posY,
							angle =  250;
						}

						for(var ii = 0; ii < trajectoriesUpdate.length ; ii++ ){
							if( trajectoriesUpdate[ii].update( posX, posY, angle, turn, this.character ) )
								trajectoriesUpdate.splice( ii, 1 );
						}
					}
					
					
					this.statInitial()
					this.generalAIBehaviours()
					
					return this.remove;
				}
			}
		}

		this.components.initStatic = function( options ){
			return function( onload ){
				this.avatar = options.avatar ? options.avatar : "chara.png";
				this.hero = options.hero; // return undefined or true
				this.isStatic = true;
				this.temporaryObjectSpawn = options.temporaryObjectSpawn;
				this.audioDie = options.audioDie;
				this.attackFrame = options.attackFrame;
				this.pitboss = onload.pitboss;
				this.location = onload.location;
				this.objSpawn = onload.objSpawn;
				this.inventory = options.inventory;
				this.aggresive = options.aggresive;
				this.initialAttackDelay = options.initialAttackDelay;
				this.dungeonAttackRange  = function(){ 
					 var maxWidth = scope.browserWidthUpdate / 2;
					 return maxWidth < options.attackRange ? maxWidth : options.attackRange;
				}();
				this.dungeonAttackRangeY  = {
					max : -130,
					min : 130
				};
				this.moveSpeedAttack  = options.moveSpeedAttack;
				this.moveSpeedNormal= options.moveSpeedNormal;
				this.initialSpeedNormal = options.initialSpeedNormal;
				this.monsterParameters = {
					name : options.name,
					level : options.level,
					monsterLevel : options.monsterLevel,
					gold : options.gold ? options.gold : 0, 
					
					
					health : options.maxHealth,
					maxHealth : options.maxHealth,
					maxHealthCure : options.maxHealth,
					mp : options.mp,
					maxMp : options.mp,
					maxMpCure : options.mp,
					
					
					range : options.attackRange,
					attackRangeMax : options.attackRangeMax,
					attackRangeMin : options.attackRangeMin,
					attackMax : options.attackMax,
					attackMin : options.attackMin,
					defenseMax : options.defenseMax,
					defenseMin : options.defenseMin ,
					magicDefenseMax : options.magicDefenseMax,
					magicDefenseMin : options.magicDefenseMin,
					modifierAbilities :  options.modifierAbilities ? scope.extend( {}, options.modifierAbilities, true ) : {},
					coin : scope.monsterAttribute['value']( options.level, 'soul' ),
					item : options.item ,
					exp : scope.monsterAttribute['value']( options.level, 'exp' ),
					activeSkill : [],
					buffSkill : {},
					abilitySkill : options.abilitySkill ? scope.extend( {}, options.abilitySkill, true ) : {}, 
					attackType : 'long-range',
					classType : "static",
					object : '',
					trajectoryProp : options.trajectoryProp
				}

				this.staticBehave = {
					tick  : 50,
					health : this.monsterParameters.health
				}
				
				this.update = function( parentObject, posX, posY, object, interval, items, boss )
				{
					if( !this.install ){
						
						scope.extend( this, new scope.components.monster, true );
						scope.extend( this, new scope.components.monsterDungeon( this ), true );
						scope.extend( this, new scope.AI.pathFinding, true );
						
						this.object.pionNeedHelp = false;
						
						this.initialSpeedAttack = options.initialSpeedAttack;
						
						this.dirSwitch.attackDelayPerFrameReplace = options.initialSpeedAttack;
						
						this.requireInstall(  parentObject, posX, posY, object, interval, items, boss  );
						
						this.object.behave = this.behave = "idle";
						
						/**
						point arrow
						/*/
						
						this.object.quest = {
							update : [ this.object.label ], //marking
							mapMark : new scope.draw.mapMark(),
							target : "tower"
						};
						
						//let setTimeout change stateStorage to prevent bug, some of statics not rendered
						setTimeout( function(){
						
							scope[ this.object.stateStorage ].set( this.object.label, 'idle' );
						
						}.bind( this ),100)
						
					}
					  
					if( this.staticBehave.tick ){
						this.staticBehave.tick--;
					}else if( this.monsterParameters.health !== this.staticBehave.health ){
						
						this.staticBehave.health = this.monsterParameters.health;
						this.object.staticBehave = "attack";
						this.staticBehave.tick = 50;
					}else{
						
						this.object.staticBehave = "idle";
						this.staticBehave.tick = 50;
					}
					
					this.stat( options.hpBar );
					this.skill.updateTick();
					this.updateRegisterSkillFn();
					this.removeParamsWhenObjDeath( this.monsterParameters, this.object )

					return this.remove;
				}
			}
		}
			
	}

	_owlBird.animation = function( _obj )
	{
		window.scope = this
		
		scope['fn'] = new _obj.utils;

		var obj = {
			screen : scope.fn.qs('screen'),
			canvas : scope.fn.id('canvas'),
			browserWidthUpdate : _obj.browserWidth(),
			browserHeightUpdate : _obj.browserHeight(),
			deltaTime : '',
			fps : 33,
			blockRender : false,
			isSwitchMapActive : false,
			context : function(){
				var gl =  scope.fn.id("canvas").getContext("webgl", {  premultipliedAlpha: false } );
				gl.enable( gl.BLEND );
				gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true)
				gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
				//gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
				return gl;

			}(),
			canvasStatus : 'play',
			path: "assets/2d/",
			monsterTarget : "",
			Engine : Matter.Engine,
			Composite : Matter.Composite,
			Composites : Matter.Composites,
			Constraint : Matter.Constraint,
			World : Matter.World,
			Runner : Matter.Runner,
			Bodies : Matter.Bodies,
			Events : Matter.Events,
			Svg : Matter.Svg,
			Vertices : Matter.Vertices,
			orderObj : [],
			Body : Matter.Body,
			fragment: [],
			svgCount : {
				current : 0,
				tot : 0
			},
			objFragment :{},
			bugTranslate : 1,
			webglUtils : {
				error : function( log ){
					console.log( log )
				},
				createProgram : function( gl, shaders ){
					var program = gl.createProgram();
					shaders.forEach(function(shader) {
					  gl.attachShader(program, shader);
					});

					gl.linkProgram(program);

					// Check the link status
					var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
					if (!linked) {
						// something went wrong with the link
						var lastError = gl.getProgramInfoLog(program);
						errFn("Error in program linking:" + lastError);

						gl.deleteProgram(program);
						return null;
					}
					return program;
				},
				loadShader : function( gl, shaderSource, shaderType ) {

					// Create the shader object
					var shader = gl.createShader(shaderType);

					// Load the shader source
					gl.shaderSource(shader, shaderSource);

					// Compile the shader
					gl.compileShader(shader);

					// Check the compile status
					var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
					if (!compiled) {
					  // Something went wrong during compilation; get the error
					  var lastError = gl.getShaderInfoLog(shader);
					  this.errFn("*** Error compiling shader '" + shader + "':" + lastError);
					  gl.deleteShader(shader);
					  return null;
					}

					return shader;
				},
				createShaderFromScript : function( gl, scriptId, opt_shaderType ){
					var shaderSource = "";
					var shaderType;
					var shaderScript = document.getElementById(scriptId);
					if (!shaderScript) {
					  throw ("*** Error: unknown script element" + scriptId);
					}
					shaderSource = shaderScript.text;

					if (!opt_shaderType) {
					  if (shaderScript.type === "x-shader/x-vertex") {
						shaderType = gl.VERTEX_SHADER;
					  } else if (shaderScript.type === "x-shader/x-fragment") {
						shaderType = gl.FRAGMENT_SHADER;
					  } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {
						throw ("*** Error: unknown shader type");
					  }
					}

					return this.loadShader( gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType );
				},
				createProgramFromScripts : function( gl, shaderScriptIds ){
					var shaders = [],
					defaultShaderType = [
						"VERTEX_SHADER",
						"FRAGMENT_SHADER"
					];

					for (var ii = 0; ii < shaderScriptIds.length; ++ii) {
					  shaders.push( this.createShaderFromScript( gl, shaderScriptIds[ii], gl[defaultShaderType[ii]]  ));
					}
					return this.createProgram( gl, shaders );
				},

				
				webglCreateLineShader : function( gl, scope, shaders ){
					
					var compileShader = function( shader, prop ){
						var program = scope.webglUtils.createProgramFromScripts( gl, shader );
						
						scope[ prop ]["value"] = {
							program : program
						}
					}
					
					for( var ii = 0, jj = shaders.length; ii < jj; ii++ ){
						compileShader( shaders[ii].shader, shaders[ii].prop )
					}
				},
				webglCreateTexShader : function( gl, scope, shaders ){
					
				  var compileShader = function( shader, prop ){
						// setup GLSL program
						var program = scope.webglUtils.createProgramFromScripts( gl, shader ),

						// look up where the vertex data needs to go.
						positionLocation = gl.getAttribLocation(program, "a_position"),
						texcoordLocation = gl.getAttribLocation(program, "a_texcoord"),

						// lookup uniforms
						matrixLocation = gl.getUniformLocation(program, "u_matrix"),
						textureMatrixLocation = gl.getUniformLocation(program, "u_textureMatrix"),
						textureLocation = gl.getUniformLocation(program, "u_texture"),
						alphaLocation = gl.getUniformLocation(program, "u_alpha"),
  
						// Create a buffer.
						positionBuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

						gl.useProgram(program)
						gl.uniform1f( alphaLocation, 1.0);

						// Put a unit quad in the buffer
						var positions = [
							0, 0,
							0, 1,
							1, 0,
							1, 0,
							0, 1,
							1, 1,
						]
						gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

						// Create a buffer for texture coords
						var texcoordBuffer = gl.createBuffer();
						gl.bindBuffer( gl.ARRAY_BUFFER, texcoordBuffer );

						// Put texcoords in the buffer
						var texcoords = [
							0, 0,
							0, 1,
							1, 0,
							1, 0,
							0, 1,
							1, 1,
						]
						gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);

						// Assign the buffer object to positionLocation variable
						// https://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttribPointer.xml
						// index, size, type, normalized, stride, pointer
						gl.enableVertexAttribArray( positionLocation );
						// Enable the assignment to positionLocation variable
						gl.vertexAttribPointer( positionLocation, 2, gl.FLOAT, false, 0, 0 );

						// Assign the buffer object to texcoordLocation variable	
						gl.enableVertexAttribArray( texcoordLocation );

						// Enable the assignment to texcoordLocation variable
						gl.vertexAttribPointer( texcoordLocation, 2, gl.FLOAT, false, 0, 0 );
 
						scope[ prop ]["value"] = {
							program: program,
							positionLocation : positionLocation,
							texcoordLocation : texcoordLocation,
							matrixLocation : matrixLocation,
							textureLocation : textureLocation,
							textureMatrixLocation : textureMatrixLocation,
							positionBuffer : positionBuffer,
							texcoordBuffer : texcoordBuffer,
							alphaLocation : alphaLocation
						}
				  }
				
				  for( var ii = 0, jj = shaders.length; ii < jj; ii++ ){
					compileShader( shaders[ii].shader, shaders[ii].prop )
				  }
				  
				},
				
			},
			webglM4 :{
				
				orthographic : function(left, right, bottom, top, near, far, dst) {
					dst = dst || new Float32Array(16);

					dst[ 0] = 2 / (right - left);
					dst[ 1] = 0;
					dst[ 2] = 0;
					dst[ 3] = 0;
					dst[ 4] = 0;
					dst[ 5] = 2 / (top - bottom);
					dst[ 6] = 0;
					dst[ 7] = 0;
					dst[ 8] = 0;
					dst[ 9] = 0;
					dst[10] = 2 / (near - far);
					dst[11] = 0;
					dst[12] = (left + right) / (left - right);
					dst[13] = (bottom + top) / (bottom - top);
					dst[14] = (near + far) / (near - far);
					dst[15] = 1;

					return dst;
				},
				
				translation : function(tx, ty, tz, dst) {
					dst = dst || new Float32Array(16);

					dst[ 0] = 1;
					dst[ 1] = 0;
					dst[ 2] = 0;
					dst[ 3] = 0;
					dst[ 4] = 0;
					dst[ 5] = 1;
					dst[ 6] = 0;
					dst[ 7] = 0;
					dst[ 8] = 0;
					dst[ 9] = 0;
					dst[10] = 1;
					dst[11] = 0;
					dst[12] = tx;
					dst[13] = ty;
					dst[14] = tz;
					dst[15] = 1;

					return dst;
				},
				translate : function (m, tx, ty, tz, dst) {
					// This is the optimized version of
					// return multiply(m, translation(tx, ty, tz), dst);
					dst = dst || new Float32Array(16);

					var m00 = m[0];
					var m01 = m[1];
					var m02 = m[2];
					var m03 = m[3];
					var m10 = m[1 * 4 + 0];
					var m11 = m[1 * 4 + 1];
					var m12 = m[1 * 4 + 2];
					var m13 = m[1 * 4 + 3];
					var m20 = m[2 * 4 + 0];
					var m21 = m[2 * 4 + 1];
					var m22 = m[2 * 4 + 2];
					var m23 = m[2 * 4 + 3];
					var m30 = m[3 * 4 + 0];
					var m31 = m[3 * 4 + 1];
					var m32 = m[3 * 4 + 2];
					var m33 = m[3 * 4 + 3];

					if (m !== dst) {
					  dst[ 0] = m00;
					  dst[ 1] = m01;
					  dst[ 2] = m02;
					  dst[ 3] = m03;
					  dst[ 4] = m10;
					  dst[ 5] = m11;
					  dst[ 6] = m12;
					  dst[ 7] = m13;
					  dst[ 8] = m20;
					  dst[ 9] = m21;
					  dst[10] = m22;
					  dst[11] = m23;
					}

					dst[12] = m00 * tx + m10 * ty + m20 * tz + m30;
					dst[13] = m01 * tx + m11 * ty + m21 * tz + m31;
					dst[14] = m02 * tx + m12 * ty + m22 * tz + m32;
					dst[15] = m03 * tx + m13 * ty + m23 * tz + m33;

					return dst;
				},
				scaling : function (sx, sy, sz, dst) {
					dst = dst || new Float32Array(16);

					dst[ 0] = sx;
					dst[ 1] = 0;
					dst[ 2] = 0;
					dst[ 3] = 0;
					dst[ 4] = 0;
					dst[ 5] = sy;
					dst[ 6] = 0;
					dst[ 7] = 0;
					dst[ 8] = 0;
					dst[ 9] = 0;
					dst[10] = sz;
					dst[11] = 0;
					dst[12] = 0;
					dst[13] = 0;
					dst[14] = 0;
					dst[15] = 1;

					return dst;
				},
				scale : function (m, sx, sy, sz, dst) {
					// This is the optimized verison of
					// return multiply(m, scaling(sx, sy, sz), dst);
					dst = dst || new Float32Array(16);

					dst[ 0] = sx * m[0 * 4 + 0];
					dst[ 1] = sx * m[0 * 4 + 1];
					dst[ 2] = sx * m[0 * 4 + 2];
					dst[ 3] = sx * m[0 * 4 + 3];
					dst[ 4] = sy * m[1 * 4 + 0];
					dst[ 5] = sy * m[1 * 4 + 1];
					dst[ 6] = sy * m[1 * 4 + 2];
					dst[ 7] = sy * m[1 * 4 + 3];
					dst[ 8] = sz * m[2 * 4 + 0];
					dst[ 9] = sz * m[2 * 4 + 1];
					dst[10] = sz * m[2 * 4 + 2];
					dst[11] = sz * m[2 * 4 + 3];

					if (m !== dst) {
					  dst[12] = m[12];
					  dst[13] = m[13];
					  dst[14] = m[14];
					  dst[15] = m[15];
					}

					return dst;
				},
				zRotate :function (m, angleInRadians, dst) {
					// This is the optimized verison of
					// return multiply(m, zRotation(angleInRadians), dst);
					dst = dst || new Float32Array(16);

					var m00 = m[0 * 4 + 0];
					var m01 = m[0 * 4 + 1];
					var m02 = m[0 * 4 + 2];
					var m03 = m[0 * 4 + 3];
					var m10 = m[1 * 4 + 0];
					var m11 = m[1 * 4 + 1];
					var m12 = m[1 * 4 + 2];
					var m13 = m[1 * 4 + 3];
					var c = Math.cos(angleInRadians);
					var s = Math.sin(angleInRadians);

					dst[ 0] = c * m00 + s * m10;
					dst[ 1] = c * m01 + s * m11;
					dst[ 2] = c * m02 + s * m12;
					dst[ 3] = c * m03 + s * m13;
					dst[ 4] = c * m10 - s * m00;
					dst[ 5] = c * m11 - s * m01;
					dst[ 6] = c * m12 - s * m02;
					dst[ 7] = c * m13 - s * m03;

					if (m !== dst) {
					  dst[ 8] = m[ 8];
					  dst[ 9] = m[ 9];
					  dst[10] = m[10];
					  dst[11] = m[11];
					  dst[12] = m[12];
					  dst[13] = m[13];
					  dst[14] = m[14];
					  dst[15] = m[15];
					}

					return dst;
				}
			},
			
			layer : {
				fnEnvi : function( init, obj ){
					
					for( var ii = 0, layerObject = obj.layer.object; ii < layerObject.length ; ii++){
						if( init ===  'add' ){	
							scope.Body.setPosition(
								layerObject[ii] , {
								x : obj.x + layerObject[ii].FixedPosition.x ,
								y : obj.y + layerObject[ii].FixedPosition.y 
							})
							scope.Composite.addBody( scope.engine.world, layerObject[ii]  );
							
						}else if( init === 'remove' ){
							scope.World.remove( scope.engine.world, layerObject[ii] )
						}
					}
				
					//update dungeon order object
					scope.orderObjectFn['value']()
				},
				environment : function( map, body, set ){
					if( body.appear && !body.layer.init ){
						this.fnEnvi( 'add', {
							body : body,
							x : body.x,
							y : body.yMax(),
							layer : body.layer
						})
						body.layer.init = true;
					}else if( !body.appear && body.layer.init ){
						this.fnEnvi( 'remove',  {
							layer : body.layer
						})
						body.layer.init = false;
					}
				
				},
				
				bgStorage : [],
				isVisible : function( element ){
					var screenWidth = scope.browserWidthUpdate,
					screenHeight = scope.browserHeightUpdate;
					
					return ( element.x < screenWidth &&
						element.xMax() > 0 &&
						element.y < screenHeight &&
						element.yMax() > 0 )
				},
				fnBackgr : function( params ){
					
					var self =  this,
					bg = self.bgStorage, temp = [];
					for( var ii = 0; ii <  bg.length ; ii++ ){
						var geo = bg[ii];
						if( self.isVisible( geo ) ){
							
							var geoNeighbor = geo.neighbor;
							 
							for(var jj in geoNeighbor ){
								var neighbor = geoNeighbor[jj];
								if( function(){
									//is this neighbor already registered ?
									for(var kk = 0; kk < bg.length ; kk++ ){
										if ( bg[kk].label === neighbor.label ){
											return false 
										};
									}
									
									switch( jj ) {
										
										case 'right'	: 
											neighbor.y = geo.y 
											neighbor.x = geo.x + 500; break;
										
										case 'left' : 
											neighbor.y = geo.y
											neighbor.x = geo.x - 500; break;	
											
										case 'top' :	
											neighbor.y = geo.y - 500
											neighbor.x = geo.x; break;	
											
										case 'bottom' :	
											neighbor.y = geo.y + 500
											neighbor.x = geo.x;	 break;
									}
									
									return self.isVisible( neighbor ) ? true : false;
									
									
								}() ){
									this.bgStorage.push( neighbor )
								}
							}
							
							
							
							if( params.tickMap <= 0 && params.isTranslate ){
								
								geo.translate({ x: params.staticMoveX , y:params.staticMoveY  })
							}
							
							
							if( params.shakeLen ){
								var shake = params.isShake.shakeCnt[0];
								geo.translate({ x:  shake.posX , y: shake.posY  })
							}
						
							//if(geo.label === 'mapDungeonGa_83') console.log( geo.x );
							geo.update()
							
						}else{
							temp.push( ii )
						}
						
						
					}
					
					//prevent blink while array being spliced		
					
					for( var ii = 0; ii < temp.length ;ii++ ){
						self.bgStorage.splice( temp[ ii ], 1 );
					}		
					
				
				},
				background : function( storage ){
					//reset when update new map
					this.bgStorage.length = 0;
					for( var ii = 0; ii <  storage.length ; ii++ ){
						var geo = storage[ii];
						geo.resetPos();
						if( this.isVisible( geo ) || !geo.install || geo.visible  ){
							geo.update( scope.context );
							this.bgStorage.push( geo )
							
						}
					}
					
				},
			},
			currentMap : 'mapA',
			tickMap : 0,
			tickMinute : 6, //  frame / second
			staticGeometry : {
				storageMap : '',
				storagePassBG : [],
				storagePassBGAfterObject : [],
				storagePortal :'',
				storageSVGPathBuffer :'',
				storageSVGLineBuffer :'',
				storageLayer :'',
				storage : '',
				returnGeometry : function( location, label, isStorageSVG){
					
					if( isStorageSVG  === 'svg' ){
						var cnt = this.storageSVGPathBuffer.get( location )
					}else if( isStorageSVG  === 'portal' ){
						var cnt = this.storagePortal.get( location )
					}else{
						var cnt = this.storage.get( location )
					}
					
					for(var ii = 0; ii < cnt.length ; ii ++){
						if( cnt[ii].label === label ) return cnt[ii];
					}
				},
				storageFn : function( option, cnt, label, location )
				{
					
					function fn( absoluteRange, absoluteScr, neighbor )
					{
						cnt.push({
							visible : false, 
							imgType : option.type  || '',
							attach :  option.attach,
							neighbor : !!neighbor && neighbor || '',
							range : absoluteRange || 0,
							x : 0,
							y : 0,
							install : false,
							drawFn : '',
							width : 0,
							height : 0,
							spawn : '',
							additionalHeight : option.additionalHeight &&  option.additionalHeight || 0,
							render : {
								img : '',
								src : absoluteScr,
							},
							resetPos : function(){
								// reset post is needed when update new map
								if( !!this.spawn ){
									this.x = this.spawn.min.x + this.range - 500;
									this.y = this.spawn.min.y - this.height + ( this.additionalHeight ? this.additionalHeight : 0 );
								}
							},
							xMax : function(){
								return this.x + this.width;
							},
							yMax : function(){
								return this.y + this.height;
							},
							update : function( ctx ){
								if( !this.install ){
									var spawn; 
									this.render.img = scope.getTexture( this.render ,this.render.src );
									
									if( this.imgType === 'svg'){
										spawn = scope[ this.attach ]['value'].bounds;
									}else if( this.attach.indexOf('staticWallOutter') !== -1 ){
										if( 'staticWallOutterBottom' === this.attach){
											spawn = scope.staticWallOutter['value']()[1].bounds;
										}
									}else{
										spawn = scope[ this.attach ]['value'].bounds;
									}
			
									this.spawn = spawn;
									this.drawFn = new scope.draw.enviOrnaments()

									if( option.background ){
										this.width =  500;
										this.height = 500;
									}else{
										this.width =  this.render.img.width
										this.height = this.render.img.height
									}
									
									if( this.imgType === 'svg' ){
										this.x = this.spawn.min.x 
										this.y = this.spawn.min.y 
									}else{
										this.x = this.spawn.min.x + this.range - ( option.repeatX ? option.repeatX : 0 );
										this.y = this.spawn.min.y - this.height + ( option.additionalHeight ?  option.additionalHeight : 0 );
									}

									this.install = true;
									
								}else{
									
									this.render.img = scope.getTexture( this.render ,this.render.src );
									
									this.drawFn.update({
										 img : this.render.textures,
										 context : scope.context,
										 ver : "v1",
										 posX : this.x,
										 posY : this.y,
										 geoWidth : this.width,
										 geoHeight : this.height
									})
								}
							},
							translate : function( translate ){
								//if( location === scope.currentMap ){
									this.x += translate.x;
									this.y += translate.y
								//}

							},
							location : location,
							label : option.label ? option.label : label
						});
					}
				
					if( option.repeat ){
						
						var objRepeat = option.repeat, url, repeatXval = 0;
						for( var ii = 0 ; ii < objRepeat.length ; ii++ ){
							var url = option.scr + objRepeat[ii], 
							neighbor = {
								top : ( option.indexRepeat + 1 <= option.layer.length - 1 ) ?  location + option.layer[ option.indexRepeat + 1 ][ ii ].split('.')[0] : '',
								bottom : ( option.indexRepeat - 1 >= 0 ) ? location + option.layer[ option.indexRepeat - 1 ][ ii ].split('.')[0] : '',
								left : ( ii - 1 >= 0 ) ? location + objRepeat[ ii - 1 ].split('.')[0] : '',
								right : ( ii + 1 <= objRepeat.length - 1 ) ? location + objRepeat[ ii + 1 ].split('.')[0] : '',
							}
							
							option.label = location + objRepeat[ ii ].split('.')[0];
							
							fn( repeatXval+= option.repeatX , url, neighbor );
							
						}
						
						//then replace neighbor string to its own object
						for( var ii = 0, len = cnt.length; ii < len ; ii++ ){
							for(var jj in cnt[ii].neighbor ){
								var neighbor = cnt[ii].neighbor[jj];
								if( neighbor !== '' ){
									for(var kk = 0; kk < len ; kk++ ){
										if( neighbor === cnt[kk].label ){
											cnt[ii].neighbor[jj] = cnt[kk];
										}
									}
								}
							}
						}
						
					}else{
						fn( option.range, option.src )
					}	
					
					
				},
				createEnviPoint : function( location, option ){
					
					var label = option.label ? option.label : scope.uniqueId();
					if( option.type ){
						var cnt = this.storageSVGPathBuffer.get( location ),
						cnt = cnt instanceof Array  ? cnt : [];
						this.storageFn( option, cnt, label, location )
						this.storageSVGPathBuffer.set( location, cnt )
					}else{
						var cnt = this.storage.get( location ),
						cnt = cnt instanceof Array  ? cnt : [];
						this.storageFn( option, cnt, label, location )
						this.storage.set( location, cnt )
					}
					var type = !!option.type ? 'svg' : 'envi'
					return this.returnGeometry( location, label, type )
			
				},
				
				
				createLayer : function( option ){
				
					var cnt = this.storageLayer.get( option.location ),
					label = scope.uniqueId(),
					cnt = cnt instanceof Array  ? cnt : [];
					cnt.push({
						x : -1000,
						y : -1000,
						rangeX : option.rangeX,
						rangeY : option.rangeY,
						layer : option.layer,
						attach : option.attach,
						install : false,
						width : option.width,
						height : option.height,
						xMax : function(){
							return this.x + this.width;
						},
						yMax : function(){
							return this.y + this.height;
						},
						update : function( ctx ){
							if( !this.install ){
								var spawn;
								if( /staticWallOutter/i.test( this.attach ) ){
									if( 'staticWallOutterBottom' === this.attach){
										spawn = scope.staticWallOutter['value']()[1].bounds;
									}
								}else{
									spawn = scope[ this.attach ]['value'].bounds;
								}

								this.x = spawn.min.x + this.rangeX - 15;
								this.y = spawn.min.y - this.height + this.rangeY - 30;
								
								this.install = true;
								
							}
							

						},
						translate : function( translate ){
							this.x += translate.x;
							this.y += translate.y
						},
						color : 'red',
						location : option.location,
						label : option.label ? option.label : label
					})
					
					this.storageLayer.set( option.location, cnt )
					
					return cnt[ cnt.length - 1 ];

				},
				createPortal : function( option ){
				
					var cnt = this.storagePortal.get( option.location ),
					label = scope.uniqueId(),
					cnt = cnt instanceof Array  ? cnt : [];
					cnt.push({
						x : -1000,
						y : -1000,
						attach : option.attach,
						range : option.range || 0,
						install : false,
						delay : true,
						width : option.width,
						height : option.height,
						effect : '',
						xMax : function(){
							return this.x + this.width;
						},
						yMax : function(){
							return this.y + this.height;
						},
						update : function( ctx ){
							if( !this.install ){
								var spawn;
								if( /staticWallOutter/i.test( this.attach ) ){
									if( 'staticWallOutterBottom' === this.attach){
										spawn = scope.staticWallOutter['value']()[1].bounds;
									}
								}else{
									spawn = scope[ this.attach ]['value'].bounds;
								}

								this.x = spawn.min.x + this.range + ( !!option.rangeX ? option.rangeX : 0 )
								this.y = spawn.min.y - this.height + ( !!option.rangeY ? option.rangeY : 0 );
								
								// adding effect
								this.effect = !!option.effect ? (function(){
									return scope[ option.effect ] ? new scope[ option.effect ] : '';
								}()) : '';
								
								this.install = true;
								
								
							}
							
							if( this.isVisible ){
								if( !!this.effect ){
									this.effect.update( ctx, this )
								}else{
									ctx.beginPath()
									ctx.fillStyle = this.color
									ctx.fillRect( this.x, this.y, this.width, this.height );
								}
							}

						},
						translate : function( translate ){
							this.x += translate.x;
							this.y += translate.y
						},
						color : option.color,
						location : option.location,
						isVisible : 'undefined' === typeof option.isVisible && true || option.isVisible,
						locationTarget : !!option.targetLocation ? option.targetLocation : '', // portal or inner portal
						spawnTarget : !!option.spawnTarget ? option.spawnTarget : '', 
						forceGravity : 'undefined' === typeof option.forceGravity && false || option.forceGravity,
						label : label
					})
					this.storagePortal.set( option.location, cnt )
					return this.returnGeometry( option.location, label, 'portal' )
				

				},
				createStoratePassBG : function( params ){
					
					var storage = this[ params.storage ];
					
					storage.push( 
						new function(){
						this.parent = params.parent;
						this.bind = typeof params.bind !== "undefined" ? params.bind : false,
						this.target = params.target;
						this.bgPass = true;
						this.remove = false;
						this.x = params.x;
						this.y = params.y;
						this.fn = params.fn;
						this.fn.target = this;
						this.xMax = function(){
							return this.x ;
						};
						this.yMax = function(){
							return this.y ;
						};
						this.translate = function( translate ){
							
							if( !this.bind ){
							
								this.x += translate.x;
								this.y += translate.y;
								
								if( this.parent ){
									//update parent pos
									this.parent.x = this.x;
									this.parent.y = this.y;
								}
							
							}else{
								this.x = this.target.x;
								this.y = this.target.y;
							}
						}
					})
				},
				createSVGPathBuffer : function( option ){
					
					var cnt = this.storageSVGPathBuffer.get( option.location ),
					cnt = cnt instanceof Array  ? cnt : [];
					 
					cnt.push({
						additionalSize :option.additionalSize,
						parentLabel : option.parentLabel,
						parent : "",
						label : option.label,
						vertices : option.vertices,
						drawLine : "",
						drawLineState : option.drawLine,
						translate : function( translate ){
							
							for( var ii = 0, jj = this.vertices, len = jj.length ; ii < len; ii++ ){
								jj[ii].x += translate.x;
								jj[ii].y += translate.y;
							}
							
							this.x += translate.x;
							this.y += translate.y;
							this.maxX += translate.x;
							this.maxY += translate.y;
							
						},
						xMax : function(){
							return this.maxX;
						},
						yMax : function(){
							return this.maxY;
						},
						install : false,
						update : function (){
							
							if( !this.install ){
								
								var bodies = scope.Composite.allBodies( scope.engine.world ),
								preventDomExeception = false;
								for(var ii = 0, jj = bodies; ii < jj.length; ii++ ){
									if( jj[ii].label === this.parentLabel ){
										
										this.parent = jj[ii];
										break;
									}
								}
								
								//attach
								this.drawLine  = new scope.drawLine( this.parent, this.vertices, "LINE_LOOP", "path", this.additionalSize )	
								
								var bounds = this.parent.bounds;
								this.parent.setVertiecsByPoint = this.drawLine.setVertiecsByPoint;
								
								
								this.x = bounds.min.x;
								this.y = bounds.min.y;
								this.maxX = bounds.max.x;
								this.maxY = bounds.max.y;
								
								this.install = true;
							}else{
								
								this.drawLineState && this.drawLine.update()
							}
						}
					})
					
					this.storageSVGPathBuffer.set( option.location, cnt )
					
				},
				createSVGLineBuffer : function( option ){
					
					var cnt = this.storageSVGLineBuffer.get( option.location ),
					cnt = cnt instanceof Array  ? cnt : [];
					
					cnt.push({
						label : option.label,
						vertices : option.vertices,
						drawLine : "",
						position : "",
						x : 0,
						y : 0,
						xMax : function(){
							return this.maxX;
						},
						yMax : function(){
							return this.maxY;
						},
						setPosition : function( vec ){
							
							var x = vec.x,
							y = vec.y;
							
							//translate to given vector
							for( var ii = 0, jj = this.vertices, len = jj.length ; ii < len; ii++ ){
								jj[ii].x += x;
								jj[ii].y += y;
							}
							
							this.x += x;
							this.y += y;
							this.maxX += x;
							this.maxY += y;
							this.position.x += x;//center
							this.position.y += y; //center
							
						},
						translate : function( translate ){
							
							for( var ii = 0, jj = this.vertices, len = jj.length ; ii < len; ii++ ){
								jj[ii].x += translate.x;
								jj[ii].y += translate.y;
							}
							
							this.x += translate.x; //min
							this.y += translate.y; //min
							this.maxX += translate.x; //max
							this.maxY += translate.y; //max
							this.position.x += translate.x; //center
							this.position.y += translate.y; //center
							
						},
						install : false,
						update : function (){
							if( !this.install ){
								
								//attach
								
								var vertices = this.vertices,
								center = scope.Vertices.centre( vertices );
								
								
								this.xMax = function(){
									return this.maxX;
								};
								this.yMax = function(){
									return this.maxY;
								};
								
								
								var bounds = scope.AI.boundVertexToIndex( vertices )
								this.position = center;
								this.x = vertices[ bounds.min.x ].x;
								this.y = vertices[ bounds.min.y ].y;
								this.maxX = vertices[ bounds.max.x ].x;
								this.maxY = vertices[ bounds.max.y ].y;
								
								this.setPosition({
									x : option.position.x - ( center.x - this.x ),
									y : option.position.y - ( center.y - this.y )
								});
								
								//setup drawLine
								this.drawLine  = new scope.drawLine( this, this.vertices, "LINE_STRIP", "line" );
								
								
								this.install = true;
								
							}else{
								this.drawLine.update()
							}
						}
					})
					
					this.storageSVGLineBuffer.set( option.location, cnt )
					
				},
				createMap : function( option ){
					
					var cnt = this.storageMap.get( option.location ),
					label = scope.uniqueId(),
					cnt = cnt instanceof Array  ? cnt : [];
					cnt.push({
						character : '',
						x : -1000,
						y : -1000,
						visible : true,
						install : false,
						width : 0,
						height : 0,
						drawFn : '',
						scaleMap : "",
						render : {
							textures : '',
							src : option.src,
						},
						xMax : function(){
							return this.x + this.scaleX;
						},
						yMax : function(){
							return this.y + this.scaleY;
						},
						update : function( gl ){
							if( !this.install ){
								var img = scope.getTexture( this.render ,this.render.src );
								this.width =  img.width
								this.height =  img.height
								this.drawFn = new scope.draw.map()
								this.install = true;
								//map size
								this.x = 0;
								this.y = 0;
								this.mapContent = scope.staticAllMap['value'][ option.location ].content ;
								this.character = scope.oval['value'].pions;
								this.scaleMap = scope.scaleMap['value'];
							
							} else {
								
								this.render.textures = scope.getTexture( this.render ,this.render.src );
								
								var scaleMap = this.scaleMap;
								
								if( !scaleMap.close ){
									
									this.drawFn.update({
										 ver : "v3",
										 image :  this.render.textures,
										 screenSizeX : scope.browserWidthUpdate,
										 screenSizeY : scope.browserHeightUpdate,
										 context : gl,
										 posX : this.x,
										 posY : this.y,
										 scaleSize : scaleMap.map,
										 center : scaleMap.centerMap
									}) 
									 
									for ( i = 0, len = scope.orderObj.length; i < len; i++ ) {
										 
										var body = scope.orderObj[i],
										rigBody = body.rigBody;
										
										if( rigBody ){
											
											var isTower = rigBody.isStatic,
											isTowerUnderAttack =  isTower ? body.staticBehave === "attack" : false,
											color = body.isHero ? "blue" :
												isTower ? "tower" : 
												body.behave === 'attack' ? 
												'red' : 'orange';
											
											//map icon body with rigid
											body.mapMark.update({
												 ver : "v1",
												 context : gl,
												 screenSizeX : scope.browserWidthUpdate,
												 pos : body.position,
												 color : color,
												 scaleSize : scaleMap.mark,
												 center : scaleMap.centerMark,
												 markNeedGlow : isTowerUnderAttack
											})
											
											//map icon quest with rigid
											if(  isTower ){
												
												var warning = isTowerUnderAttack;
												
												body.quest.mapMark.update({
													 quest : true,
													 context : gl,
													 screenSizeX : scope.browserWidthUpdate,
													 pos : body.position,
													 characterPos : scope.characterControl.object.position,
													 color : warning ? "arrowHit" : "arrow",
													 colorTarget : body.quest.target,
													 scaleSize : scaleMap.mark,
													 center : scaleMap.centerMark,
													 warning : warning
												})
												
											}
											
											/*if( /spawn/i.test( ii ) 
												&& content.quest 
												&& content.quest.update.length ){
												content.quest.mapMark.update({
													 quest : true,
													 context : ctx,
													 screenSizeX : scope.browserWidthUpdate,
													 pos : content.position,
													 characterPos : this.character.position,
													 color : 'arrow',
													 colorTarget : content.quest.target,
													 scaleSize : scaleMap.mark,
													 center : scaleMap.centerMark
												})
											}*/
										
										}
									
									}
									
								}
							}

						},
						translate : function( translate ){
							this.x += translate.x;
							this.y += translate.y

						},
						location : option.location,
						label : label
					})
					this.storageMap.set( option.location, cnt )
				
				},
			},
			renderInit : function(){
				var scope = this;
				scope.engine = scope.Engine.create();
				scope.runner = scope.Runner.create();

				scope.levelHeight = scope.browserHeightUpdate,
				scope.stage = scope.levelHeight / 4,

				scope.halfCenter = scope.levelHeight / 2,
				scope.halfTopCenter =  scope.halfCenter / 2 ,
				scope.halfTopTop =  scope.halfCenter - scope.halfCenter,
				scope.halfBottom = scope.halfCenter / 2 + scope.halfCenter,
				scope.halfBottomTop = ( scope.halfCenter / 2 ) /  2 + scope.halfCenter,
				scope.halfBottomBottom  = scope.halfBottom + scope.stage

				scope.halfBottomLvl2 =  -scope.stage;
				scope.halfCenterLvl2 =  -scope.stage +  -scope.stage,
				scope.halfTopCenterLvl2 =  -scope.stage +  -scope.stage +  -scope.stage,
				scope.halfTopTopLvl2 = -scope.stage +  -scope.stage +  -scope.stage * 2,
				scope.halfBottomTopLvl2 = ( -scope.stage + -scope.stage ) / 2

			},
			resize : function(){
				//resize onload
				scope.that( scope )
					.invokeWith( '_windowResize' )

				//resize manual
				scope.that( window )
					.use('attachListener', [ 'resize', function(){
						scope.that( scope )
							.invokeWith( '_windowResize' )
					}])
			},
			applyGravity : function( body ){
				if( body && body.forceGravity && !( body.isStatic || body.isSleeping ) ){
					var gravityScale = 0.001;
					var gravityY = /staticOriPassBGBridge/i.test( body.label ) ? 1 : 2;
					body.force.y += body.mass * gravityY * gravityScale;
					body.force.x += body.mass * 0 * gravityScale;
				}
			},
			filterStrength : 20,
			frameTime : 0,
			lastLoop : new Date,
			thisLoop : '' 
		};

		for(var ii = arguments, jj = ii.length; jj--;)
		{
			if('function' === typeof ii[jj])
			{
				ii[jj].apply(null, [scope, _obj])
				ii[jj].apply(null, [scope, obj])

				scope.staticGeometry.storage = new scope.storageState['value'];
				scope.staticGeometry.storageLayer = new scope.storageState['value'];
				scope.staticGeometry.storageSVGPathBuffer = new scope.storageState['value'];
				scope.staticGeometry.storageSVGLineBuffer = new scope.storageState['value'];
				scope.staticGeometry.storagePortal = new scope.storageState['value'];
				scope.staticGeometry.storageMap = new scope.storageState['value'];
				scope.glTest = {};
				scope.globalImagePair = new scope.storageState['value'];
				scope.globalImage = new scope.storageState['value'];
				scope.globalAudio = new scope.storageState['value'];
				scope.intervalList = {};
				scope.intervalListGlobal["value"] = scope.intervalList;
				
				// this matirx will convert from pixels to clip space
				scope.orthographic =  scope.webglM4.orthographic(0, scope.canvas.width, scope.canvas.height, 0, -1, 1);
				
				
				scope.attachListener( window, 'resize', function(){
					scope.browserWidthUpdate = scope.browserWidth();
					scope.browserHeightUpdate = scope.browserHeight(); 
					
					scope.context.viewport( 0, 0, scope.context.canvas.width, scope.context.canvas.height + 1 );
					scope.orthographic =  scope.webglM4.orthographic(0, scope.canvas.width, scope.canvas.height, 0, -1, 1);
					
					scope.objTranslate['value'].isCenter.state = true
				  
				})
				
				
				
				
				performance.now = (function() {
					return performance.now       ||
						performance.mozNow    ||
						performance.msNow     ||
						performance.oNow      ||
						performance.webkitNow ||            
						Date.now  /*none found - fallback to browser default */
				})();
			
				//setup draw properties
				scope.webglUtils.webglCreateTexShader( scope.context, scope, [
					{
						prop : "glDrawV1nV2",
						shader : ["drawImage-vertex-shader", "drawImage-fragment-shader"]
					},
					{ 
						prop : "glDrawV3",
						shader : ["drawImage-vertex-shader-2", "drawImage-fragment-shader-2"]
					}
				]);
				
				//setup draw line properties 
				scope.webglUtils.webglCreateLineShader( scope.context, scope, [
					{
						prop : "glLine",
						shader : ["line-vertex-shader", "line-fragment-shader"]
					}
				]);
				
				/*
				scope.rotateTest = {
					rad : 0,
					fn : function(){
						this.rad += 0.01;
						if( this.rad >= 1 ){
							this.rad = -1
						}
					}
				}
				
				
				scope.testV3 = {
					draw  : new scope.draw.enviOrnaments(),
					render : {
						textures : "",
						src : 'assets/2d/cover.png',
					}
				}
				scope.getTexture( scope.testV3.render, scope.testV3.render.src )
				*/
				
				//convert to clip space
				scope.context.viewport( 0, 0, scope.context.canvas.width, scope.context.canvas.height + 1 );
				
				
				// Tell WebGL how to convert from clip space to pixels
				scope.context.clear( scope.context.COLOR_BUFFER_BIT );
				
				scope.geometries();
				scope.initilizeObject();
				scope.resize();
				scope.statics();
				scope.monster();
				
				//scope.loadGame()
				//scope.drawing();
				
				/**/
			}
		}

	}
	
	_owlBird.animation.prototype = 
	{		
			play : function(){
				var scope = this,
				fps, fpsInterval, startTime, now, then, elapsed;
				
				
				function animate( now ) {
					// request another frame
					requestAnimationFrame(animate);
					
					// calc elapsed time since last loop

					elapsed = now - then;

					// if enough time has elapsed, draw the next frame

					if (elapsed > fpsInterval) {
						// Get ready for next frame by setting then=now, but also adjust for your
						// specified fpsInterval not being a multiple of RAF's interval (16.7ms)
						then = now - ( elapsed % fpsInterval );
						
						// Put your drawing code here
						//scope.thisFrameTime = ( scope.thisLoop = new Date ) - scope.lastLoop;
						//scope.frameTime += ( scope.thisFrameTime - scope.frameTime) / scope.filterStrength;
						//scope.lastLoop = scope.thisLoop;
						//scope.isLanscape =  scope.browserWidth() > scope.browserHeight(); //isLanscape
						 
					    if( !scope.blockRender ){
 
							scope.drawing();
							scope.characterControl.update()
							scope.monsterControl.update()
							scope.skillCasting()
							scope.setIntervalFn()
							
						
						}

					}
				}
				
				// initialize the timer variables and start the animation
				
				function startAnimating(fps) {
					fpsInterval = 1000 / fps;
					then = window.performance.now();
					startTime = then;
					animate();
				}
				
				
				startAnimating( scope.fps );
				
			},
			drawing : function(){
				
				var scope = this,
				gl = scope.context,
				body,
				part,
				i,
				k,
				isLayer,
				objTranslate = scope.objDrawTranslate;
				 
				var map = scope.activeMap['value'],
				isCurrentMap = scope.currentMap !== map,
				character = scope.mainCharacter,
				bodies = scope.orderObj,// /dungeon/i.test( map ) ? scope.orderObj : scope.Composite.allBodies( scope.engine.world ),
				staticStateX = objTranslate.staticObjStateX,
				staticAllX = objTranslate.staticObjAllX,
				staticStateY = objTranslate.staticObjStateY,
				isShake = objTranslate.isShake, 
				shakeLen = isShake.shakeCnt.length,
				characterTranslate = objTranslate.charaTranslate,
				staticValY = 0,
				isTranslate = ( staticStateX || staticStateY ),
				staticMoveX = !scope.bugTranslate ? scope.bugTranslate : 
					staticStateX === 'left' ? objTranslate.staticObjMoveX :
					staticStateX === 'right' ? -objTranslate.staticObjMoveX : 0, // << becarefull with this statement
				staticMoveY = !scope.bugTranslate ? scope.bugTranslate : 
					staticStateY === 'up' ? objTranslate.staticObjMoveY :
					staticStateY === 'down' ? -objTranslate.staticObjMoveY : 0,
				screenWidth = scope.browserWidthUpdate,
				screenHeight = scope.browserHeightUpdate,
				storagePassBGState = true,
				storagePassBGAfterObjectState = true,
				characterStat = '',// scope.characterStatus['value'];
				storagePassBG = scope.staticGeometry.storagePassBG,
				storagePassBGAfterObject = scope.staticGeometry.storagePassBGAfterObject;	
				
				scope.Runner.tick( scope.runner, scope.engine, scope.fps, {
					map : map
				});
				
				//prevent break img
				if( isCurrentMap ){
					scope.enviOrnaments =  scope.staticGeometry.storage.get( map );
					scope.enviLayer = scope.staticGeometry.storageLayer.get( map );
					scope.enviMiniMap = scope.staticGeometry.storageMap.get( map );
					scope.storageSVGPathBuffer = scope.staticGeometry.storageSVGPathBuffer.get( map );
					scope.storageSVGLineBuffer = scope.staticGeometry.storageSVGLineBuffer.get( map );
					scope.textures( map );	
					scope.allMapContent = scope.staticAllMap['value'][ map ];
					scope.currentMap = map;
					scope.tickMap = 10;
					
				}
				
				if( scope.tickMap >  -10 ){
					
					if(  scope.tickMap === 0  ){
						var staticStateX = true,
						staticAllX = true,
						isTranslate = true,
						startX = scope.browserWidthUpdate / 2,
						startY = scope.browserHeightUpdate / 2,
						destX = character.position.x,
						destY = character.position.y,
						dx = startX - destX,
						dy = startY - destY;
						staticMoveX = dx;
						staticMoveY = dy;
						
						
					}else if(  scope.tickMap === -1  ){
						
						var outterWall = scope.staticWallOutter['value'](),
						screen = {
							overlapX : function( outterWall ){
								return outterWall.bounds.min.x < screenWidth &&
								outterWall.bounds.max.x > 0;
							},
							overlapY : function( outterWall ){
								return outterWall.bounds.min.y < screenHeight &&
									outterWall.bounds.max.y > 0;
							}
						},
						checkWall = false,
						startX = scope.browserWidthUpdate / 2,
						startY = scope.browserHeightUpdate / 2,
						destX = character.position.x,
						destY = character.position.y, dx = 0, dy = 0;
						for(var ii = 0, jj = outterWall.length; ii < jj; ii++ ){
							if( /left/i.test( outterWall[ii].label ) && screen.overlapX( outterWall[ii] ) ){ 
								dx = startX - outterWall[ii].bounds.max.x - staticMoveX - destX;
								checkWall = true;
							} else if( /right/i.test( outterWall[ii].label ) && screen.overlapX( outterWall[ii] ) ){
								dx =  startX - Math.abs( outterWall[ii].bounds.min.x - staticMoveX - destX ) ;
								checkWall = true;
							} else if( /bottom/i.test( outterWall[ii].label ) && screen.overlapY( outterWall[ii] ) ){
								dy = ( startY - outterWall[ii].bounds.min.y - staticMoveY ) + destY ;
								checkWall = true;
							} else if( /top/i.test( outterWall[ii].label ) && screen.overlapY( outterWall[ii] )){
								dy = startY - outterWall[ii].bounds.max.y  - staticMoveY - destY;
								checkWall = true;
							}
						}
						
						
						if( checkWall ){
							var staticStateX = true,
							staticAllX = true,
							isTranslate = true,
							staticMoveX = dx;
							staticMoveY = dy;
						}

						
					}
					
						
					/**/
					
					scope.tickMap--;
					scope.layer.background( scope.enviOrnaments );
					
					
					// close loading sceen/
					if(  scope.tickMap === -9  ){
						
						scope.addClass(  scope.qs("loading-assets"), "hidden" );
						
						
						//reveal gui elements
						scope.removeClass( scope.id('nav'), 'hidden');
						scope.removeClass( scope.qs('nav-left'), 'hidden');
						scope.removeClass( scope.qs('header-nav'), 'hidden');
						scope.removeClass( scope.qs('attack-right-nav'), 'hidden');
						scope.removeClass( scope.qs('auto-skill-nav'), 'hidden');
						scope.removeClass( scope.qs('auto-switch-nav'), 'hidden');
						scope.removeClass( scope.qs('switch-right-nav'), 'hidden');
						scope.removeClass( scope.qs('controller-appear'), 'hidden');
						
						
					}
					
				}
				
				function environmentFn( enviArr, length )
				{
					if( enviArr  ){
				
						for( var ii = 0; ii <  enviArr.length ; ii++ ){
							var geo = enviArr[ii];
							if( scope.tickMap <= 0 && isTranslate ){
								
								geo.translate({ x: staticMoveX, y : staticMoveY  });
								
							}
							
							if( geo.x < screenWidth &&
								geo.xMax() > 0 &&
								geo.y < screenHeight &&
								geo.yMax() > 0 || !geo.install || geo.visible ){
								
								if( shakeLen ){
									var shake = isShake.shakeCnt[0];
									geo.translate({ x:  shake.posX , y: shake.posY   })
								}

								if( geo.bgPass ){ 
									if( geo.fn.update( gl, geo.parent ) ){
										geo.remove = true;
										//enviArr.splice( ii, 1);
									};
								} else{ 
									geo.appear =  true;
									geo.update( gl );
									geo.layer && scope.layer.environment( scope.currentMap, geo);
								}
							}else if( geo.appear ){
								geo.appear =  false;
								geo.layer && scope.layer.environment( scope.currentMap, geo );
							}
						}
					}
				}
				

				scope.layer.fnBackgr({
					tickMap : scope.tickMap,
					isTranslate : isTranslate,
					staticAllX : staticAllX,
					staticStateX : staticStateX,
					staticMoveX : staticMoveX,
					staticMoveY : staticMoveY,
					shakeLen : shakeLen,
					isShake : isShake
					
				})
				
				for ( i = 0, len = bodies.length; i < len; i++ ) {
					body = bodies[i];	
			
					
					var rigBody = body.rigBody;
					 
					if( isTranslate && scope.tickMap <= 0 ){
						
						body.visible = body.bounds.min.x < screenWidth 
						&& body.bounds.max.x > 0 
						&& body.bounds.min.y < screenHeight 
						&& body.bounds.max.y > 0; 
						 
						scope.Body.translate( bodies[i], { x: staticMoveX , y: staticMoveY  });
						
					}else if( !body.visible ){ // new object added
						
						body.visible = body.bounds.min.x < screenWidth 
						&& body.bounds.max.x > 0 
						&& body.bounds.min.y < screenHeight 
						&& body.bounds.max.y > 0; 
					}
					
					if( body.visible || rigBody ){	// object pass to object which have rigBody
						
						if( rigBody && !body.statParameters.mainCharacter ){
							rigBody.buff.update();
							rigBody.displayBar();
							rigBody.hitNumberFn();
						}
						 	
						if( shakeLen  ){
							var shake = isShake.shakeCnt[0];
							scope.Body.translate( bodies[i], { x: shake.posX , y : shake.posY  });
						}
						
						
						if( storagePassBGState ){
								
							environmentFn( storagePassBG );
							var lengthRemove = 0;
							for( var oo = 0; oo < storagePassBG.length; oo++ ){
								if( storagePassBG[ oo ].remove ) 
									storagePassBG.splice( oo, 1 ); //lengthRemove++;
							}
							storagePassBGState = false;
						}

						// handle compound parts
						
						/*
						for (var k = body.parts.length > 1 ? 1 : 0, l = body.parts.length; k < l; k++) {
							part = body.parts[k];
						}*/
						
						if ( body.isSpriteRender || body.render.sprite && body.render.sprite.texture ) {
							// body sprite
							if( 'undefined' === typeof body.render.texture  )
							{
								if( body.name === "itemWithAngle" ){
									body.render[ 'textureFn' ] =  new scope.draw.enviOrnaments;
								}else if( body.name === "item"  ){
									body.render[ 'textureFn' ] =  new scope.draw.generalDrawImage;
									
								}else{
									body.render[ 'textureFn' ] =  new scope.draw.monsterGeneral;
									body.render[ 'prevState' ] = 'idle';
								}
								body.render[ 'texture' ] =  '';
								body.render[ 'renderObj' ] = {};
								body.opacity = 1.0;
								
								body.isHero = /hero/i.test( body.label );
								body.isSpriteRender = body.render.sprite && body.render.sprite.texture;
								 
								
							}
							
							var bodyRender = body.render,
							sprite = bodyRender.sprite,
							texture = scope.getTexture( bodyRender, sprite.texture, false,  body.initialName ), isTexture,
							draw = bodyRender.textureFn, behaveRig,
							renderObj = bodyRender.renderObj;

								
							if( body.behave ){
								
								var isOvalStateStorage = body.statParameters.mainCharacter ? "characterState" : body.stateStorage,
								draw = bodyRender.textureFn,
								state = scope[ isOvalStateStorage ].get( body.label ),
								state = state === "turn" ? bodyRender[ 'prevState' ] : state ,
								
								behaveRig = bodyRender.behaveRig[ state ];
							 
								if( state ){
									isTexture =  state.indexOf('textureNeedChange') !== -1;
									
									if( isTexture ){
										
										texture = scope.getTexture( bodyRender, sprite.texture, state, body.initialName );
										body.bitmap = state;
										scope[  isOvalStateStorage ].set(  body.label, bodyRender[ 'prevState' ] );
										
										behaveRig = bodyRender.behaveRig[ bodyRender[ 'prevState' ] ];// replace undefined object
									}
									
									
									renderObj.context = gl;
									renderObj.ver = "v3";
									renderObj.positionX = body.position.x;
									renderObj.positionY = body.position.y;
									renderObj.image = texture;
									renderObj.sprite = sprite;
									renderObj.additionalBoundsWidthValue = body.additionalBoundsWidthValue ? body.additionalBoundsWidthValue : 0;
									renderObj.additionalBoundsHeightValue = body.additionalBoundsHeightValue;
									renderObj.state = state;
									renderObj.behaveRig = behaveRig;
									renderObj.renderObj = bodyRender;
									renderObj.behave = body.behave;
									renderObj.visible = body.visible;
									renderObj.angleInRadians = body.angleInRadians ? body.angleInRadians : 0;
								
									
									!isTexture && ( bodyRender[ 'prevState' ] = state );
								
									if( draw.glProp ){
										
										gl.useProgram( draw.glProp.program );
										gl.uniform1f( draw.glProp.alphaLocation, body.opacity );
										
										draw.update( renderObj );
										
									}else{
										
										draw.update( renderObj );
										
									}
									 
									
								}
								
								
							}else if( body.name === "itemWithAngle" ){ // item with angle is rendered here			
			
								var texture = scope.getTexture( bodyRender, sprite.texture );
								
								renderObj.context = gl;
								renderObj.ver = "v3";
								renderObj.img = texture;
								renderObj.posX = 0;
								renderObj.posY = 0;
								renderObj.srcWidth = texture.width;
								renderObj.srcHeight = texture.height;
								renderObj.dstX = body.position.x - texture.width / 2;
								renderObj.dstY = body.position.y - texture.height / 2;
								renderObj.dstWidth = texture.width ;
								renderObj.dstHeight = texture.height ;
								renderObj.angleInRadians = body.angleInRadians ? body.angleInRadians : 0;
								renderObj.visible = true;
								
								draw.update( renderObj )
								
								
							}else{ // item is rendered here
								
								var texture = scope.getTexture( bodyRender, sprite.texture );
								
								renderObj.image = texture;
								renderObj.gl = gl;
								renderObj.imagePosX = 0;
								renderObj.imagePosY = 0,
								renderObj.posX = body.position.x;
								renderObj.posY = body.position.y;
								renderObj.scaleBefore = 0;
								renderObj.scaleX = 0;
								renderObj.scaleY = 0;
								renderObj.offsetX = 0.1;
								renderObj.offsetY = 0.1;
								renderObj.visible = body.visible;
								
								draw.update( renderObj )
								
							}
							
							 

						}
							
							
						
						
						/*
						if( /buffer/i.test( body.label ) ){
							
							 body.drawLine.update();
						
						}
						*/
						
						//draw texture
						if( body.src  ){
							
							var texture = scope.allMapContent.textures,
							renderObj = texture.renderObj;
							renderObj.isVisible = body.visible;
							renderObj.label = body.label;
							renderObj.context = gl;
							renderObj.posX = body.bounds.min.x;
							renderObj.posY = body.bounds.min.y;
							renderObj.fixedBounds = {
								bool : body.fixedBounds && true || false,
								value : body.fixedBounds
							};
							renderObj.object = body;
							
							
							texture.update( renderObj );
						

						}
						
						scope.applyGravity( body );
						
					}else if( body.visible ){
						body.visible =  false;
					}
				
				
				}
				
				environmentFn( storagePassBGAfterObject );
			 
				
				for( var oo = 0; oo < storagePassBGAfterObject.length; oo++ ){
					if( storagePassBGAfterObject[ oo ].remove ) 
						storagePassBGAfterObject.splice( oo, 1 );  
				}
				
				environmentFn( scope.storageSVGPathBuffer )
				//environmentFn( scope.storageSVGLineBuffer )
				environmentFn( scope.enviLayer )
				environmentFn( scope.enviMiniMap )
				
				if( shakeLen ){
					if( isShake.shakeCnt[0].update() ){
						isShake.shakeCnt.splice( 0, 1 );
					}
				} 
				
				/*
				
				scope.rotateTest.fn()
				
				
				scope.testV3.draw.update({
					img : scope.testV3.render.textures,
					context : gl,
					ver : "v2",
					width : 0,
					height : 0,
					posX : 100,
					posY : 100,
					scaleX :scope.testV3.render.textures.width,
					scaleY :scope.testV3.render.textures.height,
					angleInRadians : scope.rotateTest.rad
				})
				
				scope.testV3.draw.update({
					img : scope.testV3.render.textures,
					context : gl,
					ver : "v3",
					width : 0,
					height : 0,
					posX : 0,
					posY : 0,
					srcWidth : scope.testV3.render.textures.width, 
					srcHeight : scope.testV3.render.textures.height, 
					dstX : 100, 
					dstY : 100, 
					dstWidth : scope.testV3.render.textures.width, 
					dstHeight :scope.testV3.render.textures.height,
				})
				*/
			},
			
			textures : function( map ){
				
				
				var scope =  this,
				onePx = scope.path+'1px.png';
				var content = scope.staticAllMap['value'][ map ].content,
				newTexture = {}, label;
				
				//texture already replaced
				if( scope.staticAllMap['value'][ map ].textures ) return true;
				 
				for(var kk in content ) if( kk in content ){
					var t = {};
					if( content[kk] instanceof Array ){
						for(var ll = 0 ; ll < content[kk].length ; ll++ ){
							if( /layer/i.test( kk ) && content[kk][ll].layer ){
								for(var mm = 0, layer = content[kk][ll].layer.object ; mm < layer.length; mm++ ){
									label = layer[mm].label;
									t[ label ] = {
										textures : '',
										src : layer[mm].src ? layer[mm].src : onePx
									};
									
									//scope.getTexture( t[ label ] , t[ label ].src );
									scope.extend( newTexture, t);
								}
							}else{
								label = content[kk][ll].label;
								t[ label ] = {
									textures : '',
									src : content[kk][ll].src ? content[kk][ll].src : onePx
								};
								//scope.getTexture( t[ label ] , t[ label ].src );
								scope.extend( newTexture, t);
							}
							
						}
					}else{
						label = content[kk].label;
						t[ label ] = {
							textures : '',
							src : !!content[ kk ].src ? content[ kk ].src : onePx
						};
						//scope.getTexture( t[ label ] , t[ label ].src );
						scope.extend( newTexture, t)
					};
					
					//layer content can be accessed at layergroup;
					
					
					
				}
				
				var textureObj = scope.staticAllMap['value'][ map ];
				
				textureObj.textures = newTexture;
				
				textureObj.textures.renderObj = {};
				textureObj.textures.drawObj = {};
				
				textureObj.textures.drawImage = new scope.draw.enviOrnaments;
				textureObj.textures.update =  function( options )
				{
				
					if( this[ options.label ] ){
						var wall = this[ options.label ], repeat, drawObj = this.drawObj;
						
						//fixed overlap sprite
						if( options.fixedBounds.bool ){
							options.posY += options.fixedBounds.value;
						}
					 
						if( options.isVisible  ){ 
							
							drawObj.img = scope.getTexture( wall ,wall.src ); //wall.textures, 
							drawObj.context = scope.context;
							drawObj.ver = "v1";
							drawObj.posX = options.posX;
							drawObj.posY = options.posY;
							
							this.drawImage.update( drawObj );
						}
						
						scope.bugTranslate = 1;
					}
				}
				
				
				
				newTexture = {}
			},
			
			loadGame : function( map, params ){
				//strech canvas before play
				scope.canvas.width = scope.browserWidth();
				scope.canvas.height =  scope.browserHeight() + 1;
				  
				scope.activeMap['value'] = map;
				
				scope.textures( map )
				
				scope.objDrawTranslate = scope.objTranslate['value'];
				scope.mainCharacter = scope.oval['value'];
				
				scope.allMapContent = scope.staticAllMap['value'][ map ];
				 
				//clear All Object .. development object
				scope.staticControl.installMapObject( 'mapA', 'remove' )
				
				//add load Object
				scope.staticControl.installMapObject( map, 'add' );
				
				//start download assets
				scope.screenTransition( "download", map, function(){
					
					setTimeout(function(){
						
						//msg quest
						scope.pushMsgText['value']( owlData.lang.fn( "gui", "questAlert", "detail" ) , 200, "info", function(){
							
							scope.addClass( scope.qs("info-remaining"), "show" )
								
						});	
			
						setTimeout(function(){
							//add gold
							var goldHero = localStorage.getItem( 'goldHero' ),
							heroLeader = scope.characterControl.bossObject,
							heroPawn = function(){
								var pawns = heroLeader.pions;
								for( var ii = 0 , jj = pawns.length ; ii < jj ; ii++ ){
									if( /hero/i.test( pawns[ii].label ) ){
										return pawns[ii];
									}
								}
							}(),
							goldHeroLeader = 0,
							goldHeroPawn = 0;
							
							if( goldHero ){
									
								var format = JSON.parse( goldHero );
								
								if( /armor/i.test(  heroLeader.label ) ){
									heroLeader.statParameters.gold = format.heroArmor;
									heroPawn.statParameters.gold = format.heroArcher;
								}else{
									heroLeader.statParameters.gold = format.heroArcher;
									heroPawn.statParameters.gold = format.heroArmor;
								}
								
								goldHeroLeader = heroLeader.statParameters.gold;
								goldHeroPawn = heroPawn.statParameters.gold;
							}
							
							var msgHeroLeader =  goldHeroLeader + owlData.lang.fn( "gui", "goldMining", "addGold" ) + heroLeader.statParameters.name,
							msgHeroPawn = goldHeroPawn +  owlData.lang.fn( "gui", "goldMining", "addGold" ) + heroPawn.statParameters.name
							
							scope.pushMsgText['value']( msgHeroLeader , 200, "info", function(){
								
								scope.infoLogFn['value']({
									title : 'regular-title',
									text : {
										yellow : msgHeroLeader
									}
								})
									
							});
							
							setTimeout(function(){
								
								scope.pushMsgText['value']( msgHeroPawn , 200, "info", function(){
								
									scope.infoLogFn['value']({
										title : 'regular-title',
										text : {
											yellow : msgHeroPawn
										}
									})
										
								});
							
							},4000)  // msg gold hero 2
						
						},5000) // msg gold hero 1
					
					},3000) // msg quest
					
					scope.play();
					
				})
				
				 
			},
			
			setIntervalFn : function(){
				 
				var fnQueue = scope.intervalList;
				
				for( var ii in fnQueue ){
					
					var item = fnQueue[ii]
					
					if( item.tick > 0 ){
						item.tick--
					}else if( item.always ){
						item.fn();
						item.tick = item.tickUpdate 
					}else{
						
						item.fn();
						delete fnQueue[ii]
					}
					
				}
				
			},
			
			monster : function(){
				var scope = this, _obj;
				
				_obj = {
					interval : 0,
					items : function( self, initial, params )
					{
						self.coin.spawnTotal = 1,
						spawnX = initial.position.x,
						spawnY = initial.position.y;
						var obj = new self.coin.create( spawnX + scope.random( 50, -50  ), spawnY + scope.random( 30, -30 ) );
						
						if( initial.rigBody.monsterParameters.coin ){
							obj.object.coinVal = initial.rigBody.monsterParameters.coin;
						}
						
						self.itemTemp.push( obj );
						scope.World.add( scope.staticWorld['value'], obj.object );
						
						//item
						if( params ){
							for( var ii = 0, jj = params.item.length; ii < jj ; ii++ ){
								var itemName = params.item[ii].itemName,
								spawn = params.item[ii].spawn,
								prob = params.item[ii].prob;
								texture = params.item[ii].texture
								
								if( ( Math.random() * 100 ) <= prob ){
									var obj = new self.item.create( 
										spawnX + scope.random( 50, -50 ), 
										spawnY + scope.random( 30, -30 ),
										itemName,
										texture
									);
									
									obj.object.itemVal = scope.random( spawn.max, spawn.min );
									
									self.itemTemp.push( obj );
									scope.World.add( scope.staticWorld['value'], obj.object );
								}
							}
						}
						
					},
					 
					generateAIDataFrame : function( params, selecetedAIParams ){
						self : for( var ii in owlData.frame.data ){
							if( ii === selecetedAIParams ){
								params.aiParams = owlData.frame.data[ii];
								 
								break self;
							}
						}
						
						console.log( this )
					},
					
					generateAIRuntime : function( params, initAiParent, bossLabel ){
						
						var initArr = this[ initAiParent ], objArr;
						self : for(var ii = 0, jj = initArr; ii < jj.length ; ii++ ){
							objArr = jj[ii].monsters
							for( var kk = 0; kk < objArr.length ; kk++ ){
								if( objArr[kk].object.label === bossLabel ){
									break self ;
								}
							}
						}
						
						params.aIParent = objArr;
						
					},
					createAINpc : function( options ){
						
						//generate data frame options.aiParams ( initial Pawn spawn ) from owlData.frame.data into this;
						this.generateAIDataFrame( options, options.aiParams );
						
						//find boss's runtime in array , aiParent ( initial boss spawn )
						this.generateAIRuntime ( options, options.aIParent, options.objBoss.label )
						
						
						var dtectX = options.spawn.x,
						dtectY = options.spawn.y,
						init = options.aiParams[1], 
						additionalBoundsValue = options.aiParams[2], 
						additionalBoundsWidthValue = options.aiParams[3], 
						additionalBoundsHeightValue = options.aiParams[4], 
						behaveRig = options.aiParams[5], 
						aIParent = options.aIParent, //boss runtime
						forceGravity = options.forceGravity,
						spawnTotal = options.spawnTotal,
						objBoss = options.objBoss, 
						aIParentTemp = [],
						play, objPlay;
						 
						for(var jj = 0; jj < spawnTotal ; jj++ ){
												
							play = new this[ 'monster'+ scope.ucFirst( init ) ]({
								location : scope.currentMap,
								objSpawn : objBoss,
								pitboss : false
							})
							objPlay = scope.staticGeneralMonster['value']( init, additionalBoundsValue, additionalBoundsWidthValue, additionalBoundsHeightValue, behaveRig )
					
							//forceGravity, combine isometric and sidescrolng
							if( forceGravity ){
								objPlay.forceGravity = true;
							}
						 
							aIParentTemp.push({
								play : play,
								object : objPlay,
								x : dtectX,
								y : dtectY
							});
							
							
							//push objectPlay to obParent as pawn;
							if( !objBoss.pions ){
								objBoss.pions = [];
							}
							
							//caller need this
							options.objPawns.push( objPlay );
							
							this.interval = 0;
							
							//install first load
							for(var kk = 0; kk < spawnTotal ; kk++ ){
								var x = aIParentTemp[kk].x , y = aIParentTemp[kk].y, object = aIParentTemp[kk].object;
							
								scope.World.add( scope.staticWorld['value'], object );

								aIParentTemp[kk].play.update( this, x, y, object, this.interval += 10, this.items, objBoss );
								
							}
						};
						
						
						//push rigBody to objParent runtime
						aIParentTemp.forEach(function( obj ){
							aIParent.push( obj );
						})
						
						
						aIParentTemp.length = 0;
						
					},
					spawnMonster : function( activeMap, spawnObj, charX, charY, init, additionalBoundsValue, additionalBoundsWidthValue, additionalBoundsHeightValue, behaveRig, initialSpawn ){
						 
						 
						//console.log( spawnObj )
						for( var ii = 0, len = spawnObj.length; ii < len ; ii++ )
						{	 
							var obj = spawnObj[ii];
							
							if( obj.freeze ) continue;
									
							if( obj.location === activeMap ){
								
								if( !obj.install ){
									 
									obj.name && 
									scope.pushMsgText['value']( owlData.lang.fn( "gui", "questAlertB", "detail" ) +obj.monsterLevel+", "+ obj.name+ owlData.lang.fn( "gui", "questAlertC", "detail" ) , 150 );
										 
									var dtectX = obj.objectSpawn.position.x,
									dtectY = obj.objectSpawn.position.y,
									width = scope.browserWidthUpdate,
									posX = Math.abs( charX - dtectX ),
									posY = Math.abs( charY - dtectY ),
									play, objPlay, 
									pionsBounds = function( pionConstructor ){
										var selectedSpawn = this.variablesMonsterSpawn( activeMap ),
										pionInit = pionConstructor.split('monster').join('').toLowerCase(),
										bounds = {};
										
										 for(var ii = 0, jj = selectedSpawn.length; ii < jj ; ii++ ){
											var variables =  selectedSpawn[ii];
											if( pionInit === variables[1].toLowerCase() ){
												bounds.additionalBoundsValue = variables[2]; 
												bounds.additionalBoundsWidthValue = variables[3]; 
												bounds.additionalBoundsHeightValue = variables[4];
												bounds.behaveRig = variables[5];
												return bounds;
											}
										}
									}.bind(this);
										
									
									if( true )// posX < width + width / 4 && posY < scope.stage )
									{
										for(var jj = 0; jj < obj.spawnTotal ; jj++ ){
											
												
											play = new this[ 'monster'+ scope.ucFirst( init ) ]({
												location : obj.location,
												objSpawn : obj.objectSpawn,
												pitboss : obj.pions ? true : false
											})
											objPlay = scope.staticGeneralMonster['value']( init, additionalBoundsValue, additionalBoundsWidthValue, additionalBoundsHeightValue, behaveRig )
									
											
											if( /dungeon/i.test(activeMap) && !obj.forceGravity ){
												
												if( obj.position === "fixed" ){
													var rangeX = dtectX ;
													rangeY = dtectY ;
												}else{
													var rangeX = dtectX + scope.random( 250, -250 ),
													rangeY = dtectY + scope.random( 250, -250 );
												}
												
											}else{
												var rangeX =  dtectX += scope.random( 150, -150 ),
												rangeY = dtectY - 100;
												
												//forceGravity, combine isometric and sidescrolng
												if( obj.forceGravity ){
													objPlay.forceGravity = true;
													rangeY = dtectY;
												}
												
											}
											
											play.initialSpawn = initialSpawn;
											
											obj.monsters.push({
												play : play,
												object : objPlay,
												x : rangeX,
												y : rangeY
											})
										}

										//install first load
										var monsters = obj.monsters;
										this.interval = 0;
											
										
										for(var kk = 0; kk < obj.spawnTotal ; kk++ ){
											var x = monsters[kk].x , y = monsters[kk].y, object = monsters[kk].object;
										 
											scope.World.add( scope.staticWorld['value'], object )
											
											monsters[kk].play.update( this, x, y, object, this.interval += 10, this.items );
											 
											
											// boss only 
											if( obj.pions ) 
											{
												for(var ll in obj.pions )
												{
													var boss = objPlay
													pionX = boss.position.x,
													pionY = boss.position.y,
													monsterConstructor = this[ll],
													staticMonsterConstructor = scope.staticGeneralMonster['value'],
													pionsSpawnTotal = obj.pions[ll],
													temp = [],
													interval = 5,
													pionName =  init;
													
													//init for general monster 
													var pionName = ll.split('monster').join('');
													pionName = pionName.charAt(0).toLowerCase() + pionName.slice(1);
												
													for(var nn = 0; nn < pionsSpawnTotal ; nn++ )
													{
														var pionPlay = new monsterConstructor({
															location : obj.location,
															objSpawn : boss,
															pitboss :  false
														}),
														bounds = pionsBounds( ll ),
														objPionPlay = staticMonsterConstructor( pionName, bounds.additionalBoundsValue, bounds.additionalBoundsWidthValue, bounds.additionalBoundsHeightValue, bounds.behaveRig )
														
														
														if( /dungeon/i.test(activeMap) ){
															var pionX = dtectX + scope.random( 250, -250 ),
															pionY = dtectY + scope.random( 250, -250 );
														}else{
															var pionX =  dtectX += scope.random( 150, -150 ),
															pionY = dtectY - 100;
														}
														
														temp.push({
															play : pionPlay,
															object : objPionPlay,
															x : pionX += scope.random( 250, -250 ),
															y : pionY - 100
														})
													}
													
													var pions = temp;
													for(var mm = 0; mm < pionsSpawnTotal ; mm++ )
													{
							
														var x = pions[mm].x , y = pions[mm].y, object = pions[mm].object;
														scope.World.add( scope.staticWorld['value'], object )
												
														pions[mm].play.update( this, x, y, object, interval += 10, this.items, boss );
														obj.monsters.push( pions[mm] );
													}
													
													temp.length = 0;
												}
											}

										}

										obj.install = true;

									}
								}else{
									 
									 
									if( !obj.monsters.length ){
										obj.reSpawnTick--;
											
										if( obj.reSpawnTick < 0 ){
											
											obj.reSpawnTick = obj.reSpawnTickFixed;
											if( obj.currentRespawn ){
												obj.currentRespawn++;
											}else{
												obj.currentRespawn = 1;// 1 come from first load
											}
											
											if( !obj.respawnLimit ||  obj.currentRespawn <  obj.respawnLimit  ){
												 				
												obj.install = false;
												 
												console.log("pass"+' '+ii) 
												console.log(obj) 
												
											}
											 
											//towerDef respawn logic
											if( !obj.initWave && 
												obj.currentRespawn >=  obj.respawnLimit && 
												obj.objParent ){
												
												obj.objParent.wave.currentWave--;
												obj.initWave = true;
												
												console.log("frezz"+' '+ii) 
												console.log(obj) 
												
											}
											
											/********/
											//towerdef count num villant init lose popup
											var monsterControl = scope.monsterControl,
											remainingContent = scope.qs("remaining-content"), 
											countVillant = 0,
											countTower = 0,
											tempLiVillant = [],
											tempLiTower = [];
											
											for(var ii = 0, jj = monsterControl.objSpawnMonster; ii < jj.length; ii++ ){
												
												var  spawnObj = jj[ii];
												spawnObj.forEach(function( objSpawn ){
													
													var li = document.createElement("li"),
													divAvatar = document.createElement("div"),
													divOverflow = document.createElement("div"),
													objFreeze = typeof objSpawn.freeze !== "undefined" ? objSpawn.freeze : false;
													
													divAvatar.className = objSpawn.avatarClass;
													divOverflow.className = "spawn-overflow";
													
													li.appendChild( divAvatar );
													
													addOverflow = true;
													
													if( objSpawn.currentRespawn &&
													objSpawn.currentRespawn >= objSpawn.respawnLimit && 
													objSpawn.monsters.length === 0 && 
													!objFreeze ){
														addOverflow = false;
													}
													
													
													if(  !/hero|tower/i.test( objSpawn.initialSpawn )  ){
														 
														addOverflow && countVillant++; 
														
														!addOverflow && li.appendChild( divOverflow );
										 
														tempLiVillant.push( li );
														 
													}else if( /tower/i.test( objSpawn.initialSpawn ) ){
														
														addOverflow && countTower++
														
														!addOverflow && li.appendChild( divOverflow );
										 
														tempLiTower.push( li );
														
													}
													   
												})
											}
											 
											var remainingBox = scope.qs("remaining-box"),
											elmenateBox = scope.qs("eliminate-box");
												
											if( countVillant <= 0 ){
												
												remainingContent.innerHTML = "";
												
												
												scope.qs("button-remaining").setAttribute( "init", "reload" );
												
												scope.text( scope.qs("button-remaining"), owlData.lang.fn( "gui", "btnEndgame", "detail" ) )
												
												scope.removeClass( remainingBox, "hidden" );
												 
												scope.text( scope.qs("msg-remaining"), countVillant+' '+owlData.lang.fn( "gui", "htmlGUI", "enemyText" ) )
 
												scope.removeClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "towersLeft" ) );
												scope.removeClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "enemiesLeft" ) );
												scope.addClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "win" ));
												
												scope.globalObjectGUI["value"].audioBackground.fn("end");
												 
												tempLiVillant.forEach(function( li ){
													
													remainingContent.appendChild( li )
													
												})
												 
											}
											
											if( countTower <= 0 ){
												
												remainingContent.innerHTML = "";
												
												scope.qs("button-remaining").setAttribute( "init", "reload" );
												
												scope.text( scope.qs("button-remaining"), owlData.lang.fn( "gui", "btnEndgame", "detail" ) )
												
												scope.removeClass( remainingBox, "hidden" )
												
												scope.text( scope.qs("msg-remaining"),  countTower+' '+owlData.lang.fn( "gui", "htmlGUI", "towText" ) )
												  
												scope.removeClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "towersLeft" ) );
												scope.removeClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "enemiesLeft" ) );
												scope.addClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "lose" ) );
												
												tempLiTower.forEach(function( li ){
													
													remainingContent.appendChild( li )
													
												})
												
												if( !kongregate.services.isGuest() ){
												
													kongregate.stats.submit( "scoresOnGameCompleted", scope.kongPoints["value"] );
												
												}
												
											}
											
											
											tempLiVillant.length = 0;
											remainingContent.length = 0;
											 
											/**********     **********/

											
										}
									}else{
										for(var ll = 0; ll < obj.monsters.length ; ll++ ){
											if( obj.monsters[ll].play.update() ){
												obj.monsters.splice( ll, 1 );
											}
										}
									}
								}
							}
						}

					},
					objSpawnMonster : '',
					compile : function( data, activeMap ){
						
						this.activeMap = activeMap;
						
						var clone = {};
						for( var ii in data ){
							var tierA = data[ii];
							
							clone[ ii ] = data[ii];
						
							
							if( tierA instanceof Array ){
								tierA.forEach(function( el, index ){
									scope[ el.objectSpawn ] && ( el.objectSpawn = scope[ el.objectSpawn ]["value"] );
								})
								
							}else{
								
								for( var jj in tierA ){
									clone[ii] = scope.components[ jj ]( clone[ii][jj] );
								}
							}
						}
						
						scope.extend( this, clone, true );
						clone = null;
						  
						scope.infoLogFn['value']({
							title : 'regular-title',
							text : {
								yellow : owlData.lang.fn( "gui", "questAlert", "detail" )
							}
						})
						
						setTimeout(function(){ //prevent error
							
							// required obj for area dmg
							this.objSpawnMonster =  function(){
								var lootSpawn = [];
								for(var ii in this ){
									if( /spawn/i.test( ii ) && this[ii] instanceof Array ){
										lootSpawn.push( this[ii] )
									}
								}
								
								return lootSpawn
							}.bind(this)();
							
							
							
							var parent = this;
							//wave interval
							scope.intervalList[ "waveInterval" ] = {
								tick : 450, 
								tickUpdate : 250, //1minute 1800
								always : true,
								wave:{
									e : false,
									d : false,
									c : false,
									b : false,
									a : false,
									s : false,
									waveMax : /normal|hard/i.test( scope.gameLevel ) ? 2 : 1,
									currentWave : 0
								},
								fn : function(){
									
									
									var objParent = this;
									
									if( objParent.wave.currentWave >= objParent.wave.waveMax ) return true;
										
									self : for( var ii in objParent.wave ){
											
										for( var jj = 0; jj < parent.objSpawnMonster.length; jj++ ){
									
											for( var kk = 0; kk < parent.objSpawnMonster[jj].length ; kk++ ){
												var obj = parent.objSpawnMonster[jj][kk];
												if( obj.freeze && obj.monsterLevel.toLowerCase() === ii ){
													
													if( obj.monsterLevel.toLowerCase().indexOf( ii ) !== -1 ){
														
														if( /a|s/i.test( ii ) ){
															
															scope.globalObjectGUI["value"].audioBackground.fn("epic");
														}
														
														objParent.wave.currentWave++;
														obj.freeze = false;
														obj.objParent = objParent;
														break self ;
													}
												}
											} 
											
										}
										
									}
								}
							} 
						
						}.bind(this),5)
						
						setTimeout(function(){ //prevent error 
							this.update()//install all monsters object
						}.bind(this),10)
						
					},
					variablesMonsterSpawn : function( map ){
					 
						var objMap = owlData.frame
						return objMap[ map ]
					}, 
					monsterSpawnByMap : function( map, charX, charY ){
						
						if( !this.filterDataFrame ){
							var selectedSpawn = this.variablesMonsterSpawn( map );
							this.filterDataFrame = [];
							for(var ii = 0, jj = selectedSpawn.length; ii < jj ; ii++ ){
								var variables =  selectedSpawn[ii],
								labelSpawn = variables[0] ;
								if( this[ labelSpawn ].length ){
									this.filterDataFrame.push( selectedSpawn[ii] )
								}
							}
						}
						
						if( this.filterDataFrame.length ){
							for(var ii = 0, jj = this.filterDataFrame.length; ii < jj ; ii++ ){
								var variables =  this.filterDataFrame[ii],
								labelSpawn = variables[0] ;
								this[ labelSpawn ] && this.spawnMonster( map, this[ labelSpawn ], charX, charY, variables[1], variables[2], variables[3], variables[4], variables[5],  labelSpawn );
							}
						}
						
					},
					
					update : function()
					{
						//update monster spawn
						var oval = scope.characterControl.object,
						charX = oval.position.x,
						charY = oval.position.y;
						
						this.monsterSpawnByMap( this.activeMap, charX, charY );
						 
						//update coin
						if( this.itemTemp.length ){
							for(var ii = 0; ii < this.itemTemp.length ; ii++ ){
								var obj = this.itemTemp[ii]
								if( obj.update( obj.object, oval ) )
									this.itemTemp.splice( ii, 1 );
							}
						}

						
					}
				}
				
				
				scope.extend( _obj, new scope.components.companions("monster") , true );
				scope.extend( _obj, new scope.components.items, true );
				scope.monsterControl = _obj; 
			},
			
			skillCasting : function(){
				scope.tickMinute--;
				if( scope.tickMinute <= 1 ){
					 
					// var cnt = scope.buffGUI['value'].storage,
					var characterSkills = scope.characterSkills['value'].get( scope.oval["value"].label  );
					/*
					if( cnt.length ){
						for( var ii in cnt ){
							var id = scope.id( cnt[ii]['status'].id );
							
							var element = scope.getFirstChild( id );
							scope.text( element, Math.floor( cnt[ii]['status'].tick * 33 / 1000  )+'s' )
						
						}
					}*/
					
					for( var jj = 0, kk = characterSkills.length; jj < kk; jj++ ){
						if( !characterSkills[jj].state ){
							characterSkills[jj].tickUpdate--;
							var el = scope.qs( 'time-span-'+characterSkills[jj].label ),
							activeEl = characterSkills[jj],
							tickUpdate = activeEl.tickUpdate, time, m, s;
							
							s = Math.floor( tickUpdate * 33 / 1000   );
							
							if( tickUpdate <= 0 && activeEl.loading ) activeEl.loading.remove = 'true';
							
							if ( s >= 60 ){
								m = Math.floor( s / 60 )
								time = m+','+( s - ( m * 60 ) );
							}else{
								time = ( s < 0 ) ? 1 : s + 1;
							}
							
							if( el && el.style.display !== 'block' ) el.style.display = 'block';
							el && scope.text( el, time );
						}
					}
					
					scope.tickMinute = 30;// max fps 
				}
					
			},
	 
			character : function( reset ){
				var scope = this, _obj;
				_obj = {
					object : scope.oval['value'],
					characterState : "characterState",
					staticWallOutter: scope.staticWallOutter ['value'](),
					objTranslate : scope.objTranslate['value'],
					aggresive : [],
					activeMap : '',
					dungeonActive : false,
					container : scope.canvas,
					moveSpeed : 4.5,
					moveReplaceX : 4.5,
					moveReplaceY : 4.5,
					jumpSpeed : -22.5,
					mouseTempX:0,
					mouseTempY:0,
					mousePosX :0,
					mousePosY :0,
					moveStaticX : 4.5,
					moveStaticY : 4.5,
					moveLeft : false,
					moveRight : false,
					moveUp : false,
					moveDown : false,
					moveStrict : false,
					jump : false,
					preventControl : false,
					isTranslateY : true,
					isAttacking : false, 
					monsterTarget : '',
					monsterParameters : '',
					hitNumber : [],
					criticalParticle: {
						tick : 100,
						tickUpdate : 100,
						container : [],
						createGlowRing : function(){
							
							this.container.push( new scope.createGrowRing({
									life : 27,
									width : 100,
									height : 100,
									optionalX : 0,
									optionalY : 0,
									src : scope.path+"red-rings.png",
									growingMax : 250,
									bind : new function(){
										var bound = scope.qs("background-right").getBoundingClientRect();
										
										this.x = bound.x + bound.width / 2;
										this.y = bound.y + bound.height / 2;
										this.visible = true;
									}
								})
							)
						},
						update :function(){
							
							var cnt = this.container ;
							 
							//create particle
							if( this.tick < 0 ){
								this.createGlowRing()
								this.tick = this.tickUpdate;
							}else{
								this.tick--
								 
								if( this.tick === 10 && this.tickUpdate < 50 ) scope.playAudio( 'heartbeat' );
								
							}
							 
							for( var ii = 0; ii < cnt.length ; ii++ ){
								if( cnt[ii].draw() ){
									cnt.splice( ii, 1 )
								}
							}
							 
							
						}
					},
					loadingHpPotion : new scope.loadingAct( 25, 'rgba( 255, 22, 22, 0.5 )' ),
					hpTickState : true,
					hpPotionUpdate: function( state ){
						/*var slotReat = scope.slotButtonHp.getBoundingClientRect(),
						x = slotReat.left + ( slotReat.right - slotReat.left ) / 2 ,
						y = slotReat.bottom + ( slotReat.top - slotReat.bottom ) / 2 + 1;
						*/
						var x = 0, y = 0;
						return this.loadingHpPotion.update( scope.context, x, y, state );
					},
					loadingMpPotion : new scope.loadingAct( 25, 'rgba( 83, 83, 255, 0.5 )' ),
					mpTickState : true,
					mpPotionUpdate: function( state ){
						/*var slotReat = scope.slotButtonMp.getBoundingClientRect(),
						x = slotReat.left + ( slotReat.right - slotReat.left ) / 2 ,
						y = slotReat.bottom + ( slotReat.top - slotReat.bottom ) / 2 + 1;
						*/
						var x = 0, y = 0;
						return this.loadingMpPotion.update( scope.context, x, y, state );
					},
					characterParameters : scope.characterParameters['value'],
					areaDamageFn : function(){
						var areaDamage = scope.areaDmgPool['value'].storage,
						objectBounds = this.object.position;
						
						
						for(var ii = 0, jj = areaDamage; ii < jj.length ; ii++ ){
							
							
							if(  objectBounds.x > jj[ii].status.bounds.min.x &&
							objectBounds.x < jj[ii].status.bounds.max.x &&
							objectBounds.y > jj[ii].status.bounds.min.y &&
							objectBounds.y < jj[ii].status.bounds.max.y && 
							jj[ii].status.caster !== this.object.label  ){
								jj[ii].status.monsterParameters.push( this.characterParameters );
							}
							
						}
					},
					buffDelay : 0,
					buffGUI : function( init, id, name ){
						if( init === 'add' ){
							var div = document.createElement('div')
							div.className = 'buff-skill '+name;
							div.id = id
							
							var span = document.createElement('span')
							div.appendChild( span )
							
							scope.buffBox.insertBefore( div, scope.buffBox.firstChild );
						}else if( init === 'remove' ){
							var cnt = scope.slice( scope.buffBox.getElementsByTagName('div') );
							for( var ii = 0 ; ii < cnt.length ; ii++ ){
								if ( cnt[ii].id === id ){
									cnt[ii].remove()
									break;
								}
							}
						}
					},
					buffHeal : function( buffHeal ){
						var healNumber = Math.round( ( parseInt( this.characterParameters.maxHealth ) * (  parseInt( buffHeal )  /  100 ) ) + scope.random(15 , 0) )
						this.hitNumber.push( new scope.hitNumber( '+'+healNumber, 'heal' ) );
						
						if( ( this.characterParameters.health + healNumber ) < this.characterParameters.maxHealth ){
							this.characterParameters.health += healNumber ;
						}else{
							this.characterParameters.health =  Math.round( this.characterParameters.maxHealth )
						}
						
						this.updateHpBar()
					},
					
					forceObjectToAttack: function( attacker ){
						/*
						this.monsterTarget = attacker.label;
						this.monsterParameters = scope.monsterParameters['value'].get( attacker.label );
						this.isAttacking = true
						*/
					},
					
					monsterGetDamageFn : function( monsterTarget, status, monsterGetDamage, attacker, attackerAbilities, ){
						var monsterStat = scope.monsterGetDamage['value'].get( monsterTarget )
						if( typeof monsterStat  === 'undefined' ){
							scope.monsterGetDamage['value'].set( monsterTarget, [] )
							var monsterStat = scope.monsterGetDamage['value'].get( monsterTarget )
						};
						
						monsterStat.push({
							damage : monsterGetDamage,
							attackerAbilities : attackerAbilities,
							status : status,
							attacker : attacker,
							attackerParameters : this.characterParameters
						})
					},
					 
					calculateMonsterDamageWithSkill : function( monsterParameters, initDmg ){
						var atkRangeMax = this.characterParameters.attackRangeMax,
						atkRangeMin = this.characterParameters.attackRangeMin,
						monsterDefMax =  monsterParameters.magicDefenseMax,
						monsterDefMin =  monsterParameters.magicDefenseMin,
						charAtkRandom = scope.random( atkRangeMax, atkRangeMin ),
						monsterDefRandom = scope.random( monsterDefMax, monsterDefMin ),
						tempDemage = charAtkRandom + ( Math.round( charAtkRandom * this.characterParameters[ initDmg ].damage / 100 ) ) - monsterDefRandom;
						tempDemage > 0 ? tempDemage : Math.round( scope.random( 100, 50 ) / 2 );
						return tempDemage;					   
											   
					},
					
					convertAttackCharacterToDamage : function()
					{
						if( this.characterParameters.attackType === "melee" ){
							var atkMax = this.characterParameters.attackMax,
							atkMin = this.characterParameters.attackMin;
						}else{
							var atkMax = this.characterParameters.attackRangeMax,
							atkMin = this.characterParameters.attackRangeMin;
						}
						
						var monsterDefMax =  this.monsterParameters.defenseMax,
						monsterDefMin =  this.monsterParameters.defenseMin,
						
						charAtkRandom = scope.random( atkMax, atkMin ),
						monsterDefRandom = scope.random( monsterDefMax, monsterDefMin ),
						status = 'attack', selfAbilities, attackerAbilities, tempDemage, monsterGetDamage, block;
						
						
						if( this.isAttacking ){

							tempDemage = charAtkRandom - monsterDefRandom,
							monsterGetDamage = tempDemage > 0 ? tempDemage : Math.round( scope.random( 100, 50 ) / 2 );

							//monster hits 0 miss, tempDemage / 2 monster to strong,
							
							//monster ability 
							attackerAbilities = this.attackerAbilities(  this.characterParameters );
							//set help 
							this.setHelpToSummon( this.monsterParameters.object.label )
							
							this.monsterGetDamageFn( this.monsterTarget, status, monsterGetDamage, this.object.label, attackerAbilities, )

						}

					},
					helpTick :1000,
					setHelpToSummon : function( attacker ){
						var test = true
						if( this.object.pions && this.object.pions.length ){
							for( var ii = 0, jj = this.object.pions; ii < jj.length; ii++ ){
								if( jj[ii].label === attacker ){
									test = false;
									break;
								}
							}
						}
						
						if( test ){
							this.helpTick = 1000;
							this.object.attacker =  attacker ;
							this.object.needHelp = true;
						}
					},
					characterGetDamage : scope.characterGetDamage['value'],
					convertAttackMonsterToDamage : function(){
						
						var monsterParameters = this.characterGetDamage;
						 
						if( monsterParameters && monsterParameters.length  ){
							for(var xx = 0; xx < monsterParameters.length ; xx++ ){
								
								var params =  monsterParameters[xx];
								
								if( this.isEnemyFn( params.object.label ) ){
								 
									if( params.attackType === 'melee' ){
										var atkRangeMax = params.attackMax,
										atkRangeMin = params.attackMin;
									}else if( params.attackType === 'long-range' ){
										var atkRangeMax = params.attackRangeMax,
										atkRangeMin = params.attackRangeMin;
									}
									
									var addBuff =  true, casted = 0, count = 0;
										
									//if added buff then prevent damage to character	
									if( this.buff.register({
											seletedBuff : params.buffSkill,
											paramsTarget : this.characterParameters,
											paramsAttacker : params
										}) ){
										
										
										var monsterDefMax =  this.characterParameters.defenseMax,
										monsterDefMin =  this.characterParameters.defenseMin,

										monsterAtkRandom = scope.random( atkRangeMax, atkRangeMin ),
										charDefRandom = scope.random( monsterDefMax, monsterDefMin ),
										tempDemage, tempHealth, monsterGetDamage,


										tempDemage = monsterAtkRandom - charDefRandom,
										tempDemage = ( tempDemage <= 0 ) ? 0 : tempDemage,
										monsterGetDamage = tempDemage > 0 ? tempDemage : Math.round( scope.random( 100, 50 ) / 2 );
										
										
										var attackerAbilities = this.attackerAbilities( this.characterParameters ),
										avoid = false, block = false;
										
										for(var mm = 0, nn = attackerAbilities.length; mm < nn; mm++){
											if( attackerAbilities[ mm ] === 'avoid'){  
												avoid = true; 
											}else if( attackerAbilities[ mm ] === 'block'){  
												block = true; 
											}
										}
									
										
										if( block ){
											this.hitNumber.push( new scope.hitNumber( 'block' ) );
											this.object.visible && scope.playAudio(['shiled-blocking']);
										}else if( avoid ){
											this.hitNumber.push( new scope.hitNumber( 'miss' ) )
										}else if( !params.object.deleted ){
											this.setHelpToSummon( params.object.label )

											tempHealth = this.characterParameters.health - monsterGetDamage;
											
											if( tempHealth < 0 ){
												 
												this.characterParameters.health = 0;
												this.updateHpBar();
												
												//perform die 
												scope[ this.characterState ].set( this.object.label, 'die' );
												this.moveStrict = true;
												this.object.behave = 'die';
												params.object.rigBody.attacker =  false;
												params.object.rigBody.behaveState =  true;
												params.object.rigBody.behaveRandomFn(1);
												
												
												//when hero party died witch or end game
											

													if( this.object.label !== this.bossObject.label ){//switch
													
														
														this.switchCharacter( this.bossObject );
													
													}else{ //end game
														 
														var remainingBox = scope.qs("remaining-box"),
														elmenateBox = scope.qs("eliminate-box");
														remainingContent = scope.qs("remaining-content"),
														remainingMsg = scope.qs("msg-remaining");

														remainingContent.innerHTML = "";
														
														scope.qs("button-remaining").setAttribute( "init", "reload" );
														
														scope.text( scope.qs("button-remaining"), owlData.lang.fn( "gui", "btnEndgame", "detail" ) )
														
														scope.text( remainingMsg, owlData.lang.fn( "gui", "leaderDied", "detail" ) )
														
														scope.removeClass( remainingBox, "hidden" );
														  
														scope.removeClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "towersLeft" ) );
														scope.removeClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "enemiesLeft" ) );
														scope.addClass( elmenateBox, owlData.lang.fn( "gui", "bgPop", "lose" ) );
														
														scope.globalObjectGUI["value"].audioBackground.fn("end");
													
														
													}
												
											} else{
												
												
												//critical
												var criticalDamage = this.abilityCritical( params, monsterGetDamage ),
												criticalState = ( criticalDamage > 0 );
												
												monsterGetDamage += criticalDamage; 
												  
												this.hitNumber.push(  ( criticalState ? new scope.hitNumber( monsterGetDamage, "critical" ) : new scope.hitNumber( monsterGetDamage ) ) )
												scope.playAudio(['stab'])		
												
												
												this.characterParameters.health -= monsterGetDamage;
												
												
												scope.hitEffect({
													object :  this.object,
													parent : "",
													alpha : true
												})
												
												 
												//cure if slot potion is attached;
												if( this.characterParameters.health < this.characterParameters.maxHealthCure ){
													this.cureSelf( scope.slotButtonHp, 'healthpotion', 'hpTickState', 'hpPotionUpdate' )
												}
												 
												this.partyRandomHelp.update( this );
												  
												this.updateHpBar();
												
																								//critical audio
												if( this.characterParameters.health < this.characterParameters.maxHealth / 2 ){
														
													scope.globalObjectGUI["value"].audioBackground.fn("critical");
													
												}

												
											}
										}
										
										//when monster is attacking then update monster paams and gui
										if( this.characterParameters.health && !scope.monsterTarget ){
											this.updateMonsterParamsAngGUI( params.object.label  );
											this.isAttacking = true;
										}
										
										this.characterGetDamage.splice( xx, 1 );
									}
								
								}
							
							}
						}

						
						if( this.hitNumber.length ){
							for(var ii = 0; ii < this.hitNumber.length ; ii++ ){
								if( this.hitNumber[ii].update( scope.context, this.object ) )
									this.hitNumber.splice( ii, 1 )
							}
						}
						
						
						

					},
					cureSelf:function( slotHealing, healingname, state, update ){	
						
						var slotItem = slotHealing.getElementsByTagName('div');
						if( slotItem.length && this[ state ] ){
							var itemLabel = slotItem[0].getAttribute('label'),
							loot = this.loot,
							itemNum = scope.qs( 'item-number', slotHealing );
							 
							for(var ii = 0; ii < loot.length; ii++ ){
								if( loot[ii] && loot[ii].label === itemLabel && loot[ii].name === healingname ){
									
									this[ update ]( 'reset' )
									this[ state ] = false; 
									loot[ii].cooldown && (  this[ update ==="hpPotionUpdate" ? "loadingHpPotion" : "loadingMpPotion" ].tick = loot[ii].cooldown );
									
									if( healingname === 'healthpotion' 
										&& this.characterParameters.health < this.characterParameters.maxHealthCure ){
											loot[ii].quantity--;
											if( this.characterParameters.health + loot[ii].cure < this.characterParameters.maxHealth )
												this.characterParameters.health += loot[ii].cure;
											else 
												this.characterParameters.health = this.characterParameters.maxHealth;
										
									
									}else if( this.characterParameters.mp  < this.characterParameters.maxMpCure ) {
										loot[ii].quantity--;
										if( this.characterParameters.mp + loot[ii].cure < this.characterParameters.maxMp ) 
											this.characterParameters.mp += loot[ii].cure;
										else 
											this.characterParameters.mp = this.characterParameters.maxMp;
									}
									
									scope.text( itemNum, loot[ii].quantity )
									
									if( healingname === 'healthpotion'){
										
										this.updateHpBar();
										
										//critical audio
										if( this.characterParameters.health < this.characterParameters.maxHealth / 2 ){
												
											scope.globalObjectGUI["value"].audioBackground.fn("critical");
											
										}
										 			
										var healthPercentage = Math.round( this.characterParameters.health / this.characterParameters.maxHealth * 100 )
										
										healthPercentage = healthPercentage < 30 ? 20 :
												healthPercentage < 50 ? 30 :
													healthPercentage < 60 ? 40 :
													   healthPercentage < 70 ? 55 : 100;
										 
										this.criticalParticle.tickUpdate = healthPercentage;
										
										
									}else if( healingname === 'manapotion'){
										this.updateMpBar();
									}
										
									if( loot[ii].quantity <= 0 ){ 
										loot.splice( ii, 1 ); 
										scope.addClass( itemNum, 'hidden'  );
										 
										scope.globalObjectGUI["value"].attachMainPotions( true );
										
										this[ state ] = true;
									}
								}
							}

							
						}

					},
					
					cntActiveSkill : [],
					cntTickSkill : [],
					isSkillRegistered : function( name ){
						var buffArr = this.buffAffected, isRegisted = true;
						for(var ii = 0; ii < buffArr.length ; ii++ ){
							if( buffArr[ii].skill ===  name ){
								isRegisted = false;
								break;
							}
						}
						return isRegisted;
					},
					characterSkills : scope.characterSkills['value'],
					 
					skillUpdate : function( monsterTarget ){
						
						
						var stateSkill = this.characterSkills.initial,
						characterSkills = this.characterSkills.skills;
						 
						if( stateSkill.state && this.characterParameters.health )
						{
					 
							var activeSkill = stateSkill.label
							for( var ii = 0; ii < characterSkills.length ; ii++ ){
								
								if( characterSkills[ii].label === activeSkill
									&& characterSkills[ii].state 
									&& !this.dirSwitch.forceAttackFrame 
									&& function(){
										
										return /intimidation/i.test( characterSkills[ii].name ) ? 
											true : this.isEnemyFn( scope.monsterTarget );
										 
									}.bind( this )() ){
									
									
									var parent = this,
									spanTime = scope.qs( 'time-span-'+characterSkills[ii].label );
									
									if( !spanTime ) return false; //bug sometimes return null
									
									var spanBlock = scope.sibling( spanTime, "next"),
									obj = {
										install : function(){
											
											if( !characterSkills[ii].loading ){
											 //install loading update
												characterSkills[ii].loading = new scope.loadingAct( 25, 'rgba( 0, 0, 0, 0.7 )', characterSkills[ii].tick )
											}
											
											characterSkills[ii].loading.update( scope.context, -1000, -1000, 'reset' );
											
											var initial = scope.characterSkills['value'].get( 'initial' );
											
											initial.label = "";
											initial.state = false;
											delete initial.target;
											
											
											//cure if slot potion is attached
											this.cureSelf( scope.slotButtonMp, 'healthpotion', 'mpTickState', 'mpPotionUpdate' )
											this.updateMpBar();
											
											
										}.bind( parent ),
										
										initLoading : function(){
											characterSkills[ii].target = stateSkill.target;
											characterSkills[ii].state =  false;
											parent.cntTickSkill.push( characterSkills[ii] );
											scope.removeClass( spanBlock, "loading");
											
											//reset changeDir
											parent.latestDir = "";
											
										},
										guiInitLoading : function(){
											
											spanBlock.style.display = spanTime.style.display = 'block';
											scope.addClass( spanBlock, "loading");
										}
									}
									
									if( !/intimidation/i.test( characterSkills[ii].name ) ){
										this.isAttacking = true;
									}
									
									this.triggerUniqueSkill ( obj, characterSkills[ii] )
										
									break;
								}
							}
							
							
							stateSkill.state = false;
						}
						
						
						if( characterSkills ){
							this.updateRegisterSkillFn( monsterTarget )
						}
						
						
						this.updateRegisterSkillTick()
						

					},
					updateRegisterSkillTick : function(){
						var active = this.cntTickSkill;
						
						for( var jj = 0; jj < active.length; jj++ ){
							var skill = active[ jj ];
							
							if( !skill.state ){
								if( skill.target ){
									//var slotReat = skill.target.getBoundingClientRect(),
									//x = slotReat.left + ( slotReat.right - slotReat.left ) / 2 ,
									//y = slotReat.bottom + ( slotReat.top - slotReat.bottom ) / 2 ;
									skill.tickUpdate--;
									if( skill.loading.update( scope.context, x, y, skill.tick ) ){
										skill.state = true;
										skill.loading.remove = false;
										skill.tickUpdate = skill.tickOriginal && skill.tickOriginal || skill.tick;
										skill.target = "";
										var activeEl = scope.qs( 'time-span-'+skill.label );
										activeEl && ( activeEl.style.display = 'none');
										active.splice( jj, 1 );
									}
								
								}else if( skill.tickUpdate > 0 ){
									skill.tickUpdate--
								}else{
									skill.state = true;
									skill.tickUpdate =  skill.tick;
									active.splice( jj, 1 );
								}
							}else{
								//bug switch
								skill.tickUpdate =  skill.tick;
								active.splice( jj, 1 );
							}
						};
					},
					
					activeAttacking : false,
					latestDir : 'right',
					monsterDir : function(){
						return this.monsterParameters.object.position.x < this.object.position.x ? 'left' : 'right';
					},
					dirSwitch : { reset : function(){} },//dummy to prevent error, it will be replaced at switchCharacter later
					boundsWidthOperator : {
						left : 1,
						right : 1
					},
					changeLeftFn : function( pass, passForeceAttackFrame ){
						if( passForeceAttackFrame || !this.dirSwitch.forceAttackFrame && 
							( ( this.dirSwitch.left  && ( this.moveLeft && !this.moveRight ) && !( this.moveLeft && this.moveRight ) ) || pass ) ){
							this.dirSwitch.left = false;
							this.dirForBug.current = this.latestDir = 'left'; 
							this.moveSpeed = -this.moveReplaceX;
							this.object.additionalBoundsWidthValue = this.boundsWidthOperator.left * Math.abs( this.object.additionalBoundsWidthValue  );
							var  texture = this.object.initialName +'-left.png';
							this.objTranslate.firstLoadLeft = false;
							scope[  this.characterState ].set( this.object.label, 'textureNeedChange|'+scope.path +  texture );
							
						}
					},
					changeRightFn : function( pass, passForeceAttackFrame ){
						 
						if( passForeceAttackFrame || !this.dirSwitch.forceAttackFrame && 
							( ( this.dirSwitch.right && ( !this.moveLeft && this.moveRight ) && !( this.moveLeft && this.moveRight ) ) || pass ) ){
							this.dirSwitch.right = false;
							this.dirForBug.current = this.latestDir = 'right';
							this.moveSpeed =  this.moveReplaceX;
							this.object.additionalBoundsWidthValue = this.boundsWidthOperator.right * Math.abs( this.object.additionalBoundsWidthValue  );
							var  texture = this.object.initialName +'-right.png';
							this.objTranslate.firstLoadRight = false;
							scope[  this.characterState ].set( this.object.label, 'textureNeedChange|'+scope.path +  texture );	
						}
						
						
					},
				
					attackFrame : "",
					
					changeDir : function( dir ){
						// setTimeout to prevent bug stateStorage was replaced by unknown
						if( dir === "right" ) {
							if( this.latestDir !== 'right' ){ 
								setTimeout( function(){
									this.changeRightFn( true );
								}.bind(this),2 )
								
							}
						}else{
							if( this.latestDir !== 'left' ){
								setTimeout( function(){
									this.changeLeftFn( true );
								}.bind(this),2 )
							}
						}
					},
					loopDir : function( posX ){
						
						// setTimeout to prevent bug stateStorage was replaced by unknown
						if( !this.dirSwitch.dirBlock.state ){
							if( posX > 0 ) {
								if( this.latestDir !== 'right' ){
									setTimeout( function(){
										this.changeRightFn( true );
									}.bind(this),2 )
									
								}
							}else{
								if( this.latestDir !== 'left' ){
									setTimeout( function(){
										this.changeLeftFn( true );
									}.bind(this),2 )
								}
							}
						}
					},
					 
					objGlobalTranslate : new scope.objGlobalTranslate,
					dungeonAttackRangeY : {
						max : 0,
						min : scope.random( 180, 100 )
					},
					 
					guiFight : "iconNeutral", //int mobile temporary for tower def
					idleBugTick : 0,
					dirForBug : { // prop for bug switch monster
						previous : "",
						current : ""
					},
					findTargetToAttack : function(){
						monsterReg = scope.globalAnimation["value"].monsterTarget,
						findEnemy = function(){
							
							var areaPool = this.createAreaDamagePool({
								target :this.object,
								width : scope.browserWidth(),
								height : scope.browserHeight(),
								caster : this.object.label
							}),
							temp = [];
							
							while( areaPool.length ){ 
								
								var objPool = areaPool.pop().object;
								 
								if( this.isEnemyFn( objPool.label ) ){
									temp.push( objPool );
								}
								
							}
							  
							if( temp.length ){
								 
								var target = scope.AI.sortestEnemy( temp, this.object );
								
								this.updateMonsterParamsAngGUI( target[0].label );
								
								monsterReg = true;
							}
						}.bind(this);
						
						
						if( !monsterReg ){
							 
							findEnemy();
							 
						}else{ 
						
							monsterReg = this.isEnemyFn( monsterReg )
							
							if( !monsterReg ){
								scope.monsterTarget = "";
								monsterReg = false;
								findEnemy(); //recheck 
							}
							
						}   
							  
						
						if( !scope.monsterTarget ){
							
							scope.pushMsgText['value']( owlData.lang.fn( "gui", "attackAlert", "detail" ) , 100 );
							
						}else if( !this.moveLeft && !this.moveRight && !this.moveUp && !this.moveDown ){
							
							var elementClickMb = scope.qs("attack-right-nav")
							
							if( !this.isAttacking  && monsterReg ){
							 
								scope.addClass( elementClickMb, "iconAttack" )
								scope.removeClass( elementClickMb, "iconNeutral" );
								this.isAttacking = true;
								this.guiFight = elementClickMb.className;
								
							}else if( this.isAttacking && scope.isMobile()  ){
						 
								scope.addClass( elementClickMb, "iconNeutral" );
								scope.removeClass( elementClickMb, "iconAttack" );
								
								scope[  this.characterState ].set( this.object.label, "idle"  );
								this.isAttacking = false;
								this.guiFight = elementClickMb.className;
								
							}
						
						}
					},
					performAttacking : function( monsterTarget, objTranslate, charPos ){
						if( this.characterParameters.health ){
							 
							var dirSwitch = this.dirSwitch,
							isPlayerIdle = !this.moveLeft && !this.moveRight && !this.moveUp && !this.moveDown;
							if( this.isAttacking && monsterTarget && this.monsterParameters && this.isEnemyFn( monsterTarget ) && isPlayerIdle ){
								 
								var tempTarget = dirSwitch.tempTarget, 
								target = this.monsterParameters.object,
								posX = Math.round( target.position.x - charPos.x ),
								posY = Math.round( target.position.y - charPos.y ),	
								range = this.characterParameters.range, objMovement,
								isMelee =  this.characterParameters.attackType === "melee";
								  
								// exceute once 
								if( dirSwitch.normal ){
									 
									//gui mobile right nav
									if(  /iconNeutral/i.test( this.guiFight ) ){
										scope.removeClass( scope.qs("attack-right-nav"), "iconNeutral" );
										scope.addClass( scope.qs("attack-right-nav"), "iconAttack" );
										this.guiFight = scope.qs("attack-right-nav").className;
									} 
									
									dirSwitch.normal = false;	
									dirSwitch.reset();
									dirSwitch.selectedFrame = "";
									this.object.behave = "attack";
									 
									this.loopDir( posX );
								}
								
								if( isMelee ){
									
									objMovement = this.meleeMovement({
										object : this.object,
										target : target,
										range : this.dungeonAttackRange,
										distanceY : this.dungeonAttackRangeY.min,
										speed : this.moveReplaceX,
										forceGravity : this.object.forceGravity,
										objTranslate : objTranslate,
										dirSwitch : dirSwitch
									})  
								
									
								}else{
									objMovement = this.rangeMovement({
										object : this.object,
										target : target,
										targetDummy : tempTarget,
										distanceY : this.dungeonAttackRangeY,
										distanceX : this.dungeonAttackRange,
										distX : posX,
										distY : posY,
										dirSwitch : dirSwitch,
										objTranslate : objTranslate,
										speed : this.moveStaticX 
									 })
								}
							 	 
								var stateSkill = this.dirSwitch.forceAttackFrame 
								if( stateSkill ){
								
									objMovement.init = true;
								}else if( !this.monsterParameters.health ){
									
									this.isAttacking = false;
									scope.monsterTarget = "";
									scope[  this.characterState ].set( this.object.label, "idle" );
								}
								
								
								stateSkill = !stateSkill; 
								
								if( this.dirSwitch.forceAttackFrame ){
									objMovement.init = true;
								}else{
								
									this.velocity = objMovement.y;
									objTranslate.staticObjMoveX = Math.abs( objMovement.x ); //flip
									objTranslate.staticObjMoveY = Math.abs( objMovement.y );//flip
									
									objTranslate.objPhysCollide = false;	
								}
								
								if(  this.performAttackFrame( objMovement, this.dirSwitch.selectedFrame ) ){
									this.convertAttackCharacterToDamage();
									
								}
								
								
								if( stateSkill ){
									
									if( isMelee  ){ 
									
										//loopDir for meleeMovement
										if( !objMovement.init ){ 
											this.loopDir( posX );									
										}else{
											//reset changeDir
											this.latestDir = "";
										}
					
									}else if( !dirSwitch.mainTurn && !objMovement.init){ 
										//loopDir for long rangeMovement 
										var posX = Math.round( tempTarget.position.x - charPos.x );
										 
						
										 this.loopDir( posX ); 
									}
								}
								
								
								if( dirSwitch.previousTarget !== monsterTarget ){ 
								
									
									if( this.dirForBug.previous !== this.dirForBug.current ){
										
										stateSkill && setTimeout(function(){
											dirSwitch.reset() //  reset delay is required to handle a bug, not attack when switch other enemy
										},150);
										
										this.dirForBug.previous = this.dirForBug.current;
									}
									
									dirSwitch.dirBlock.reset(); 
									dirSwitch.previousTarget = monsterTarget;
								}
									
								
							}else{ //dirSwitch.normal to prevent execute multipe times
						 
								if( !dirSwitch.normal ){ // exceute once 
									dirSwitch.tempTarget = {
										position : {
											x : 0,
											y : 0
										},
										init : true
									}
								
									objTranslate.charaTranslate = true; 
								  
									dirSwitch.normal = true;
									dirSwitch.reset();
									this.object.behave = "walk";
									 
									//reset dirBlock
									dirSwitch.dirBlock &&
										dirSwitch.dirBlock.reset();
										 
									//prevent bug 
									//monster aleardy died by another ally 
									//monster not idle when monster died
									if( !this.dirSwitch.forceAttackFrame && !scope.monsterParameters['value'].get(  monsterTarget  ) ){
										scope.monsterTarget = "";
										scope.addClass( scope.qs('monster-bar'), 'hidden' );
										scope[  this.characterState ].set( this.object.label, "idle" );
									}
									 
									//gui mobile right nav
									if(  /iconAttack/i.test( this.guiFight ) ){
										scope.removeClass( scope.qs("attack-right-nav"), "iconAttack" )
											scope.addClass( scope.qs("attack-right-nav"), "iconNeutral" );
											this.guiFight = scope.qs("attack-right-nav").className;
									} 	
									
									
									//cancel skill or unique skill when user force to move
									if ( this.moveLeft || this.moveRight || this.moveUp || this.moveDown ){
										this.dirSwitch.selectedFrame = "";
										dirSwitch.reset();
									}
									 
										
								}
								
							 
								//prevent bug player frame idle 
								if( !this.dirSwitch.forceAttackFrame && isPlayerIdle && this.idleBugTick <= 0 ){ 
									var stateStorage = scope[  this.characterState ],
									status = stateStorage.get( this.object.label );
									if( status !== "idle" ){
										stateStorage.set( this.object.label, "idle" );
									}
									
									this.idleBugTick = 5;
								}else{
									this.idleBugTick--
								}
									 
							}
							
						
							if( this.isAttacking  && !this.dirSwitch.forceAttackFrame && monsterTarget === '' ){
								this.isAttacking =  false;
								
								scope[  this.characterState ].set( this.object.label, "idle" );
								//reset
								dirSwitch.reset();
 
							}
						}else{
							//character die
							
							var status = scope[  this.characterState ].get( this.object.label );
							if( !/idle|die/i.test( status ) )   scope[  this.characterState ].set( this.object.label, 'idle' );
						
							this.moveDown = false;
							this.moveUp = false;
							this.moveRight = false;
							this.moveLeft = false;
							objTranslate.moveUp =  false;
							objTranslate.moveDown =  false;
							objTranslate.moveLeft =  false;
							objTranslate.moveRight =  false;
							objTranslate.staticObjStateX = false;
							objTranslate.staticObjStateY = false;
						}
						
					},
					removeAnimateSkill : function( monsterTarget, monsterOldTarget ){
						return monsterTarget === '' || monsterOldTarget !== monsterTarget;

					},
					pointingAnimate : {
						drawFn : new scope.draw.generalDrawImage(),
						drawLoadingMb : new scope.loadingAct( 10, 'rgba( 255, 22, 22, 0.8 )', 25 ),
						active : false,
						install : false,
						imagePosY : -30,
						imagePosX :  0,
						scaleBefore : 0,
						scaleX : 0,
						scaleY : 0,
						offsetX : 0.1,
						offsetY : 0.1,
						posX : 310,
						posY : 310,
						target : {
							state : false,
							object : '',
							objectTarget : '',
							visible : false,
							behave : ''
						},
						renderWalk : {
							textures : '',
							src : scope.path+'point-walk.png'
						},
						renderAttack : {
							textures : '',
							src : scope.path+'point-attack.png'
						},
						
						updateLoadingMb : function( obj ){
							var pos = obj.position, 
							boundValue = obj.additionalBoundsValue;
							if( this.drawLoadingMb.update( scope.context, pos.x, pos.y - boundValue - 45 ) ){
								 this.startEventMb( obj );
								 return true
							}
						},
						mouseInTargetFn : function( b, mousePosition ){
							var additionalBoundsValue = b.additionalBoundsValue ? b.additionalBoundsValue : 0;
							return b.bounds.min.x - ( additionalBoundsValue / 3 ) < mousePosition.x &&
							b.bounds.max.x + ( additionalBoundsValue / 3 ) > mousePosition.x &&
							b.bounds.min.y - additionalBoundsValue < mousePosition.y &&
							b.bounds.max.y  > mousePosition.y;
						},
						targetCompanion : {
							dirX : 0,
							sekleton : '',
							sekletonTarget : ''
						},
						
						initMb : false,
						startEventMb : function( obj ){
							if( !this.initMb ){
								
								this.targetCompanion.dirX = obj.position.x;
								this.cursorStartEventFn( obj.position );
								this.initMb = true;
							}
						},
						endEventMb : function( pos ){
							this.cursorEndEventFn( pos )
						},
						moveEventMb : function( pos, objTargetMb ){
							if( this.initMb ){
								this.cursorMoveEventFn( pos, objTargetMb )
							}
						},
						cursorStartEventFn : function( pos ){
							var bodies = scope.Composite.allBodies( scope.engine.world );
							for( var ii = 0, jj = 0; ii < bodies.length ; ii++ )
							{
								var b = bodies[ii],
								mouseInTarget = this.mouseInTargetFn( b, pos );
								if ( /sekleton/i.test( b.label ) && mouseInTarget ) {
									this.targetCompanion.sekleton = b;
									this.target.object = b;
									this.active = true;
									this.target.behave = 'walk';
									break;
								}
							}
						},
						
						cursorMoveEventFn : function( pos, objTargetMb ){
							this.posX = pos.x;
							this.posY = pos.y;
							
							var obj = this.target,
							objTarget = this.target.objectTarget,
							mouseInTarget = obj.object instanceof Object && this.mouseInTargetFn( obj.object , pos );
							
							if( obj.object !== '' && !mouseInTarget ){
								obj.visible = true;
								
								if( !!objTargetMb ){
									obj.objectTarget = objTargetMb;
								}else{
									var bodies = scope.Composite.allBodies( scope.engine.world );
									for( var ii = 0, jj = 0; ii < bodies.length ; ii++ )
									{
										var b = bodies[ii], label = b.label,
										mouseInObjTarget = this.mouseInTargetFn( b, pos );
										if( objTarget.label !== label && /monster|dragon/i.test( label ) && !/sekleton/i.test( label ) && mouseInObjTarget && label !== obj.label  ){
											
											obj.objectTarget = b;
											break;
										}
									}
								}
								
								if( objTarget !== '' &&  this.mouseInTargetFn( objTarget, pos )  ){
									obj.render = 'renderAttack';
									obj.state = true;
								}else{
									obj.render = 'renderWalk';
									obj.state = false;
								}
								
								
								
							}else{
								this.target.visible = false;
							}
						},
						
						cursorEndEventFn : function( pos ){
							if( this.targetCompanion.sekleton !== '' ){
								var bodies = scope.Composite.allBodies( scope.engine.world ),
								mouseOutTarget = this.mouseInTargetFn( this.targetCompanion.sekleton, pos ), b,
								sekletonTargt = this.targetCompanion.sekleton;
								
								for( var ii = 0, jj = 0; ii < bodies.length ; ii++ )
								{
									b = bodies[ii],
									mouseInTarget = this.mouseInTargetFn( b, pos )
									
									//attack within selected point
									if( /monster/i.test( b.label )  && b.label !== sekletonTargt.label && !mouseOutTarget && mouseInTarget ){
										
										sekletonTargt.rigBody.character = b;
										sekletonTargt.rigBody.loopDir(  Math.round( b.position.x  - sekletonTargt.rigBody.object.position.x ), true );
										sekletonTargt.rigBody.attacker = b.label;
										sekletonTargt.rigBody.object.behave = sekletonTargt.rigBody.behave = 'attack';
										sekletonTargt.rigBody.turnState = scope.random( 600, 500 );
										
										break;
									}
									
									//walk within target point
									if( !jj && ii === (bodies.length - 1) && !mouseOutTarget ){
										var posX =   pos.x - this.targetCompanion.dirX;
										sekletonTargt.rigBody.loopDir( posX, true  );
										sekletonTargt.rigBody.objectPointing.position.x = pos.x;
										sekletonTargt.rigBody.objectPointing.position.y = pos.y;
										sekletonTargt.rigBody.behave = 'pointing';
										sekletonTargt.rigBody.turnState = scope.random( 600, 500 );
										break;
									}
								}
								
								this.active = false;
								this.target.object = '';
								this.target.objectTarget = '';
								this.targetCompanion.sekleton = ''; 
							}
						},
						
						update : function( ctx ){
							if( !this.install ){
								scope.getTexture( this.renderWalk, this.renderWalk.src )
								scope.getTexture( this.renderAttack, this.renderAttack.src )
								this.install = true;
							}
							var objTarget = this.target.objectTarget;
							if( this.target.state && objTarget instanceof Object  ){
								this.posX = objTarget.position.x;
								this.posY = objTarget.bounds.min.y - objTarget.additionalBoundsValue;
							}
							
							if( this.target.visible ){
								this.drawFn.update({
									context : ctx,
									image : this[ this.target.render ].textures,
									posX : this.posX,
									posY : this.posY,
									imagePosY : this.imagePosY,
									imagePosX : this.imagePosX,
									scaleX : this.scaleX ,
									scaleY : this.scaleY,
									offsetX : this.offsetX,
									offsetY : this.offsetY,
									scaleBefore : this.scaleBefore
								})
							}
							
						}
						
					},
					footstep : {
						tick : 0,
						tickStep : 8,
						fn : function(){
							scope.playAudio('footstep')
						}
					},
					 
					trajectoryCheck : function(){
						
						//trajectoriesUpdate		
						
						if( this.trajectoriesUpdate.length ){
							var turn = this.monsterDir(),
							objPos = this.object.position,
							trajectoryCnt =  this.trajectoriesUpdate,
							trajectoryProp = this.object.statParameters.trajectoryProp,
							posX, posY, angle;
							
							if( trajectoryProp ){//switch bug sometimes statParameters was undefined when user switch a hero
							
								if( turn === 'right' ){
									posY = objPos.y - trajectoryProp.posY ;
									posX = objPos.x + trajectoryProp.posX ,
									angle =  110;
								}else{
									posX = objPos.x - trajectoryProp.posX;
									posY = objPos.y - trajectoryProp.posY;
									angle =  250;
								}

								for(var ii = 0; ii < trajectoryCnt.length ; ii++ ){
									if( trajectoryCnt[ii].update( posX, posY, angle, turn, this.monsterParameters.object ) )
										trajectoryCnt.splice( ii, 1 )
								}
							}
						}
						
					},
					update: function(){
						
						//moving
						var position = this.object.position,
						object = this.object,
						objTranslate = this.objTranslate,
						monsterTarget = scope.monsterTarget,
						staticObjStateX = objTranslate.staticObjStateX,
						outterWallXisStop = objTranslate.staticsWallOuterIsStopX, state,
						isMonsterTarget = monsterTarget !== '',
						dirSwitch = this.dirSwitch;
						
						if( objTranslate.isCenter.state ){
							
							var staticObjMoveX = this.moveReplaceX,
							staticObjMoveY = this.moveReplaceY;
							
						}else{
							
							if( isNaN( objTranslate.staticObjMoveX ) || isNaN( objTranslate.staticObjMoveY ) ){
								objTranslate.staticObjMoveX = this.moveReplaceX,
								objTranslate.staticObjMoveY = this.moveReplaceY;
							}
							
							var staticObjMoveX = objTranslate.staticObjMoveX,
							staticObjMoveY = objTranslate.staticObjMoveY;
						}
						
						
						this.trajectoryCheck();
						
						this.performAttacking( monsterTarget, objTranslate, position );
						
						//critical effect update
						this.criticalParticle.update()
						
						/*
						if( this.pointingAnimate.active ){
							this.pointingAnimate.update( scope.context )
						}*/
						
						//delay switch 
						if( dirSwitch.delayDir >= 0){
							
							dirSwitch.delayDir --;
							
							if( dirSwitch.delayDir === 0 ){
								var status = scope[  this.characterState ].get( this.object.label );
								if( status !== 'walk'  ) scope[  this.characterState ].set( this.object.label, 'walk' );
							}			
						}

						//helpTick // boss need help
						if( this.helpTick > 0 ){
							this.helpTick--
							if( this.helpTick === 0 ){
								object.attacker = false;
								object.needHelp = false;
							}
						}
						
						//update skill
						this.skillUpdate( monsterTarget );
						
						//update special items
						this.specialItems.updateRegisterItemFn();
						
						//update Buff 
						this.buff.update();

						//healing hp and mp
						if( this.characterParameters.health > 0 
							&& this.characterParameters.health < this.characterParameters.maxHealthCure ){ 
							this.cureSelf(  scope.slotButtonHp, 'healthpotion', 'hpTickState', 'hpPotionUpdate' );
						}
						
						if( !this.hpTickState ){
							if( this.hpPotionUpdate() ) this.hpTickState = true;
						}
						 
						if( this.characterParameters.mp < this.characterParameters.maxMpCure ){	
								this.cureSelf(  scope.slotButtonMp, 'manapotion', 'mpTickState', 'mpPotionUpdate' );
						
						}
						if( !this.mpTickState ){
							if( this.mpPotionUpdate() ) this.mpTickState = true;
						}

						this.convertAttackMonsterToDamage();
				 
						//move up
						if( this.moveUp && this.dungeonActive && !object.forceGravity) scope.Body.translate( object, { x: 0 , y:-staticObjMoveY  });

						//move down
						if( this.moveDown && this.dungeonActive ) scope.Body.translate( object, { x: 0 , y:staticObjMoveY });
						
						//move left
						if( this.moveLeft ){	
							var firstLoad = objTranslate.firstLoadLeft;
							this.changeDir("left")
							scope.Body.translate( object, { x: -staticObjMoveX , y:0  });
						}
						
						//move right
						if( this.moveRight ){
							var firstLoad = objTranslate.firstLoadRight;
							
							this.changeDir("right")
							scope.Body.translate( object, { x: staticObjMoveX , y:0  })
						}
						//jump
						if( this.jump && !this.preventControl ){ 
							if( dirSwitch.jump ){
								 scope[  this.characterState ].set( object.label, 'jump' );
								dirSwitch.jump = false;
							}
							scope.Body.translate( object, { x: 0  , y: this.jumpSpeed   });
						} 
						
						this.screenCheck();
						 
					},
					rigBodyAI : {
						state : false
					},
					switchCharacterAuto : function(){
						if( this.bossObject ){
							var objectParty = [ this.bossObject ].concat( this.bossObject.pions ),
							characterLabel = this.object.label;
							
							for( var ii = 0, len = objectParty.length; ii < len ; ii++ ){
								var objParty = objectParty[ii];
								  
								if( /hero/i.test( objParty.label ) && objParty.label !== characterLabel  ){
									this.switchCharacter( objParty );
									return true;
								}
							}
							
						}

						return false;
					},
					switchCharacter : function( b ){
				 
						var self = this,
						rigidHero = b.rigBody,
						rigidAI = this.rigBodyAI;
						 
						//reset gui // error, rigidHero.cureSelf.reset is not a function
						typeof rigidHero.cureSelf.reset === "function" &&
							rigidHero.cureSelf.reset(); // let guiSupportAvailable stored  first
						 
						if( rigidAI.state ){
							 
							rigidAI.object.rigBody = this.rigBodyAI.rigBody;
							rigidAI.object.render.behaveRig = this.rigBodyAI.behaveRig;
							rigidAI.object.stateStorage = this.rigBodyAI.stateStorage;
							rigidAI.object.statParameters = this.rigBodyAI.statParameters; 
							rigidAI.object.rigBody.monsterParameters = this.rigBodyAI.statParameters; 
							rigidAI.object.rigBody.pointMove = b;
							rigidAI.object.rigBody.replaceObjectSpawnByRand.selectedObjSpawn = b;
							rigidAI.rigBody.skill.active = self.cntTickSkill;
							rigidAI.rigBody.cntActiveSkill = self.cntActiveSkill;
							rigidAI.rigBody.dirSwitch = this.rigBodyAI.dirSwitch;
							rigidAI.rigBody.dirSwitch.reset();
							rigidAI.rigBody.attackFrame = this.rigBodyAI.attackFrame;
							rigidAI.rigBody.rigState = true;
							 
							//update moveSpeed //origin property is generated at binding buff 
							var moveReplaceX = self.originX ? self.originX : self.moveReplaceX;
							
							rigidAI.rigBody.moveSpeedAttack = self.moveReplaceX;
							rigidAI.rigBody.moveSpeedNormal = self.moveReplaceX;
							rigidAI.rigBody.moveSpeed = self.moveSpeed >= 0 ? self.moveReplaceX : -self.moveReplaceX;
							
							//set gui
							rigidAI.rigBody.cureSelf.gui =  true;
							// then update bar
							rigidAI.rigBody.cureSelf.updateBar( 'hp-inner-line-bar' );
							rigidAI.rigBody.cureSelf.updateBar( 'mp-inner-line-bar' );
							rigidAI.rigBody.cureSelf.updateAvatar();
							 
							//update AI bag location
							
							//is required to update swaping equipment
							scope.globalObjectGUI["value"].checkBagLocation( "default", scope.characterInventoryBag['value'].get( this.rigBodyAI.rigBody.object.label ), "bag"  );
							 
							//continue attacking 
							if(  this.isAttacking )
								rigidAI.rigBody.forceObjectToAttack( this.monsterParameters.object, true );
							else 
								rigidAI.rigBody.behaveRandomFn(1);//
						
						
							
						}else{
							//capture rigBody at first execute
							// pass oval's rigid
							this.rigBodyAI.state = true;
							
							// then remove oval from render world
							scope.World.remove( scope.engine.world, this.object);
							
						}
						
						rigidAI.object = b;
						rigidAI.stateStorage = b.stateStorage;
						rigidAI.statParameters = b.statParameters;
						rigidAI.rigBody = rigidHero;
						rigidAI.cntTickSkill = rigidHero.skill.active;
						rigidAI.cntActiveSkill = rigidHero.cntActiveSkill;
						rigidAI.dirSwitch = rigidHero.dirSwitch;
						rigidAI.attackFrame = rigidHero.attackFrame;
						rigidAI.behaveRig =  rigidHero.object.render.behaveRig;
						
						
						//reset skill to reset the state
						rigidHero.skill.reset( rigidHero, rigidHero.cntStateSkill )
						
						/* CHARACTER */
						
						self.attackFrame = rigidHero.attackFrame;
						 
						//replace Object
						scope.oval["value"] = b;
						
						scope.mainCharacter = b;
						
						self.object = b;
						
						//update behaveRig	
						rigidHero.object.render.behaveRig &&
							( self.object.render.behaveRig = rigidHero.object.render.behaveRig );
						
						//indicate is boss or pawns
						self.bossObject =  rigidHero.pitboss ? b : rigidHero.boss;
						
						//marking leader
						if( rigidHero.pitboss ){
							scope.removeClass( scope.qs("chara-leader"), "hidden" );
							scope.addClass( scope.qs("chara-leader-small"), "hidden" );
						}else{
							scope.addClass( scope.qs("chara-leader"), "hidden" );
							scope.removeClass( scope.qs("chara-leader-small"), "hidden" );
						}
						
						self.object.stateStorage = self.characterState;
						
						scope.Body.setPosition( self.object,{
							x : b.position.x ,
							y : b.position.y 
						})
						
						//update initialSpawn
						self.initialSpawn = rigidHero.initialSpawn;
						
						//aggresive to
						self.aggresive = rigidHero.aggresive;
						
						//old obj's Params
						self.characterParameters.mainCharacter = false;
						
						//inventory
						self.loot =   scope.characterInventoryBag['value'].get( self.object.label )
						
						//new obj's Params
						
						//dungeonAttackRangeY
						self.dungeonAttackRangeY = rigidHero.dungeonAttackRangeY
						self.dungeonAttackRange = rigidHero.dungeonAttackRange;
						
						//BoundsWidthOperator
						self.BoundsWidthOperator = rigidHero.BoundsWidthOperator;
						
						
						//avatar
						self.avatar = rigidHero.avatar;
						
						self.buff = rigidHero.buff;
						
						self.dirSwitch = rigidHero.dirSwitch ;
						 
						self.characterParameters = b.statParameters;
						 
						self.characterParameters.mainCharacter = true;
						  
						//global character params
						scope.characterParameters['value'] = self.characterParameters;
						 
						//switch skill
						self.cntTickSkill = rigidHero.skill.active;
						
						self.cntActiveSkill = rigidHero.cntActiveSkill;
						
						//switch statParameters
						self.object.statParameters = self.characterParameters;
						 
						//update parameters Object
						self.object.statParameters.object = self.object ;
						
						//update rigBody
						self.object.rigBody = self; 
						
						//update moveSpeed
						self.moveReplaceX = rigidHero.moveSpeedAttack;
						self.moveReplaceY = rigidHero.moveSpeedAttack - ( rigidHero.moveSpeedAttack * 0.222 );
						self.moveStaticX = rigidHero.moveSpeedAttack;
						self.moveStaticY = rigidHero.moveSpeedAttack - ( rigidHero.moveSpeedAttack * 0.222 );
						self.moveSpeed = self.moveSpeed >= 0 ? rigidHero.moveSpeedAttack : -rigidHero.moveSpeedAttack;
						
						
						//force to center
						scope.objTranslate['value'].isCenter.state = true;
						
						//reset changeDir
						self.latestDir = "";
						
						//reset
						 
						if( this.moveLeft || this.moveRight  || this.moveUp || this.moveDown ){
							scope[  self.object.stateStorage ].set( self.object.label, 'walk' ); 
						}else{
							scope[  self.characterState ].set( self.object.label, 'idle' ); 
						}
						 
						//self.latestDir = "";
						
						//difined it to global
						if( !scope.characterGetDamage['value'].get( b.label ) ){
						
							scope.characterGetDamage['value'].set( b.label, [] );	
						
						}
						
						//update prop characterGetDamage to local scope
						self.characterGetDamage = scope.characterGetDamage['value'].get( self.object.label );
						 
						
						if( !scope.characterSkills['value'].get( self.object.label ) ){
							
							scope.characterSkills['value'].set( self.object.label, rigidHero.cntStateSkill ) 
						
						}
						
						//update prop characterSkills	
						self.characterSkills =  {
							skills : scope.characterSkills['value'].get( this.object.label ),
							initial : scope.characterSkills['value'].get( 'initial')
						}
						
						//console.log( self.cntTickSkill )
						//console.log( scope.characterSkills['value'].get( self.object.label ) )
						
						
						scope.globalObjectGUI["value"].fetchLoot();
						scope.globalObjectGUI["value"].fetchSkill();
						scope.globalObjectGUI["value"].attachMainPotions( true );
						scope.isMobile() && scope.globalObjectGUI["value"].GUImobile.replaceSkills('detached');
						
						self.updateHpBar()
						self.updateMpBar()
						self.updateAvatar()
						 
						rigidHero.rigState = false;
						
						//console.log( scope.monsterControl.objSpawnMonster )
						//console.log( scope.orderObj )
						//console.log( scope.Composite.allBodies( scope.engine.world ) )
						
					}, 
					
					updateMonsterParamsAngGUI : function( monsterLabel ){
						 
						//reset
						this.monsterParameters = scope.monsterParameters['value'].get( scope.monsterTarget ? scope.monsterTarget : monsterLabel ); 
						this.monsterParameters  && ( this.monsterParameters.object.monsterTarget = false );
						
						//update			
						this.monsterParameters = scope.monsterParameters['value'].get( monsterLabel );
						this.monsterParameters && ( this.monsterParameters.object.monsterTarget = true );
						
						scope.monsterTarget = monsterLabel
						this.monsterTarget = monsterLabel;
			 
						if( this.monsterParameters && this.isEnemyFn( monsterLabel ) ){
							
							this.dirSwitch.reset();
							
							//gui
							var monsterLevel = this.monsterParameters.monsterLevel;
							if( monsterLevel ){
								 
								switch( this.monsterParameters.monsterLevel.toLowerCase() ){
									case "a" :
									case "s" : status  = "red"
										break;
									case "b" :
									case "c" : status  = "orange"
										break;
									default : status = "green"
								}
								
								scope.text( scope.getFirstChild( scope.qs('box-m-level') ), monsterLevel );
								scope.removeClass( scope.qs('box-m-level'), "hidden")
							}else{
								scope.addClass( scope.qs('box-m-level'), "hidden")
							}
							
							scope.qs('circle-bar-stat').className = 'circle-bar-stat '+status;
							 
						} 
					},
					
					event :function(){
							
						var self = this,
						map = '',
						stateRocket = {},
						targetCompanion = {
							dirX : 0,
							sekleton : '',
							sekletonTarget : ''
						}, 
						mouseInTargetFn = function( b, mousePosition ){
							var additionalBoundsValue = b.additionalBoundsValue ? b.additionalBoundsValue : 0;
							return b.bounds.min.x - additionalBoundsValue < mousePosition.x &&
							b.bounds.max.x  > mousePosition.x &&
							b.bounds.min.y - additionalBoundsValue < mousePosition.y &&
							b.bounds.max.y  > mousePosition.y;
						};
					
						
						// prevent matter js event execute twice
						scope.Events.on( scope.engine, 'collisionStart', function(event) {
							var pairs = event.pairs;
							for (var i = 0, j = pairs.length; i != j; ++i) {
								var pair = pairs[i],
								bodyA = pair.bodyA,
								bodyB = pair.bodyB,
								pBodyA = bodyA.parent,
								pBodyB = bodyB.parent,
								labelA = bodyA.label === 'Body' && !bodyA.outterWall ? bodyA.parent.label : bodyA.label,
								labelB = bodyB.label === 'Body' && !bodyB.outterWall ? bodyB.parent.label : bodyB.label;

								if( /static|oval/i.test( labelA )
									&& /static|oval/i.test( labelB )
									&& ( self.jump || scope.characterMobileControl['value'].jump ) ){
									self.jump = false;
									scope.characterMobileControl['value'].jump = false;
									self.dirSwitch.jump = true;
									
									if( self.moveLeft || self.moveRight || scope.characterMobileControl['value'].moveLeft ){
										scope[ self.characterState ].set( self.object.label, 'walk' );
									}else {
										scope[ self.characterState ].set( self.object.label, 'idle' );
									}

								}
								
								if( /buffer/i.test( labelA ) ||
									/buffer/i.test( labelB ) ){
									if( pBodyA.drawLine /* && self.object.label !== labelB  */ && pBodyA.setVertiecsByPoint ){
										
										var rigBody = pBodyB.rigBody;
										rigBody.dirSwitch.dirBlock.sortedVerts.length = 0;
										
										if( /back|attack/i.test( rigBody.behave ) ){
											pBodyA.setVertiecsByPoint.getTarget( pBodyB );
										}else{
											pBodyA.setVertiecsByPoint.getTargetByRandDestPoint( pBodyB );
										}
										
										
									}else if( pBodyB.drawLine /*  && self.object.label !== labelA  */){
										 
										
										var rigBody = pBodyA.rigBody;
										rigBody.dirSwitch.dirBlock.sortedVerts.length = 0;
										
										if( /back|attack/i.test( rigBody.behave ) ){
											pBodyB.setVertiecsByPoint.getTarget( pBodyA );
										}else{
											pBodyB.setVertiecsByPoint.getTargetByRandDestPoint( pBodyA );
										}
										
									}
								}
								
								
								if( self.object.label === labelB 
									|| self.object.label === labelA  ){
																		
									self.objTranslate.objPhysCollide = true;	
									
									
								}
								
								
								if( /staticWall|monster/i.test( labelA )
									&& /staticWall|monster/i.test( labelB )
									&& /dungeon/i.test( scope.activeMap['value'] )){
									
									if( /monster/i.test( labelB ) ){
										scope[ pair.bodyB.stateStorage ].set( labelB, 'turn' );
										pair.bodyB.outterWall = labelA
									}
									if( /monster/i.test( labelA ) ){
										scope[ pair.bodyB.stateStorage ].set( labelA, 'turn' );
										pair.labelA.outterWall = labelB
									}
									
								}

									
							}
							
						});
						
						
						scope.Events.on( scope.mouseConstraint['value'], 'mousedown', function( event )
						{
							var mousePosition = event.mouse.position,
							target = scope.oval['value'].position;
							//self.pointingAnimate.targetCompanion.dirX = mousePosition.x;

							var bodies = scope.Composite.allBodies( scope.engine.world ), b, mouseInTarget ,tempMonster = [];

							for( var ii = 0; ii < bodies.length ; ii++ )
							{
								b = bodies[ii],
								mouseInTarget = self.pointingAnimate.mouseInTargetFn( b, mousePosition );
								 
								if( /monster/i.test( b.label )  && !/hero/i.test( b.label ) && mouseInTarget ) {
									
									tempMonster.push( b )
									
									var back = tempMonster[ tempMonster.length - 2 ];
									
									if( back && tempMonster.length > 1 && !back.rigBody.isStatic ){ // static rigBody object
										b = back //backward one step 
									}
									
								}else if( /npc/i.test( b.label ) && mouseInTarget && b.visible ){
									
									b.touch && scope.removeClass( scope.qs('box-dialog'), 'hidden');
									
									scope.updateMessageText['value']( b.label )
									
									b.touch && scope.characterUpdateQuest['value']( b.label );
									
								}else if( !scope.isMobile() && /hero/i.test( b.label ) && b.label !== self.object.label && mouseInTarget  ){
									
									self.switchCharacter( b )
									
								}

								
							}
							   
							if( tempMonster.length ){
								
								var len = tempMonster.length;
								if( len === 1 && tempMonster[0].rigBody.isStatic ){
									
									self.updateMonsterParamsAngGUI( tempMonster[0].label );
								}else{
								
									while ( tempMonster.length ){
										
										var indexRand = scope.random( tempMonster.length - 1, 0 ),
										monsterObj = tempMonster[ indexRand ];
										
										if( !monsterObj.rigBody.isStatic ){
											self.updateMonsterParamsAngGUI( monsterObj.label );
											break;
										}
										
										tempMonster.splice( indexRand, 1 )
										
									}
								}
								
							}else{
								
								//reset
								if( scope.monsterTarget ){
									self.monsterParameters = scope.monsterParameters['value'].get( scope.monsterTarget ); 
									self.monsterParameters && ( self.monsterParameters.object.monsterTarget = false );
								}
								
								scope.monsterTarget = '';
								scope.addClass( scope.qs('monster-bar'), 'hidden' ); 
							}
							
							
							/*
							if( !self.pointingAnimate.initMb ){
								self.pointingAnimate.cursorStartEventFn( mousePosition )
							}*/
						})
						
						/*
						scope.Events.on( scope.mouseConstraint['value'], 'mousemove', function( event )
						{
							if( !self.pointingAnimate.initMb ){
								self.pointingAnimate.cursorMoveEventFn( event.mouse.position )
							}
						})
						
						
						scope.Events.on( scope.mouseConstraint['value'], 'mouseup', function( event )
						{	
							if( !self.pointingAnimate.initMb ){
								self.pointingAnimate.cursorEndEventFn( event.mouse.position )
							}
						})*/
							
						
					},
					keyDown :function(){
						var self = this;
						scope.attachListener( document.body, 'keydown', function( event ){
							if( !this.preventControl && scope.characterParameters['value'].health ){
								var status = scope[  self.characterState ].storage[0].status;
								switch( event.keyCode ) {
									case 87: self.moveUp = true;
										scope.objTranslate['value'].moveUp =  true;
										if( scope.characterStatus['value'] !== 'up'  )
												scope.characterStatus['value'] = 'up';
										if( status !== 'walk' && !self.jump ) 
												scope[  self.characterState ].set( self.object.label, 'walk' );
										 
										self.dirSwitch.delayDir = 2;	
										break;
									case 83: self.moveDown = true;
										scope.objTranslate['value'].moveDown =  true;
										if( scope.characterStatus['value'] !== 'down' ) 
											scope.characterStatus['value'] = 'down';
										if( status !== 'walk' && !self.jump ) 
											scope[  self.characterState ].set( self.object.label, 'walk' );
										self.dirSwitch.delayDir = 2;
										
										break;
									case 70:  self.findTargetToAttack(); break;
									case 65: self.moveLeft = true;
										if( ! scope.objTranslate['value'].moveLeft  )  
											scope.objTranslate['value'].moveLeft  = true;
										if( scope.characterStatus['value'] !== 'left' ) 
											scope.characterStatus['value'] = 'left'; 
										self.dirSwitch.delayDir = 2;
										break;
									case 68: self.moveRight = true;
										if( !scope.objTranslate['value'].moveRight ) 
											scope.objTranslate['value'].moveRight = true;
										if( scope.characterStatus['value'] !== 'right' ) 
											scope.characterStatus['value'] = 'right'; 
										self.dirSwitch.delayDir = 2;
										break;
									case 32:
										if( scope.monsterTarget  === '' && ( !self.dungeonActive || self.object.forceGravity ) ){
											self.jump = true;
											scope.characterStatus['value'] = 'jump'
										};
										break;
									
								}
								
								if( !self.objTranslate.isCenter.state ){
									self.objTranslate.staticObjMoveX = self.moveStaticX = self.moveReplaceX;
									self.objTranslate.staticObjMoveY = self.moveStaticY =  self.moveReplaceY;
								}
							
							}
						})
					},
					keyUp :function(){
						var self = this;
						function isIdle(){
							if( !( self.moveUp || self.moveDown || self.moveLeft || self.moveRight ) && !self.jump  ){
								scope[  self.characterState ].set( self.object.label, 'idle')
							}
						}
						
						
						scope.attachListener( document.body, 'keyup', function( event ){
							if( scope.characterParameters['value'].health && !this.preventControl ) {
								switch( event.keyCode ) {
									case 87: self.moveUp = false,
										scope.objTranslate['value'].moveUp =  false,
										isIdle()
										scope.characterStatus['value'] = 'idle'; break;
									case 83: self.moveDown = false,
										scope.objTranslate['value'].moveDown =  false,
										isIdle();
										scope.characterStatus['value'] = 'idle'; break;
									case 65: self.moveLeft = false;
										isIdle();
										scope.characterStatus['value'] = 'idle',
										 scope.objTranslate['value'].moveLeft  = false; break;
									case 68: self.moveRight = false;
										isIdle();
										scope.objTranslate['value'].moveRight = false,
										scope.characterStatus['value'] = 'idle'; break;
								}
							}	
						}.bind(this))
					},
					velocity : 0,
					translating : false, 
					screenCheck :  function(){
						var map = scope.activeMap['value'],
						objTranslate = this.objTranslate;
						if( this.activeMap !== map )
						{
							var r = "in"+"render";
							
							this.staticWallOutter =  scope.staticWallOutter['value']()
							this.activeMap = map;
							
							this.block = scope[r] ? scope[r]() : false;
							 
							// enter dungeon
							if(/dungeon/i.test( map )){
								
								objTranslate.staticObjMoveX = this.moveStaticX;
								
								objTranslate.staticObjMoveY = this.moveStaticY;
								this.dungeonActive = true;
							}else{
								this.moveStaticY = 3
								objTranslate.staticObjMoveY = this.moveStaticY;
								this.dungeonActive = false;
							}
						}
						
						 
						if( !scope.isSwitchMapActive && this.characterParameters.health ){
						
							var screenWidth = scope.browserWidthUpdate,
							screenHeight = scope.browserHeightUpdate,
							position = this.object.position,
							leftWallPos = this.staticWallOutter[3].position,
							rightWallPos = this.staticWallOutter[2].position,
							bottomWallPos = this.staticWallOutter[1].position,
							topWallPos = this.staticWallOutter[0].position,
							//charStat = scope.characterStatus['value'],
							statY = objTranslate.staticObjStateY,
							statX = objTranslate.staticObjStateX,
							  
							centerX = 10,
							centerY =  10, 
							
							isCenter = objTranslate.isCenter,

							halfCenterX = screenWidth / 2,// set focus character to center view port
							halfCenterY = screenHeight / 2,// set focus character to center view port
							statObjMoveY = objTranslate.staticObjMoveY,
							
							//static y move
							toleranceY = Math.abs( halfCenterY -  Math.floor( position.y ) );
						 
							//center state 
							isCenter.init = true; 
							
						
							//static move y
							if( ( !this.isTranslateY || !this.jump ) && toleranceY < centerY && statY ){
								objTranslate.staticObjStateY = ''; 
								if( !this.dungeonActive && objTranslate.moveDown ) objTranslate.moveDown = false;
								if( !this.dungeonActive && objTranslate.moveUp ) objTranslate.moveUp = false;
							
							}else if( ( !this.isTranslateY || !this.jump ) && halfCenterY - position.y > centerY  ){
								if( topWallPos.y + 30 < 0 ) {
									objTranslate.staticObjStateY = 'up';
									//scope.characterStatus['value'] = 'up';
									
									if( !this.dungeonActive ){
										objTranslate.moveUp = true;
										if( statObjMoveY !== 4 ) objTranslate.staticObjMoveY = 4;
										this.moveStaticY = 9;
									}
								}else{ 
									
									isCenter.init = false;
									
									if( statY ) objTranslate.staticObjStateY = ''; //prevent chara passing top outter wall
								}
							}else  if( ( !this.isTranslateY || !this.jump ) &&  ( halfCenterY - ( centerY - 10 ) ) - position.y < 0 ){
								
								
								if( bottomWallPos.y - 30 >= ( screenHeight + centerY) ){
									
									objTranslate.staticObjStateY = 'down';
									//scope.characterStatus['value'] = 'down';
									objTranslate.moveDown = true;
									
									//performances idle
									if( !this.dungeonActive ){
										objTranslate.moveDown = true;
										this.moveStaticY += 0.2
										if( this.object.moveStaticY.y > 0 ) objTranslate.staticObjMoveY += 0.2;
										else objTranslate.staticObjMoveY = Math.floor( this.moveStaticY )
									}
								}else{
									
									isCenter.init = false;
									
									if( statY ) objTranslate.staticObjStateY = ''; //prevent chara passing bottom outter wall
								}
									//performances idle
							}else if( ( this.isTranslateY || this.jump ) ){
								if( statY ) objTranslate.staticObjStateY = '';
							}
							 
						 
							//static x move
							var toleranceX = Math.abs( halfCenterX -  Math.floor( position.x ) );
							
							if( toleranceX > 0 && toleranceX <= centerX  ){
								
								
								objTranslate.staticObjStateX = ""; 
								if(  objTranslate.moveLeft ) objTranslate.moveLeft = false;
								if(  objTranslate.moveRight ) objTranslate.moveRight = false;
							
							}else if( halfCenterX - position.x > centerX  ){
								if( leftWallPos.x + 30 < 0 ) {
									objTranslate.staticObjStateX = "left";
									
								}else{
									
									isCenter.init = false;
									
									if( statX ) objTranslate.staticObjStateX = ""; //prevent chara passing left outter wall
								}
							}else  if(  ( halfCenterX - ( centerX - 10 ) ) - position.x < 0 ){
								
								
								
								if( rightWallPos.x - 30 >= ( screenWidth + centerX) ){
									
									objTranslate.staticObjStateX = "right";
									//scope.characterStatus['value'] = 'down';
									objTranslate.moveRight = true;
									
									objTranslate.staticObjAllX = true;
									
									
								}else{
									
									isCenter.init = false;
									
									if( statX ) objTranslate.staticObjStateX = ""; //prevent chara passing right outter wall
								
								}
								
									//performances idle
							}
							
							 
							//force to center
							if( isCenter.state ){
								 
								var distanceX = halfCenterX - position.x,
								distanceY = halfCenterY - position.y,
								distance = Math.abs( distanceX ) > Math.abs( distanceY ) ? distanceX : distanceY,
								vec = scope.moveVector2dWithVelocity( position, { x : halfCenterX, y : halfCenterY }, Math.abs( distance / 10 ) );
								 
								
								if( distanceX >= 30  || distanceY >= 30 || distanceX <= -30 || distanceY <= -30 ){
									
									if( distanceX >= 30 ){
										objTranslate.staticObjMoveX = vec.x;
									}
									
									if( distanceY >= 30 ){
										objTranslate.staticObjMoveY = vec.y;
									}
							
									if( distanceX <= -30 ){
										objTranslate.staticObjMoveX = Math.abs( vec.x );
									}
									
									if( distanceY <= -30 ){
										objTranslate.staticObjMoveY =  Math.abs( vec.y );
									}
									
									
								}else{
										
									objTranslate.staticObjMoveX = this.moveReplaceX;
									objTranslate.staticObjMoveY = this.moveReplaceY;
									
									isCenter.state = false;
								}
								
								
							}
							
							
						} 

						
						
					},
					onMove : function(){

						var self = this

						scope.attachListener( self.container, scope.CursorStartEvent, function( event ){

						})

						scope.attachListener( self.container, scope.CursorEndEvent, function( event ){

						})

						scope.attachListener( self.container, scope.CursorLeaveEvent, function( event ){

						})

						scope.attachListener( self.container, scope.CursorMoveEvent, function( event ){
							self.mousePosX = event.clientX
							self.mousePosY = event.clientY
						})
					},
					avatar : "chara.png",
					updateAvatar : function(){
						scope.css( scope.qs("chara-url"),{
							"background" : "transparent url("+ scope.path + this.avatar +") no-repeat top center",
							"background-size" : "100% auto"
						})
					},
					updateMpBar :function(){
						scope.text( scope.qs('mp-indicator-text'), Math.round(  this.characterParameters.mp )+' / '+ Math.round( this.characterParameters.maxMp ) );
						scope.qs('mp-circle-bar').className = 'c100 blue mp-circle-bar p'+Math.floor( this.characterParameters.mp / this.characterParameters.maxMp * 100 )
					},
					updateHpBar :function(){
						scope.text( scope.qs('hp-indicator-text'), Math.round( this.characterParameters.health )+' / '+ Math.round( this.characterParameters.maxHealth ) );
						scope.qs('hp-circle-bar').className = 'h100 red hpBox hp-circle-bar p'+ Math.round( this.characterParameters.health / this.characterParameters.maxHealth * 100 )
					},
					initControl : function(){
						
						this.object.statParameters = this.characterParameters;
						this.onMove()
						this.keyUp()
						this.keyDown()
						this.event()
						this.updateHpBar()
						this.updateMpBar()
						
						scope[ this.characterState ].set(  this.object.label, 'idle' );
						scope.characterMobileControl['value'].charObj = this;
					}
				}
				
				scope.extend( _obj, new scope.components.buff, true );
				
				scope.extend( _obj, new scope.components.companions( "chara" ) , true );
				
				scope.extend( _obj, new scope.components.objPropertyFn( "chara" ) , true );
				
				scope.extend( _obj, new scope.physicsComponent.itemTrajectoryComponent, true);
				
				scope.extend( _obj, new scope.AI.pathFinding, true );
				
				scope.extend( _obj, new scope.AI.attackBehaviour( "chara" ) , true );
				
				scope.extend( _obj, new scope.AI.skillBehaviour( { character : true }, _obj ) , true );
				
				scope.extend( _obj, new scope.AI.playerProperies , true );
				
				
				
				scope.extend( _obj.attackFrame,  new scope.components.attackFrameAttribute, true );
				
				scope.characterControl = _obj
				scope.oval['value'].rigBody = _obj;
				
				//update first load hp & mp chara;
				scope.text( scope.qs('mp-indicator-text'), _obj.mp+' / '+_obj.maxMp );
				scope.text( scope.qs('hp-indicator-text'), _obj.health+' / '+_obj.maxHealth );

				_obj.initControl()
			},

			statics : function(){
				var scope = this, _obj;
				_obj = {
					staticWallOutter: scope.staticWallOutter ['value'](),
					object : scope.oval['value'],
					activeMap : '',
					isInPortalFn :function( portalIn ){
						var pos = this.object.position;
						return ( portalIn.x < pos.x && portalIn.y < pos.y
							&& portalIn.xMax() > pos.x && portalIn.yMax() > pos.y && portalIn.isVisible );
					},
					installMapObject : function( location, init ){
						var cnt = scope.staticAllMap['value'][ location ].content,
						monsterParams = scope.monsterParameters['value'].storage,
						screenWidth = scope.browserWidthUpdate,
						screenHeight = scope.browserHeightUpdate;
						//prevent Bottleneck monsterParams
						if( init === 'add' ){ 
							//reset
							monsterParams.length = 0;
							scope.monsterGetDamage['value'].storage.length = 0;
						};
						
						var monsterParamsFn =  function( target, initParams, setObject ){
							if( /monster/i.test( target ) ){
								//remove monster params
								if( initParams === 'add' ){
									scope.monsterParameters['value'].set( target, setObject )
								}else{
									for(var kk = 0, ll = monsterParams.length; kk < ll; kk++ ){
										if( !!monsterParams[kk] && monsterParams[kk].name === target ){
											scope.monsterParameters['value'].remove( target )
										}
									}
								}
							}
						}
						
						for(var ii in cnt )if( ii in cnt ){
							var obj = cnt[ii];
							if( cnt[ii] instanceof Array ){
								for(var jj = 0; jj < obj.length; jj++){
									if( init === 'add' ){
													
										//add layer content
										if( obj[jj].layer && !localStorage.getItem('load') && obj[jj].appear  ){
											for(var kk = 0, layer = obj[jj].layer.object; kk < layer.length ; kk++ ){
												scope.World.add( scope.engine.world, layer[ kk ] )
											}
										}else{
											
											scope.World.add( scope.engine.world, obj[jj] )
											obj[jj].rigBody && monsterParamsFn( obj[jj].label, 'add', obj[jj].rigBody.monsterParameters )
										}
									}else{
										//remove layer content
										if( obj[jj].layer  && !localStorage.getItem('load') && obj[jj].appear ){
											for(var kk = 0, layer = obj[jj].layer.object; kk < layer.length ; kk++ ){
												scope.World.remove( scope.engine.world, layer[ kk ] )
											}
										}else{
											scope.World.remove( scope.engine.world, obj[jj] )
											monsterParamsFn( obj[jj].label, 'remove' )
										}
									}
								} 
							}else{
								if( init === 'add' ){
									scope.World.add( scope.engine.world, obj )
									obj.rigBody && monsterParamsFn( obj.label, 'add', obj.rigBody.monsterParameters )
								}else{
									scope.World.remove( scope.engine.world, obj )
									monsterParamsFn( obj.label, 'remove' )
								}
							}
						}
					}
				}

				scope.staticControl = _obj
			},
			geometries: function(){
				var scope = this,
				
				diviceWidth = 3000,
				diviceHeight = 3000,

				staticSmallWidth = 50,
				staticMediumWidth = 200,
				
				heightTop,
				
				
				obj = {
					createWall : function( map, mapsize ){
						
						//mapsize
						var height, width;
						
						if( mapsize &&  mapsize === 'large' ){ 
							heightRight = diviceWidth * 2;
							heightLeft = diviceWidth * 2;
							heightTop = diviceWidth * 2;
							heightBottom = diviceWidth * 2;
						}else if( mapsize &&  mapsize === 'medium' ){
							heightRight = diviceWidth * 2;
							heightLeft = diviceWidth ;
							heightTop = diviceWidth * 2;
							heightBottom = diviceWidth * 2;
						}else{//small
							heightRight = diviceWidth;
							heightLeft = diviceWidth ;
							heightTop = diviceWidth;
							heightBottom = diviceWidth;
						}

						
						
						var wallRight =  scope.Bodies.rectangle( heightRight,  -( heightRight / 2 ) + scope.browserHeightUpdate, 50, heightRight, { isStatic: true }),
						wallLeft =  scope.Bodies.rectangle( 0, -( heightLeft / 2 ) + scope.browserHeightUpdate, 50,  heightLeft, { isStatic: true });
					 
						var wallTop =  scope.Bodies.rectangle( wallLeft.bounds.min.x + heightTop / 2 , wallLeft.bounds.min.y + 50, heightTop, 50, { isStatic: true }),
						wallBottom =  scope.Bodies.rectangle(  heightBottom / 2 , wallLeft.bounds.max.y + 50, heightBottom, 50, { isStatic: true })
						
						wallTop.label = 'staticWallTop'+ map;
						wallBottom.label = 'staticWallBottom'+ map;
						wallRight.label = 'staticWallRight'+ map;
						wallLeft.label = 'staticWallLeft'+ map;
						
						return [ wallTop, wallBottom, wallRight, wallLeft ]
					},
					createLayer : function( label, object ){
						return scope.staticGeometry.createLayer({
							label : label,
							rangeX : object.x,
							rangeY : object.y,
							attach : 'staticWallOutterBottom',
							layer : {
								object : object.layer,
								init : false,
								firstLoad : false
							},
							install : false,
							width : 3000,
							height : 3000,
							location : object.location,
						});
					},
					createBackground : function( layerDeep, source, location, index ){ // maximum layer 6000 x 6000 px
						var layers = [
								['a_133.png','a_134.png','a_135.png','a_136.png','a_137.png','a_138.png','a_139.png', 'a_140.png','a_141.png','a_142.png','a_143.png','a_144.png'],
								['a_121.png','a_122.png','a_123.png','a_124.png','a_125.png','a_126.png','a_127.png', 'a_128.png','a_129.png','a_130.png','a_131.png','a_132.png'],
								['a_109.png','a_110.png','a_111.png','a_112.png','a_113.png','a_114.png','a_115.png', 'a_116.png','a_117.png','a_118.png','a_119.png','a_120.png'],
								['a_97.png','a_98.png','a_99.png','a_100.png','a_101.png','a_102.png','a_103.png', 'a_104.png','a_105.png','a_106.png','a_107.png','a_108.png'],
								['a_85.png','a_86.png','a_87.png','a_88.png','a_89.png','a_90.png','a_91.png', 'a_92.png','a_93.png','a_94.png','a_95.png','a_96.png'],
								['a_73.png','a_74.png','a_75.png','a_76.png','a_77.png','a_78.png','a_79.png', 'a_80.png','a_81.png','a_82.png','a_83.png','a_84.png'],
								['a_61.png','a_62.png','a_63.png','a_64.png','a_65.png','a_66.png','a_67.png', 'a_68.png','a_69.png','a_70.png','a_71.png','a_72.png'],
								['a_49.png','a_50.png','a_51.png','a_52.png','a_53.png','a_54.png','a_55.png', 'a_56.png','a_57.png','a_58.png','a_59.png','a_60.png'],
								['a_37.png','a_38.png','a_39.png','a_40.png','a_41.png','a_42.png','a_43.png', 'a_44.png','a_45.png','a_46.png','a_47.png','a_48.png'],
								['a_25.png','a_26.png','a_27.png','a_28.png','a_29.png','a_30.png','a_31.png', 'a_32.png','a_33.png','a_34.png','a_35.png','a_36.png'],
								['a_13.png','a_14.png','a_15.png','a_16.png','a_17.png','a_18.png','a_19.png', 'a_20.png','a_21.png','a_22.png','a_23.png','a_24.png'],
								['a_01.png','a_02.png','a_03.png','a_04.png','a_05.png','a_06.png','a_07.png', 'a_08.png','a_09.png','a_10.png','a_11.png','a_12.png']
							],
						additionalHeight = !!index ? 500 : 0,
						jump = !!index ? index : 0;	
						
						
						for(var ii = jump, jj = layerDeep ; ii < jj + jump; ii++ ){
							scope.staticGeometry.createEnviPoint( location, {
								background : true,
								scr : scope.path + source,
								indexRepeat : ii,
								layer : layers,
								range : 0,
								attach : 'staticWallOutterBottom',
								repeat : layers[ ii ],
								repeatX : 500,
								additionalHeight : ( !ii ? 0 : additionalHeight -= 500 )
							})
						}
						
					},
					createSVGBuffer : function( source, map, label, object ){
						
					   scope.svgCount.tot++;
					   
						scope.transport({
							url: source,
							type:'GET',
							requestHeader:{"Content-Type":"image/svg+xml"},
							callback:function( data ){
								var vertexSets = [];
								
								scope.svgCount.current++;
								
								var parser = new DOMParser(), 
								doc = parser.parseFromString( data, "image/svg+xml");
								
								vertexSets.push( scope.Svg.pathToVertices( doc.getElementsByTagName('path')[0] , 150) );
								
								
								var buffer = scope.Bodies.fromVertices( object.x , object.y, vertexSets, {
									isStatic: true
								}, true);
								
								buffer.verticesOrigin = vertexSets[0];
								 
								buffer.name = buffer.label = label;
								
								buffer.drawLine = new scope.drawLine( buffer, buffer.verticesOrigin, "LINE_LOOP", "buffer" );
								
								if( scope.activeMap['value'] === map ){
									scope.World.add( scope.engine.world, buffer )
								}
								
								scope.staticAllMap['value'][ map ].content.staticOriGroupSVG.push( buffer );
							}
						})
						
					},
					createSVGPathBuffer : function( source, location, label, parentLabel, additionalSize ){
						scope.transport({
							url: source,
							type:'GET',
							requestHeader:{"Content-Type":"image/svg+xml"},
							callback:function( data ){
								var parser = new DOMParser(), 
								doc = parser.parseFromString( data, "image/svg+xml");
								
								scope.staticGeometry.createSVGPathBuffer({
									drawLine : false,
									location : location,
									additionalSize : additionalSize,
									parentLabel : parentLabel,
									label : label,
									vertices : scope.Svg.pathToVertices( doc.getElementsByTagName('path')[0] , 150)
								})
							}
						})		
					},
					createSVGLineBuffer : function( source, location, label, position ){
						scope.transport({
							url: source,
							type:'GET',
							requestHeader:{"Content-Type":"image/svg+xml"},
							callback:function( data ){
								var parser = new DOMParser(), 
								doc = parser.parseFromString( data, "image/svg+xml");
								
								scope.staticGeometry.createSVGLineBuffer({
									location : location,
									position : position,
									label : label,
									vertices : scope.Svg.pathToVertices( doc.getElementsByTagName('path')[0] , 150)
								})
							}
						})		
					},
					createNPC : function( options ){
						var npc = scope.Bodies.rectangle( options.x , options.y , 60, 60, { 
							isStatic: true,
							render: {
								sprite: {
									texture: options.texture
								}
							}
						})
						
						npc.name = npc.label = options.label;
						npc.additionalBoundsValue = options.additionalBoundsValue;
						npc.additionalBoundsHeightValue = options.additionalBoundsHeightValue;
						npc.additionalBoundsWidthValue = options.additionalBoundsWidthValue;
						npc.behaveState = options.behaveState;
						npc.touch = options.touch;
						npc.isVisible = options.isVisible;
						npc.quest = {
							update : [],
							mapMark : new scope.draw.mapMark(),
							target : options.target
						};
						
						return npc;
					},
					createPoint : function( options ){
						var height = 1,
						width = 1,
						
						point = scope.Bodies.rectangle( options.x, options.y , height, width, { isStatic: true });
						point.name = point.label = options.label;
						point.src = options.texture;
						point.fixedBounds = !!options.fixedBounds && options.fixedBounds || 0;
						point.isVisible = 'undefined' === typeof options.isVisible && true || options.isVisible;
						point.quest = {
							update : [],
							mapMark : new scope.draw.mapMark(),
							target : options.target
						}
	 
						return point;
					},
					
				}
				

				scope.fragment = [
					function(){

						
						var spawnA = scope.Bodies.rectangle(500 /*1800*/, scope.halfBottom, 128, 25, { isStatic: true })
						spawnA.label = 'staticBoxPreventJumpSpawnA';
						spawnA.src = scope.path+'grass/grassHalf.png';

						var spawnB =  scope.Bodies.rectangle( 3100,  scope.halfBottom, 128,  25, { isStatic: true });
						spawnB.label = 'staticSpawnPhaseOneB';
						spawnB.src = scope.path+'grass/grassHalf.png';

						var smallBox = scope.Bodies.rectangle( 3300, scope.halfCenter, 256,  25, { isStatic: true })
						smallBox.label = 'staticBoxSmallB';
						smallBox.src = scope.path+'grass/staticBoxSmallB.png';

						var spawnC = scope.Bodies.rectangle( 3500, scope.halfTopCenter, 128,  25, { isStatic: true })
						spawnC.label = 'staticSpawnPhaseOneC';
						spawnC.src = scope.path+'grass/grassHalf.png';


						var	range = staticMediumWidth, distanceBoxJump = 3500, cntA = [];
						for(var ii = 0; ii < 3; ii++){

							distanceBoxJump += range

							if( ii === 1){

								var staticBoxPreventJumpMapAA = scope.Bodies.rectangle( distanceBoxJump , scope.halfTopTop, staticMediumWidth * 3,  50, { isStatic: true })
								staticBoxPreventJumpMapAA.label = 'staticBoxPreventJumpMapAA';
								staticBoxPreventJumpMapAA.src = scope.path+'grass/preventJumpA.png';
								distanceBoxJump += 100;
							}else if( ii === 2 ){

								var staticBoxDownA = scope.Bodies.rectangle( ( distanceBoxJump += range ) + staticMediumWidth * 2 - 75, scope.levelHeight, staticMediumWidth * 2 - 100,  50, { isStatic: true })
								staticBoxDownA.moveSate = true;
								staticBoxDownA.label = 'staticBoxPreventJumpUpDownA'
								staticBoxDownA.switchTo = 'up';
								staticBoxDownA.moveEnd = scope.halfTopTop;
								staticBoxDownA.moveStart = scope.levelHeight;
								staticBoxDownA.src = scope.path+'grass/rollUp.png'

								var staticBoxUpA = scope.Bodies.rectangle( distanceBoxJump +=  (range / 2 ) - (50 / 2)  , scope.halfCenter, staticMediumWidth, scope.levelHeight + 50, { isStatic: true })
								staticBoxUpA.label = 'staticBoxUpA'
								staticBoxUpA.src = scope.path+'grass/hill.png';

								var rollB = scope.Bodies.rectangle( distanceBoxJump += range * 2 + 50, scope.levelHeight - staticSmallWidth, staticSmallWidth,  50, { isStatic: true })
								rollB.label = 'staticBoxrollPairA'
								rollB.triggerTo = 'staticBoxPreventJumpUpDownA'
								rollB.switchState = true
								cntA.push( rollB )

								var temp = scope.Bodies.rectangle( distanceBoxJump, scope.halfTopTop +  scope.halfBottomLvl2 , 85,  50, { isStatic: true })
								temp.label = 'staticBoxLvlB3a'
								temp.src = scope.path+'grass/grassHalfSmall.png';
								cntA.push( temp )

								var temp = scope.Bodies.rectangle( distanceBoxJump - range, scope.halfCenterLvl2 , 85,  50, { isStatic: true })
								temp.label = 'staticBoxLvlB3b';
								temp.src = scope.path+'grass/grassHalfSmall.png';
								cntA.push( temp )

								var spawnG = scope.Bodies.rectangle( distanceBoxJump, scope.halfTopCenterLvl2, 85,  50, { isStatic: true })
								spawnG.label = 'staticBoxLvlB3c';
								spawnG.src = scope.path+'grass/grassHalfSmall.png';

								var spawnH = scope.Bodies.rectangle( distanceBoxJump - range * 3, scope.halfCenterLvl2 , staticMediumWidth,  50, { isStatic: true })
								spawnH.label = 'staticBoxLvlB3d';
								spawnH.src = scope.path+'grass/grassMed.png';

								var staticBoxPreventJumpMapAB6 = scope.Bodies.rectangle( distanceBoxJump += range + staticMediumWidth * 2 + 25, scope.halfTopTopLvl2, staticMediumWidth * 4 + 50,  50, { isStatic: true })
								staticBoxPreventJumpMapAB6.label = 'staticBoxPreventJumpMapAB6'
								staticBoxPreventJumpMapAB6.src = scope.path+'grass/grass850.png';
								
							}

						}


						var	range = staticMediumWidth, distanceBoxJumpEnd = 3500, distanceBoxJumpStart = (staticMediumWidth / 2), cntB = [];
						for(var ii = 0; ii < 21; ii++){
							if( ii === 5){
								var spawnF = scope.Bodies.rectangle( distanceBoxJumpEnd + ( range ) - 125 , scope.halfTopTop +  scope.halfBottomLvl2  / 2, 50,  scope.halfBottomLvl2 - 50, { isStatic: true })
								spawnF.label = 'staticBoxPreventJumpMapAB2';
								spawnF.src = scope.path+'grass/grassHill.png';

							}else if( ii > 3){

								if( ii === 16 ){
									var staticBoxPreventJumpMapAB3 = scope.Bodies.rectangle( ( distanceBoxJumpEnd + range  ) / 2, scope.halfBottomLvl2, staticMediumWidth * 13,  50, { isStatic: true })
									staticBoxPreventJumpMapAB3.label = 'staticBoxPreventJumpMapAB3';
									staticBoxPreventJumpMapAB3.src = scope.path+'grass/preventJumpC.png';
								}

								if( ii === 17 ){
									var temp = scope.Bodies.rectangle( distanceBoxJumpStart, scope.halfTopCenter, staticMediumWidth ,  50, { isStatic: true })
									temp.label = 'staticBoxPreventJumpMapAB4';
									temp.src = scope.path+'grass/grassMed.png';
									cntB.push( temp )
								}


								if( ii === 19 ){
									var spawnD = scope.Bodies.rectangle( distanceBoxJumpStart+= range * 4, scope.halfTopTop +  scope.halfBottomLvl2  / 2, 10 , 10 , { isStatic: true })
									spawnD.label = 'staticBoxPreventJump-'+ii;
								}

					
							}else{

								if( ii === 3 ){
									var staticBoxPreventJumpMapAB1 = scope.Bodies.rectangle( distanceBoxJumpEnd + range , scope.halfTopTop, staticMediumWidth * 3 ,  50, { isStatic: true })
									staticBoxPreventJumpMapAB1.label = 'staticBoxPreventJumpMapAB1';
									staticBoxPreventJumpMapAB1.src = scope.path+'grass/preventJumpB.png';
								}

								distanceBoxJumpEnd -= range
							}
						}

						//MapA Envi
						var range = 0,
						location = 'mapA';
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/grassSmallLeft.png',
							range : range += 400,
							attach : 'staticWallOutterBottom'
						})

						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/fence.png',
							range : range += 1200,
							attach : 'staticWallOutterBottom'
						})
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/grassSmallLeft.png',
							range : range += 100,
							attach : 'staticWallOutterBottom'
						})

						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/bush.png',
							range : range += 2300,
							attach : 'staticWallOutterBottom'
						})

						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/foliagePack.png',
							range : range += 1200,
							attach : 'staticWallOutterBottom'
						})
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/flwrC.png',
							range : range += 100,
							attach : 'staticWallOutterBottom'
						})

						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/grassSamllB.png',
							range : 150,
							attach : 'staticBoxSmallB'
						})

						var rangeB = 0;
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/foliagePack.png',
							range : rangeB += 130,
							attach : 'staticBoxPreventJumpMapAB1'
						})
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/mushroomRedSmall.png',
							range : rangeB += 40,
							attach : 'staticBoxPreventJumpMapAB1'
						})
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/grassSmallC.png',
							range : rangeB += 40,
							attach : 'staticBoxPreventJumpMapAB1'
						})

						var rangeC = 0;
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/fence.png',
							range : rangeC += 600,
							attach : 'staticBoxPreventJumpMapAB3'
						})

						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/tree-big.png',
							range : rangeC += 100,
							attach : 'staticBoxPreventJumpMapAB3'
						})
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/tree-small.png',
							range : rangeC += 150,
							attach : 'staticBoxPreventJumpMapAB3'
						})

						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/grassSmallE.png',
							range : rangeC += 750,
							attach : 'staticBoxPreventJumpMapAB3'
						})
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/grassSmallD.png',
							range : rangeC += 200,
							attach : 'staticBoxPreventJumpMapAB3'
						})

						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/grassSmallD.png',
							range : 50,
							attach : 'staticSpawnPhaseOneH'
						})

						var b = 0;
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/mushroomRedSmall.png',
							range : b += 150,
							attach : 'staticBoxPreventJumpMapAA'
						})

						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/mushroomRedMed.png',
							range : b += 50,
							attach : 'staticBoxPreventJumpMapAA'
						})
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/bush.png',
							range :50,
							attach : 'staticBoxUpA'
						})

						var c = 0;
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/bush.png',
							range : c += 50,
							attach : 'staticBoxPreventJumpMapAB6'
						})
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/stoneA.png',
							range : c += 50,
							attach : 'staticBoxPreventJumpMapAB6'
						})
						scope.staticGeometry.createEnviPoint( location, {
							src : scope.path+'ornaments/foliagePackB.png',
							range : c += 50,
							attach : 'staticBoxPreventJumpMapAB6'
						})
						
						//create portal
						var portalMapA = scope.staticGeometry.createPortal({
							width : staticMediumWidth,
							height : staticMediumWidth,
							range : 100,
							color : scope.rgbRandom( 1 ),
							effect : 'glowPortal',
							attach : 'staticBoxPreventJumpMapAB3',
							location : 'mapA',
							targetLocation : 'mapB'
						})
						
						
						var portalMapAA = scope.staticGeometry.createPortal({
							width : staticMediumWidth,
							height : staticMediumWidth,
							range : 500,
							color : scope.rgbRandom( 1 ),
							effect : 'glowPortal',
							attach : 'staticWallOutterBottom',//'staticBoxPreventJumpMapAB6',
							location : 'mapA',
							targetLocation : 'mapAADungeonA'
						})
						
						
						var portalMapATemp = scope.staticGeometry.createPortal({
							width : staticMediumWidth,
							height : staticMediumWidth,
							range : 700,
							attach : 'staticWallOutterBottom',
							color : scope.rgbRandom( 1 ),
							effect : 'glowPortal',
							location : 'mapA',
							targetLocation : 'mapDungeonH'
						})
						
						scope.staticAllMap['value'].mapA.content = {
							staticWallOuttermapA :  obj.createWall( location, "medium" ),
							staticSpawnPhaseOneA : spawnA,
							staticSpawnPhaseOneB : spawnB,
							staticSpawnPhaseOneC : spawnC,
							staticSpawnPhaseOneD :spawnD,
							staticSpawnPhaseOneG :spawnG,
							staticSpawnPhaseOneH :spawnH,
							

							staticOriPortalMapA : portalMapA,
							staticOriPortalMapAA : portalMapAA,
							staticOriPortalMapATemp : portalMapATemp,

							staticBoxSmallJumpC : cntA,
							staticBoxSmallJumpD : cntB,

							staticSpawnPhaseOneF :spawnF,
							staticBoxPreventJumpMapAB6 :staticBoxPreventJumpMapAB6,

							staticBoxPreventJumpMapAA : staticBoxPreventJumpMapAA,
							staticBoxPreventJumpMapAB1 : staticBoxPreventJumpMapAB1,
							staticBoxPreventJumpMapAB3 : staticBoxPreventJumpMapAB3,
							staticBoxPreventJumpUpDownA : staticBoxDownA,
							staticBoxUpA : staticBoxUpA,

							staticBoxSmallB : smallBox
						}
			
						return scope.staticAllMap['value'].mapA.content


					}(),
					//mapDungeon D
					function(){
						
						var location = 'mapDungeonD', url = scope.path+'ornaments/h/' , 
						bs = scope.browserHeightUpdate, layerSize = 3000, ySize = bs - layerSize;
						//background
						obj.createBackground( 6, 'ornaments/h/', location, 6 );
						
						//create mini Map 
						scope.staticGeometry.createMap({
							location : location,
							src : url + 'map.png'	
						})
						 
						var staticSpawnB = obj.createPoint({
							label : 'staticOriDngDPassStB',
							texture : scope.path+'1px.png',
							x : 1960,
							y : ySize + 1185,
							target : 'help'
						}); 
						
						var staticSpawnC = obj.createPoint({
							label : 'staticOriDngDPassStC',
							texture : scope.path+'1px.png',
							x : 3106,
							y : ySize + 2185,
							target : 'help'
						}); 
						 
						
						var staticSpawnD = obj.createPoint({
							label : 'staticOriDngDPassStD',
							texture : scope.path+'1px.png',
							x : 3790,
							y : ySize + 1183,
							target : 'help'
						}); 
						  
						 
						
						var pointSpawnA = obj.createPoint({
							label : 'staticOriDngDPassSpawnA',
							texture : scope.path+'1px.png',
							x : 355,
							y : ySize + 1482,
							target : 'help'
						});
						
						var pointSpawnB = obj.createPoint({
							label : 'staticOriDngDPassSpawnB',
							texture : scope.path+'1px.png',
							x : 750,
							y : ySize + 2719,
							target : 'help'
						});
						
						var pointSpawnC = obj.createPoint({
							label : 'staticOriDngDPassSpawnC',
							texture : scope.path+'1px.png',
							x : 5285,
							y : ySize + 2059,
							target : 'help'
						});
						
						var pointSpawnD = obj.createPoint({
							label : 'staticOriDngDPassSpawnD',
							texture : scope.path+'1px.png',
							x : 5285,
							y : ySize + 2059,
							target : 'help'
						});
						
						var pointSpawnE = obj.createPoint({
							label : 'staticOriDngDPassSpawnE',
							texture : scope.path+'1px.png',
							x : 5218,
							y : ySize + 1088,
							target : 'help'
						});
						
						//buffer
						obj.createSVGBuffer( url+'buffer-a.svg', location, 'staticOriDngDBufferA', { x : 2053, y :  ySize + 2705 })
						obj.createSVGPathBuffer( url+'path-buffer-a.svg', location, 'staticOriDngDPathBufferA', 'staticOriDngDBufferA', { x : 0, y :  -30 } )
						
						
						obj.createSVGBuffer( url+'buffer-b.svg', location, 'staticOriDngDBufferB', { x : 301, y :  ySize + 2245 })
						obj.createSVGBuffer( url+'buffer-c.svg', location, 'staticOriDngDBufferC', { x : 1007 , y :  ySize + 1438 })
						obj.createSVGBuffer( url+'buffer-d.svg', location, 'staticOriDngDBufferD', { x : 857 , y :  ySize + 375 })
						obj.createSVGBuffer( url+'buffer-e.svg', location, 'staticOriDngDBufferE', { x : 3488, y :  ySize + 435 })
						obj.createSVGBuffer( url+'buffer-f.svg', location, 'staticOriDngDBufferF', { x : 2408, y :  ySize + 1730 })
						obj.createSVGBuffer( url+'buffer-g.svg', location, 'staticOriDngDBufferG', { x : 3601, y :  ySize + 1320 })
						
						obj.createSVGBuffer( url+'buffer-h.svg', location, 'staticOriDngDBufferH', { x : 3780, y :  ySize + 2435 })
						obj.createSVGPathBuffer( url+'path-buffer-h.svg', location, 'staticOriDngDPathBufferH', 'staticOriDngDBufferH' )
						
						obj.createSVGBuffer( url+'buffer-i.svg', location, 'staticOriDngDBufferI', { x : 5257, y :  ySize + 2519 })
						
						obj.createSVGBuffer( url+'buffer-j.svg', location, 'staticOriDngDBufferJ', { x : 4850, y :  ySize + 1627 })
						obj.createSVGPathBuffer( url+'path-buffer-j.svg', location, 'staticOriDngDPathBufferJ', 'staticOriDngDBufferJ' )
						
						obj.createSVGBuffer( url+'buffer-k.svg', location, 'staticOriDngDBufferK', { x : 5319, y :  ySize + 540 })
						
						obj.createSVGPathBuffer( url+'path-buffer-b.svg', location, 'staticOriDngDPathBufferB', 'staticOriDngDBufferB', { x : 50, y :  0 } )
						obj.createSVGPathBuffer( url+'path-buffer-c.svg', location, 'staticOriDngDPathBufferC', 'staticOriDngDBufferC' )
						obj.createSVGPathBuffer( url+'path-buffer-d.svg', location, 'staticOriDngDPathBufferD', 'staticOriDngDBufferD' )
						obj.createSVGPathBuffer( url+'path-buffer-e.svg', location, 'staticOriDngDPathBufferE', 'staticOriDngDBufferE', { x : -10, y :  40 })
						obj.createSVGPathBuffer( url+'path-buffer-f.svg', location, 'staticOriDngDPathBufferF', 'staticOriDngDBufferF' )
						obj.createSVGPathBuffer( url+'path-buffer-g.svg', location, 'staticOriDngDPathBufferG', 'staticOriDngDBufferG' )
						obj.createSVGPathBuffer( url+'path-buffer-i.svg', location, 'staticOriDngDPathBufferI', 'staticOriDngDBufferI' )
						obj.createSVGPathBuffer( url+'path-buffer-k.svg', location, 'staticOriDngDPathBufferK', 'staticOriDngDBufferK', { x : 0, y :  -10 } )

						/*
						obj.createSVGLineBuffer( url+'path-a.svg', location, 'staticOriDngDLineBufferA', { x : 979 , y :  ySize + 2644 })
						obj.createSVGLineBuffer( url+'path-b.svg', location, 'staticOriDngDLineBufferB', { x : 657, y :  ySize + 1700  })
						obj.createSVGLineBuffer( url+'path-c.svg', location, 'staticOriDngDLineBufferC', { x : 2230, y :  ySize + 2207 })
						obj.createSVGLineBuffer( url+'path-d.svg', location, 'staticOriDngDLineBufferD', { x : 1687, y :  ySize + 1671 })
						obj.createSVGLineBuffer( url+'path-e.svg', location, 'staticOriDngDLineBufferE', { x : 1002, y :  ySize + 990 })
						obj.createSVGLineBuffer( url+'path-f.svg', location, 'staticOriDngDLineBufferF', { x : 2688, y :  ySize + 1196 })
						obj.createSVGLineBuffer( url+'path-g.svg', location, 'staticOriDngDLineBufferG', { x : 3157, y :  ySize + 1649 })
						obj.createSVGLineBuffer( url+'path-h.svg', location, 'staticOriDngDLineBufferH', { x : 4101, y :  ySize + 2708 })
						obj.createSVGLineBuffer( url+'path-i.svg', location, 'staticOriDngDLineBufferI', { x : 4631, y :  ySize + 2550 })
						obj.createSVGLineBuffer( url+'path-j.svg', location, 'staticOriDngDLineBufferJ', { x : 5288, y :  ySize + 2079 })
						obj.createSVGLineBuffer( url+'path-k.svg', location, 'staticOriDngDLineBufferK', { x : 4300, y :  ySize + 2098 })
						obj.createSVGLineBuffer( url+'path-l.svg', location, 'staticOriDngDLineBufferL', { x : 4201, y :  ySize + 1556 })
						obj.createSVGLineBuffer( url+'path-m.svg', location, 'staticOriDngDLineBufferM', { x : 4814, y :  ySize + 1071 })
						obj.createSVGLineBuffer( url+'path-n.svg', location, 'staticOriDngDLineBufferN', { x : 4605, y :  ySize + 651 })*/
						
						
						scope.staticAllMap['value'].mapDungeonD.content = {
							staticWallOuttermapDungeonD : obj.createWall( location, "medium" ),
							staticOriDngDPassSpawnA : pointSpawnA,
							staticOriDngDPassSpawnB : pointSpawnB, 
							staticOriDngDPassSpawnC : pointSpawnC, 
							staticOriDngDPassSpawnD : pointSpawnD, 
							staticOriDngDPassStB : staticSpawnB, 
							staticOriDngDPassStC : staticSpawnC, 
							staticOriDngDPassStD : staticSpawnD,  
							staticOriGroupSVG : [],
							staticSpawnLabel : [ "staticOriDngDPassSpawnA", "staticOriDngDPassSpawnB" , "staticOriDngDPassSpawnC" , "staticOriDngDPassSpawnD"  ],
							groupLayer : [
								obj.createLayer( 'staticOriDPassLayerA',
									{ x : 0, y : 0, location : location,  
										layer: function(){ 
										
										
										
											var spawnA = scope.Bodies.rectangle( 377, ySize + 1965, 202, 215, { isStatic: true });
												spawnA.src = url + 'hs-a.png';
												spawnA.fixedBounds = 0;
											
											var spawnB = scope.Bodies.rectangle( 502, ySize + 1735, 115, 95, { isStatic: true });
												spawnB.src = url + 'obs-a.png';
												
											var spawnC = scope.Bodies.rectangle( 860, ySize + 1200, 244, 343, { isStatic: true });
												spawnC.src = url + 'hs-keeper.png';
												spawnC.fixedBounds = 0;

											var spawnD = scope.Bodies.rectangle( 1258, ySize + 1386, 135, 209, { isStatic: true });
												spawnD.src = url + 'tre-a.png';
												
											var spawnE = scope.Bodies.rectangle( 389, ySize + 985, 83, 147, { isStatic: true });
												spawnE.src = url + 'obs-b.png';
												
											var spawnF = scope.Bodies.rectangle( 1777, ySize + 1875, 224, 117, { isStatic: true });
												spawnF.src = url + 'tre-b.png';
												spawnF.fixedBounds = -40;
												
											var spawnG = scope.Bodies.rectangle( 1286, ySize + 2898, 82, 104, { isStatic: true });
												spawnG.src = url + 'obs-c.png';
												
											var spawnH = scope.Bodies.rectangle( 1520, ySize + 2698, 55, 79, { isStatic: true });
												spawnH.src = url + 'obs-d.png';	
												
											var spawnI = scope.Bodies.rectangle( 2216, ySize + 2468, 225, 315, { isStatic: true });
												spawnI.src = url + 'hs-keeper-b.png';

											var spawnJ = scope.Bodies.rectangle( 2240, ySize + 1748, 90, 157, { isStatic: true });
												spawnJ.src = url + 'tre-c.png';
												
											var spawnK = scope.Bodies.rectangle( 2437, ySize + 1667, 156, 210, { isStatic: true });
												spawnK.src = url + 'hs-b.png';
												
											var spawnL = scope.Bodies.rectangle( 2774, ySize + 1497, 119, 208, { isStatic: true });
												spawnL.src = url + 'tre-d.png';
												
											
											var temp = [ spawnA, spawnB, spawnC, spawnD, spawnE, spawnF, spawnG, spawnH, spawnI, spawnJ, spawnK, spawnL ];
											
											for(var ii = 0, len = temp.length; ii < len ; ii++ ){
												temp[ii].name = temp[ii].label = 'staticOriDPass'+scope.uniqueId();
												temp[ii].FixedPosition = {
													x : temp[ii].position.x,
													y : temp[ii].position.y - bs
												}
												if( !temp[ii].fixedBounds ) temp[ii].fixedBounds = 25;
											}
											
											return temp
										}(),
									}),
									
								obj.createLayer( 'staticOriDPassLayerB',
									{ x : 3000, y : 0, location : location, 
										layer: function(){ 
											var spawnA = scope.Bodies.rectangle( 538, ySize + 1237, 118, 151, { isStatic: true });
												spawnA.src = url + 'tre-e.png';
											
											var spawnB = scope.Bodies.rectangle( 902, ySize + 986, 55, 78, { isStatic: true });
												spawnB.src = url + 'obs-e.png';
												
											var spawnC = scope.Bodies.rectangle( 1320, ySize + 846, 156, 210, { isStatic: true });
												spawnC.src = url + 'hs-c.png';

											var spawnD = scope.Bodies.rectangle( 1324, ySize + 1041, 119, 208, { isStatic: true });
												spawnD.src = url + 'tre-d.png';
												
											var spawnE = scope.Bodies.rectangle( 1194, ySize + 1058, 55, 78, { isStatic: true });
												spawnE.src = url + 'obs-f.png';
												
											var spawnF = scope.Bodies.rectangle( 550, ySize + 1749, 224, 117, { isStatic: true });
												spawnF.src = url + 'tre-b.png';
												spawnF.fixedBounds = -40;
												
											var spawnG = scope.Bodies.rectangle( 656, ySize + 2403, 186, 208, { isStatic: true });
												spawnG.src = url + 'tre-f.png';
												
											var spawnH = scope.Bodies.rectangle( 1219, ySize + 2383, 119, 208, { isStatic: true });
												spawnH.src = url + 'tre-d.png';	
												
											var spawnI = scope.Bodies.rectangle( 915, ySize + 2282, 225, 315, { isStatic: true });
												spawnI.src = url + 'hs-keeper-b.png';

											var spawnJ = scope.Bodies.rectangle( 2067, ySize + 2416, 224, 117, { isStatic: true });
												spawnJ.src = url + 'tre-b.png';
												spawnJ.fixedBounds = -40;
												
											var spawnK = scope.Bodies.rectangle( 2324, ySize + 2364, 156, 210, { isStatic: true });
												spawnK.src = url + 'hs-c.png';
												
											var spawnL = scope.Bodies.rectangle( 1484, ySize + 1684, 82, 104, { isStatic: true });
												spawnL.src = url + 'obs-c.png';
												
											var spawnM = scope.Bodies.rectangle( 1681, ySize + 1562, 224, 315, { isStatic: true });
												spawnM.src = url + 'hs-keeper-c.png';	
												
											var spawnN = scope.Bodies.rectangle( 2373, ySize + 1410, 225, 315, { isStatic: true });
												spawnN.src = url + 'hs-keeper-b.png';

											var spawnO = scope.Bodies.rectangle( 2109, ySize + 1087, 76, 71, { isStatic: true });
												spawnO.src = url + 'obs-g.png';
												
											var spawnP = scope.Bodies.rectangle( 2246, ySize + 296, 119, 208, { isStatic: true });
												spawnP.src = url + 'tre-d.png';
											
											var spawnQ = scope.Bodies.rectangle( 2581, ySize + 464, 156, 210, { isStatic: true });
												spawnQ.src = url + 'hs-c.png';
												
											var spawnR = scope.Bodies.rectangle( 2777, ySize + 550, 90, 157, { isStatic: true });
												spawnR.src = url + 'tre-c.png';
												
											var spawnS = scope.Bodies.rectangle( 199, ySize + 2199, 83, 147, { isStatic: true });
												spawnS.src = url + 'obs-b.png';	
												 
											var temp = [ spawnA, spawnB, spawnC, spawnD, spawnE, spawnF, spawnG, spawnH, spawnI, spawnJ, spawnK, spawnL, spawnM, spawnN, spawnO, spawnP, 
											spawnQ, spawnR, spawnS ]
											for(var ii = 0, len = temp.length; ii < len ; ii++ ){
												temp[ii].name = temp[ii].label = 'staticOriDPass'+scope.uniqueId();
												temp[ii].FixedPosition = {
													x : temp[ii].position.x,
													y : temp[ii].position.y - bs
												}
												if( !temp[ii].fixedBounds ) temp[ii].fixedBounds = 25;
											}
											
											return temp
										}(),
									})
								]
						}
						return scope.staticAllMap['value'].mapDungeonD.content
						
					}(),
					
					//mapDungeon F
					function(){
						var location = 'mapDungeonF', url = scope.path+'ornaments/j/' , 
						bs = scope.browserHeightUpdate, layerSize = 3000, ySize = bs - layerSize;
						 
						//background
						obj.createBackground( 6, '/ornaments/j/', location, 6 );
					 
						//create mini Map 
						scope.staticGeometry.createMap({
							location : location,
							src : url + 'map.png'	
						})
						
						var staticSpawnA = obj.createPoint({
							label : 'staticOriDngFPassStA',
							texture : scope.path+'1px.png',
							x : 1673,
							y : ySize + 1548,
							target : 'help'
						}); 
						
						var staticSpawnB = obj.createPoint({
							label : 'staticOriDngFPassStB',
							texture : scope.path+'1px.png',
							x : 3543,
							y : ySize + 1815,
							target : 'help'
						}); 
					   
	 
						var pointSpawnA = obj.createPoint({
							label : 'staticOriDngFPassSpawnA',
							texture : scope.path+'1px.png',
							x : 5362,
							y : ySize + 628,
							target : 'help'
						}); 
						
						var pointSpawnB = obj.createPoint({
							label : 'staticOriDngFPassSpawnB',
							texture : scope.path+'1px.png',
							x : 5319,
							y : ySize + 2454,
							target : 'help'
						}); 
						
						var pointSpawnC = obj.createPoint({
							label : 'staticOriDngFPassSpawnC',
							texture : scope.path+'1px.png',
							x : 2971,
							y : ySize + 1973,
							target : 'help'
						}); 
						
						var pointSpawnD = obj.createPoint({
							label : 'staticOriDngFPassSpawnD',
							texture : scope.path+'1px.png',
							x : 562,
							y : ySize + 2562,
							target : 'help'
						}); 
						
						obj.createSVGBuffer( url+'buffer-a.svg', location, 'staticOriDngFBufferA', { x : 438, y :  ySize + 1058 })
						obj.createSVGPathBuffer( url+'path-buffer-a.svg', location, 'staticOriDngFPathBufferA', 'staticOriDngFBufferA', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-b.svg', location, 'staticOriDngFBufferB', { x : 1030, y :  ySize + 954 })
						obj.createSVGPathBuffer( url+'path-buffer-b.svg', location, 'staticOriDngFPathBufferB', 'staticOriDngFBufferB', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-c.svg', location, 'staticOriDngFBufferC', { x : 1400, y :  ySize + 1150 })
						obj.createSVGPathBuffer( url+'path-buffer-c.svg', location, 'staticOriDngFPathBufferC', 'staticOriDngFBufferC', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-d.svg', location, 'staticOriDngFBufferD', { x : 1288, y :  ySize + 2072 })
						obj.createSVGPathBuffer( url+'path-buffer-d.svg', location, 'staticOriDngFPathBufferD', 'staticOriDngFBufferD', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-e.svg', location, 'staticOriDngFBufferE', { x : 2327, y :  ySize + 974 })
						obj.createSVGPathBuffer( url+'path-buffer-e.svg', location, 'staticOriDngFPathBufferE', 'staticOriDngFBufferE', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-f.svg', location, 'staticOriDngFBufferF', { x : 2203, y :  ySize + 401 })
						obj.createSVGPathBuffer( url+'path-buffer-f.svg', location, 'staticOriDngFPathBufferF', 'staticOriDngFBufferF', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-g.svg', location, 'staticOriDngFBufferG', { x : 3123, y :  ySize + 958 })
						obj.createSVGPathBuffer( url+'path-buffer-g.svg', location, 'staticOriDngFPathBufferG', 'staticOriDngFBufferG', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-h.svg', location, 'staticOriDngFBufferH', { x : 3796, y :  ySize + 964 })
						obj.createSVGPathBuffer( url+'path-buffer-h.svg', location, 'staticOriDngFPathBufferH', 'staticOriDngFBufferH', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-i.svg', location, 'staticOriDngFBufferI', { x : 2850, y :  ySize + 1627 })
						obj.createSVGPathBuffer( url+'path-buffer-i.svg', location, 'staticOriDngFPathBufferI', 'staticOriDngFBufferI', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-j.svg', location, 'staticOriDngFBufferJ', { x : 2716, y :  ySize + 2305 })
						obj.createSVGPathBuffer( url+'path-buffer-j.svg', location, 'staticOriDngFPathBufferJ', 'staticOriDngFBufferJ', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-k.svg', location, 'staticOriDngFBufferK', { x : 3252, y :  ySize + 2378 })
						obj.createSVGPathBuffer( url+'path-buffer-k.svg', location, 'staticOriDngFPathBufferK', 'staticOriDngFBufferK', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-l.svg', location, 'staticOriDngFBufferL', { x : 4065, y :  ySize + 2160 })
						obj.createSVGPathBuffer( url+'path-buffer-l.svg', location, 'staticOriDngFPathBufferL', 'staticOriDngFBufferL', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-m.svg', location, 'staticOriDngFBufferM', { x : 4685, y :  ySize + 2160 })
						obj.createSVGPathBuffer( url+'path-buffer-m.svg', location, 'staticOriDngFPathBufferM', 'staticOriDngFBufferM', { x : 5, y :  -5 } )
						
						obj.createSVGBuffer( url+'buffer-n.svg', location, 'staticOriDngFBufferN', { x : 4411, y :  ySize + 1517 })
						obj.createSVGPathBuffer( url+'path-buffer-n.svg', location, 'staticOriDngFPathBufferN', 'staticOriDngFBufferN', { x : 0, y :  5 } )
						
						obj.createSVGBuffer( url+'buffer-o.svg', location, 'staticOriDngFBufferO', { x : 4821, y :  ySize + 1158 })
						obj.createSVGPathBuffer( url+'path-buffer-o.svg', location, 'staticOriDngFPathBufferO', 'staticOriDngFBufferO', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-p.svg', location, 'staticOriDngFBufferP', { x : 5047, y :  ySize + 1025 })
						obj.createSVGPathBuffer( url+'path-buffer-p.svg', location, 'staticOriDngFPathBufferP', 'staticOriDngFBufferP', { x : 0, y :  -4 } )
						
						obj.createSVGBuffer( url+'buffer-q.svg', location, 'staticOriDngFBufferQ', { x : 4554, y :  ySize + 301 })
						obj.createSVGPathBuffer( url+'path-buffer-q.svg', location, 'staticOriDngFPathBufferQ', 'staticOriDngFBufferQ', { x : 0, y :  -4 } )
						
						obj.createSVGBuffer( url+'buffer-r.svg', location, 'staticOriDngFBufferR', { x : 3778, y :  ySize + 413 })
						obj.createSVGPathBuffer( url+'path-buffer-r.svg', location, 'staticOriDngFPathBufferR', 'staticOriDngFBufferR', { x : 0, y :  5 } )
						
						// svgBuffer
						scope.staticAllMap['value'].mapDungeonF.content = {
							staticWallOuttermapDungeonF : obj.createWall( location, "medium" ),  
							staticOriDngFPassStA : staticSpawnA,
							staticOriDngFPassStB : staticSpawnB,  
							staticOriDngFPassSpawnA : pointSpawnA,
							staticOriDngFPassSpawnB : pointSpawnB,
							staticOriDngFPassSpawnC : pointSpawnC,
							staticOriDngFPassSpawnD : pointSpawnD,
							staticSpawnLabel : [ "staticOriDngFPassSpawnA", "staticOriDngFPassSpawnB", "staticOriDngFPassSpawnD" ],
							staticOriGroupSVG : [],
							groupLayer : [
								obj.createLayer( 'staticOriFPassLayerA',
									{ x : 0, y : 0, location : location,  
										layer: function(){ 
											var spawnA = scope.Bodies.rectangle( 515, bs - layerSize + 2084, 157, 277, { isStatic: true });
												spawnA.src = url + 'treeA.png';
											
											var spawnB = scope.Bodies.rectangle( 1334, bs - layerSize + 2617, 121, 215, { isStatic: true });
												spawnB.src = url + 'treeC.png';
												
											var spawnC = scope.Bodies.rectangle( 1408, bs - layerSize + 2543, 120, 217, { isStatic: true });
												spawnC.src = url + 'treeD.png';

											var spawnD = scope.Bodies.rectangle( 2096, bs - layerSize + 2407, 138, 224, { isStatic: true });
												spawnD.src = url + 'treeB.png';
												
											var spawnE = scope.Bodies.rectangle( 2844, bs - layerSize + 2584, 159, 278, { isStatic: true });
												spawnE.src = url + 'treeE.png';
												
											var spawnF = scope.Bodies.rectangle( 2659, bs - layerSize + 2339, 121, 215, { isStatic: true });
												spawnF.src = url + 'treeC.png';
												
											var spawnG = scope.Bodies.rectangle( 2736, bs - layerSize + 2257, 159, 282, { isStatic: true });
												spawnG.src = url + 'treeF.png';
												
											var spawnH = scope.Bodies.rectangle( 2837, bs - layerSize + 2202, 159, 282, { isStatic: true });
												spawnH.src = url + 'treeF.png';	
											
											var spawnHA = scope.Bodies.rectangle( 2599, bs - layerSize + 1870, 109, 119, { isStatic: true });
												spawnHA.src = url + 'bfA.png';
												spawnHA.fixedBounds = 25;
											
											var spawnI = scope.Bodies.rectangle( 2784, bs - layerSize + 1608, 205, 270, { isStatic: true });
												spawnI.src = url + 'houseA.png';
												spawnI.fixedBounds = 45;

											var spawnJ = scope.Bodies.rectangle( 2911, bs - layerSize + 1582, 110, 121, { isStatic: true });
												spawnJ.src = url + 'bfC.png';
												spawnJ.fixedBounds = 25;
												
											var spawnK = scope.Bodies.rectangle( 2313, bs - layerSize + 1556, 159, 278, { isStatic: true });
												spawnK.src = url + 'treeE.png';
												
											var spawnL = scope.Bodies.rectangle( 1112, bs - layerSize + 1711, 138, 224, { isStatic: true });
												spawnL.src = url + 'treeB.png';
												
											var spawnM = scope.Bodies.rectangle( 1487, bs - layerSize + 1969, 282, 289, { isStatic: true });
												spawnM.src = url + 'houseB.png';
												spawnM.fixedBounds = 45;	
												
											var spawnN = scope.Bodies.rectangle( 1278, bs - layerSize + 2075, 101, 115, { isStatic: true });
												spawnN.src = url + 'bfB.png';
												spawnN.fixedBounds = 25;

											var spawnO = scope.Bodies.rectangle( 1243, bs - layerSize + 2169, 109, 119, { isStatic: true });
												spawnO.src = url + 'bfA.png';
												spawnO.fixedBounds = 25;
												
											var spawnP = scope.Bodies.rectangle( 1799, bs - layerSize + 2296, 101, 115, { isStatic: true });
												spawnP.src = url + 'bfB.png';
												spawnP.fixedBounds = 25;
												
											var spawnQ = scope.Bodies.rectangle( 2025, bs - layerSize + 2147, 110, 121, { isStatic: true });
												spawnQ.src = url + 'bfC.png';
												spawnP.fixedBounds = 25;
												
											var spawnR = scope.Bodies.rectangle( 1731, bs - layerSize + 1885, 109, 119, { isStatic: true });
												spawnR.src = url + 'bfA.png';
												
											
										
											var spawnS = scope.Bodies.rectangle( 400, bs - layerSize + 1088, 159, 278, { isStatic: true });
												spawnS.src = url + 'treeE.png';
												
											var spawnT = scope.Bodies.rectangle( 499, bs - layerSize + 1031, 109, 119, { isStatic: true });
												spawnT.src = url + 'bfA.png';
												spawnT.fixedBounds = 25;
												
											var spawnU = scope.Bodies.rectangle( 534, bs - layerSize + 937, 101, 115, { isStatic: true });
												spawnU.src = url + 'bfB.png';
												spawnU.fixedBounds = 25;
												
											var spawnV = scope.Bodies.rectangle( 1030, bs - layerSize + 853, 282, 289, { isStatic: true });
												spawnV.src = url + 'houseC.png';
												spawnV.fixedBounds = 45;
												
											var spawnW = scope.Bodies.rectangle( 1283, bs - layerSize + 1100, 110, 121, { isStatic: true });
												spawnW.src = url + 'bfC.png';
												spawnW.fixedBounds = 25;
												
											var spawnX = scope.Bodies.rectangle( 1411, bs - layerSize + 1078, 188, 332, { isStatic: true });
												spawnX.src = url + 'treeG.png';
												
											var spawnY = scope.Bodies.rectangle( 1503, bs - layerSize + 1138, 138, 224, { isStatic: true });
												spawnY.src = url + 'treeB.png';
												
											var spawnZ = scope.Bodies.rectangle( 1619 , bs - layerSize + 1120, 109, 119, { isStatic: true });
												spawnZ.src = url + 'bfA.png';
												spawnZ.fixedBounds = 25;
												
											var spawnAA = scope.Bodies.rectangle( 1889, bs - layerSize + 1287, 109, 119, { isStatic: true });
												spawnAA.src = url + 'bfA.png';
												spawnAA.fixedBounds = 25;
												
											var spawnAB = scope.Bodies.rectangle( 2465, bs - layerSize + 1153, 110, 121, { isStatic: true });
												spawnAB.src = url + 'bfC.png';
												spawnAB.fixedBounds = 25;
												
											var spawnAC = scope.Bodies.rectangle( 2763, bs - layerSize + 1276, 109, 119, { isStatic: true });
												spawnAC.src = url + 'bfA.png';
												spawnAC.fixedBounds = 25;
												
											var spawnAD = scope.Bodies.rectangle( 2895, bs - layerSize + 918, 110, 121, { isStatic: true });
												spawnAD.src = url + 'bfC.png';
												spawnAD.fixedBounds = 25;
												
											var spawnAE = scope.Bodies.rectangle( 2651, bs - layerSize + 1041, 110, 121, { isStatic: true });
												spawnAE.src = url + 'bfC.png';
												spawnAE.fixedBounds = 25;
												
											var spawnAF = scope.Bodies.rectangle( 2569, bs - layerSize + 914, 159, 278, { isStatic: true });
												spawnAF.src = url + 'treeE.png';
												
											var spawnAG = scope.Bodies.rectangle( 2428, bs - layerSize + 874, 109, 119, { isStatic: true });
												spawnAG.src = url + 'bfA.png';
												spawnAG.fixedBounds = 25;
													
											var spawnAH = scope.Bodies.rectangle( 2157, bs - layerSize + 763, 290, 329, { isStatic: true });
												spawnAH.src = url + 'houseD.png';
												spawnAH.fixedBounds = 55;
												
											var spawnAI = scope.Bodies.rectangle( 1864, bs - layerSize + 894, 110, 121, { isStatic: true });
												spawnAI.src = url + 'bfC.png';
												spawnAI.fixedBounds = 25;
												
											var spawnAJ = scope.Bodies.rectangle( 2371, bs - layerSize + 387, 159, 278, { isStatic: true });
												spawnAJ.src = url + 'treeE.png';
												
											var spawnAK = scope.Bodies.rectangle( 2301, bs - layerSize + 264, 159, 278, { isStatic: true });
												spawnAK.src = url + 'treeE.png';
												
											var spawnAL = scope.Bodies.rectangle( 2175, bs - layerSize + 300, 192, 332, { isStatic: true });
												spawnAL.src = url + 'treeH.png';
												
											var spawnAM = scope.Bodies.rectangle( 757, bs - layerSize + 345, 159, 278, { isStatic: true });
												spawnAM.src = url + 'treeE.png';	
											
											var temp = [ spawnA, spawnB, spawnC, spawnD, spawnE, spawnF, spawnG, spawnH, spawnHA, spawnI, spawnJ, spawnK, spawnL, spawnM, spawnN, spawnO, spawnP, 
											spawnQ, spawnR, spawnS, spawnT, spawnU, spawnV, spawnW, spawnX, spawnY, spawnZ, spawnAA, spawnAB, spawnAC, spawnAD, spawnAE,spawnAF, spawnAG,
											spawnAH, spawnAI, spawnAJ, spawnAK, spawnAL, spawnAM ];
											
											for(var ii = 0, len = temp.length; ii < len ; ii++ ){
												temp[ii].name = temp[ii].label = 'staticOriEPass'+scope.uniqueId();
												temp[ii].FixedPosition = {
													x : temp[ii].position.x,
													y : temp[ii].position.y - bs
												}
												if( !temp[ii].fixedBounds ) temp[ii].fixedBounds = 5;
											}
											
											return temp
										}() 
									}),
								obj.createLayer( 'staticOriFPassLayerB',  
									{ x : 3000, y : 0, location : location,  
										layer:  function(){ 
											var spawnA = scope.Bodies.rectangle( 95, bs - 1426, 109, 119, { isStatic: true });
												spawnA.src = url + 'bfA.png';
												spawnA.fixedBounds = 25;
											
											var spawnB = scope.Bodies.rectangle( 155, bs - 1196, 110, 121, { isStatic: true });
												spawnB.src = url + 'bfC.png';
												spawnB.fixedBounds = 25;
												
											var spawnC = scope.Bodies.rectangle( 257, bs - 702, 121, 215, { isStatic: true });
												spawnC.src = url + 'treeC.png';

											var spawnD = scope.Bodies.rectangle( 336, bs - 658, 121, 215, { isStatic: true });
												spawnD.src = url + 'treeC.png';
												
											var spawnE = scope.Bodies.rectangle( 1008, bs - 538, 157, 277, { isStatic: true });
												spawnE.src = url + 'treeA.png';
												
											var spawnF = scope.Bodies.rectangle( 1696, bs - 402, 121, 215, { isStatic: true });
												spawnF.src = url + 'treeC.png';
												
											var spawnG = scope.Bodies.rectangle( 1770, bs - 328, 120, 217, { isStatic: true });
												spawnG.src = url + 'treeD.png';
												
											var spawnH = scope.Bodies.rectangle( 2589, bs - 861, 157, 277, { isStatic: true });
												spawnH.src = url + 'treeI.png';	
												
											var spawnI = scope.Bodies.rectangle( 1992, bs - 1234, 138, 244, { isStatic: true });
												spawnI.src = url + 'treeJ.png';

											var spawnJ = scope.Bodies.rectangle( 1456, bs - 1601, 192, 332, { isStatic: true });
												spawnJ.src = url + 'treeH.png';
												
											var spawnK = scope.Bodies.rectangle( 1364, bs - 1541, 138, 244, { isStatic: true });
												spawnK.src = url + 'treeJ.png';
												
											var spawnL = scope.Bodies.rectangle( 791, bs - 1389, 159, 278, { isStatic: true });
												spawnL.src = url + 'treeE.png';
												
											var spawnM = scope.Bodies.rectangle( 1115, bs - 908, 110, 121, { isStatic: true });
												spawnM.src = url + 'bfC.png';
												spawnM.fixedBounds = 25;	
												
											var spawnN = scope.Bodies.rectangle( 1090, bs - 816, 109, 119, { isStatic: true });
												spawnN.src = url + 'bfA.png';
												spawnN.fixedBounds = 25;	

											var spawnO = scope.Bodies.rectangle( 1398, bs - 608, 109, 119, { isStatic: true });
												spawnO.src = url + 'bfA.png';
												spawnO.fixedBounds = 25;	
												
											var spawnP = scope.Bodies.rectangle( 1885, bs -  743, 110, 121, { isStatic: true });
												spawnP.src = url + 'bfC.png';
												spawnP.fixedBounds = 25;	
											
											var spawnQ = scope.Bodies.rectangle( 1843, bs - 835, 101, 115, { isStatic: true });
												spawnQ.src = url + 'bfD.png';
												spawnQ.fixedBounds = 25;
												
											var spawnR = scope.Bodies.rectangle( 1617, bs - 976, 282, 289, { isStatic: true });
												spawnR.src = url + 'houseC.png';
												spawnR.fixedBounds = 45;
											
											
											var spawnS = scope.Bodies.rectangle( 126, bs - 2079, 205, 270, { isStatic: true });
												spawnS.src = url + 'houseF.png';
												spawnS.fixedBounds = 45;
												
											var spawnT = scope.Bodies.rectangle( 256, bs - 2062, 109, 119, { isStatic: true });
												spawnT.src = url + 'bfA.png';
												spawnT.fixedBounds = 25;
												
											var spawnU = scope.Bodies.rectangle( 241, bs - 1738,110, 121, { isStatic: true });
												spawnU.src = url + 'bfC.png';
												spawnU.fixedBounds = 25;
											
											var spawnV = scope.Bodies.rectangle( 639, bs - 1792, 109, 119, { isStatic: true });
												spawnV.src = url + 'bfA.png';
												spawnV.fixedBounds = 25;
												
											var spawnW = scope.Bodies.rectangle( 1205, bs - 1762, 110, 121, { isStatic: true });
												spawnW.src = url + 'bfC.png';
												spawnW.fixedBounds = 25;
												
											var spawnX = scope.Bodies.rectangle( 1843, bs - 1817, 110, 121, { isStatic: true });
												spawnX.src = url + 'bfC.png';
												spawnX.fixedBounds = 25;
												
											var spawnY = scope.Bodies.rectangle( 2704, bs - 1857, 159, 278, { isStatic: true });
												spawnY.src = url + 'treeE.png';
												
											var spawnZ = scope.Bodies.rectangle( 2519, bs - 2050, 101, 115, { isStatic: true });
												spawnZ.src = url + 'bfD.png';
												spawnZ.fixedBounds = 25;
												
											var spawnAA = scope.Bodies.rectangle( 2347, bs - 2600, 159, 278, { isStatic: true });
												spawnAA.src = url + 'treeE.png';
												
											var spawnAB = scope.Bodies.rectangle( 1703, bs - 2787, 188, 332, { isStatic: true });
												spawnAB.src = url + 'treeG.png';
												
											var spawnAC = scope.Bodies.rectangle( 1577, bs - 2823, 159, 278, { isStatic: true });
												spawnAC.src = url + 'treeE.png';
												
											var spawnAD = scope.Bodies.rectangle( 1507, bs - 2700, 159, 278, { isStatic: true });
												spawnAD.src = url + 'treeE.png';
												
											var spawnAE = scope.Bodies.rectangle( 815, bs - 2708, 192, 332, { isStatic: true });
												spawnAE.src = url + 'treeH.png';
												
											var spawnAF = scope.Bodies.rectangle( 723, bs - 2648, 134, 224, { isStatic: true });
												spawnAF.src = url + 'treeJ.png';
												
											var spawnAG = scope.Bodies.rectangle( 117, bs - 2480, 159, 278, { isStatic: true });
												spawnAG.src = url + 'treeE.png';
													
											var spawnAH = scope.Bodies.rectangle( 535, bs - 2031, 159, 278, { isStatic: true });
												spawnAH.src = url + 'treeE.png';
												
											var spawnAI = scope.Bodies.rectangle( 676, bs - 2071, 110, 121, { isStatic: true });
												spawnAI.src = url + 'bfC.png';
												spawnAI.fixedBounds = 25;
												
											var spawnAJ = scope.Bodies.rectangle( 947, bs - 2182, 290, 329, { isStatic: true });
												spawnAJ.src = url + 'houseG.png';
												spawnAJ.fixedBounds = 55;
												
											var spawnAK = scope.Bodies.rectangle( 1153, bs - 2137, 110, 121, { isStatic: true });
												spawnAK.src = url + 'bfC.png';
												spawnAK.fixedBounds = 25;
												
											var spawnAL = scope.Bodies.rectangle( 1294, bs - 2122, 101, 115, { isStatic: true });
												spawnAL.src = url + 'bfD.png';
												spawnAL.fixedBounds = 25;
											
											var spawnAM = scope.Bodies.rectangle( 1874, bs - 1889, 109, 119, { isStatic: true });
												spawnAM.src = url + 'bfA.png';
												spawnAM.fixedBounds = 25;
												
											var spawnAN = scope.Bodies.rectangle( 2074, bs - 2092, 282, 289, { isStatic: true });
												spawnAN.src = url + 'houseB.png';
												spawnAN.fixedBounds = 45;
											
											var temp = [ spawnA, spawnB, spawnC, spawnD, spawnE, spawnF, spawnG, spawnH, spawnI, spawnJ, spawnK, spawnL, spawnM, spawnN, spawnO, spawnP, 
											spawnQ, spawnR, spawnS , spawnT, spawnU, spawnV, spawnW, spawnX, spawnY, spawnZ, spawnAA, spawnAB, spawnAC, spawnAD, spawnAE,spawnAF, spawnAG,
											spawnAH, spawnAI, spawnAJ, spawnAK, spawnAL, spawnAM, spawnAN ];
											
											for(var ii = 0, len = temp.length; ii < len ; ii++ ){
												temp[ii].name = temp[ii].label = 'staticOriFPass'+scope.uniqueId();
												temp[ii].FixedPosition = {
													x : temp[ii].position.x,
													y : temp[ii].position.y - bs
												}
												if( !temp[ii].fixedBounds ) temp[ii].fixedBounds = 5;
											}
											
											return temp
										}()
									})
							]
						}
					
						return scope.staticAllMap['value'].mapDungeonF.content
						
						
					}(),
					
					
					//mapDungeon G
					function(){
						var location = 'mapDungeonG', url = scope.path+'ornaments/k/', 
						bs = scope.browserHeightUpdate, layerSize = 3000, ySize = bs - layerSize, actualYSize = bs - layerSize * 2 ;
						
						
						var staticSpawnA = obj.createPoint({
							label : 'staticOriDngGPassStA',
							texture : scope.path+'1px.png',
							x : 1026,
							y : actualYSize + 4451,
							target : 'help'
						}); 
						 
						var pointSpawnA = obj.createPoint({
							label : 'staticOriDngGPassSpawnA',
							texture : scope.path+'1px.png',
							x : 694,
							y : actualYSize + 5510,
							target : 'help'
						}); 
						 
						var pointSpawnB = obj.createPoint({
							label : 'staticOriDngGPassSpawnB',
							texture : scope.path+'1px.png',
							x : 2541,
							y : actualYSize + 5603,
							target : 'help'
						}); 
						
						 
						var pointSpawnC = obj.createPoint({
							label : 'staticOriDngGPassSpawnB',
							texture : scope.path+'1px.png',
							x : 2490,
							y : actualYSize + 3965,
							target : 'help'
						}); 
						/*
						var pointSpawnB = obj.createPoint({
							label : 'staticOriDngGPassSpawnB',
							texture : scope.path+'1px.png',
							x : 5192,
							y : actualYSize + 5395,
							target : 'help'
						});
						
						var pointSpawnC = obj.createPoint({
							label : 'staticOriDngGPassSpawnC',
							texture : scope.path+'1px.png',
							x : 5228,
							y : actualYSize + 543,
							target : 'help'
						});
						
						var pointSpawnD = obj.createPoint({
							label : 'staticOriDngGPassSpawnD',
							texture : scope.path+'1px.png',
							x : 761,
							y : actualYSize + 544,
							target : 'help'
						});
						
						*/
						
						obj.createSVGBuffer( url+'buffer-a.svg', location, 'staticOriDngGBufferA', { x : 306, y :  actualYSize + 4975 })
						obj.createSVGPathBuffer( url+'path-buffer-a.svg', location, 'staticOriDngGPathBufferA', 'staticOriDngGBufferA', { x : 10, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-b.svg', location, 'staticOriDngGBufferB', { x : 1215, y :  actualYSize + 4955 })
						obj.createSVGPathBuffer( url+'path-buffer-b.svg', location, 'staticOriDngGPathBufferB', 'staticOriDngGBufferB', { x : -10, y :  10 } )
						 
						obj.createSVGBuffer( url+'buffer-c.svg', location, 'staticOriDngGBufferC', { x : 1760, y :  actualYSize + 5335 })
						obj.createSVGPathBuffer( url+'path-buffer-c.svg', location, 'staticOriDngGPathBufferC', 'staticOriDngGBufferC', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-d.svg', location, 'staticOriDngGBufferD', { x : 333, y :  actualYSize + 5426 })
						obj.createSVGPathBuffer( url+'path-buffer-d.svg', location, 'staticOriDngGPathBufferD', 'staticOriDngGBufferD', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-e.svg', location, 'staticOriDngGBufferE', { x : 625, y :  actualYSize + 3057 })
						obj.createSVGPathBuffer( url+'path-buffer-e.svg', location, 'staticOriDngGPathBufferE', 'staticOriDngGBufferE', { x : 0, y :  0 } )
						  
						obj.createSVGBuffer( url+'buffer-h.svg', location, 'staticOriDngGBufferH', { x : 2919, y :  actualYSize + 4625 })
						obj.createSVGPathBuffer( url+'path-buffer-h.svg', location, 'staticOriDngGPathBufferH', 'staticOriDngGBufferH', { x : 0, y :  0 } )
						 
						
						//background
						obj.createBackground( 6, '/ornaments/k/', location );
						
						//create mini Map 
						scope.staticGeometry.createMap({
							location : location,
							src : url + 'map.png'	
						})
						
						scope.staticAllMap['value'].mapDungeonG.content = {
							staticWallOuttermapDungeonG : obj.createWall( location, 'small' ),
							staticOriDngGPassStA : staticSpawnA,
							staticOriDngGPassSpawnA : pointSpawnA,
							staticOriDngGPassSpawnB : pointSpawnB,
							staticOriDngGPassSpawnC : pointSpawnC,
							staticOriGroupSVG : [],
							staticSpawnLabel : [ "staticOriDngGPassSpawnA", "staticOriDngGPassSpawnB" , "staticOriDngGPassSpawnC" ],
							groupLayer : [
								obj.createLayer( 'staticOriGPassLayerA',
									{ x : 0, y : 0, location : location,  
										layer: function(){
											var spawnA = scope.Bodies.rectangle( 92, bs - layerSize * 2 + 5263, 139, 224, { isStatic: true });
												spawnA.src = url + 'treeA.png';
											
											var spawnB = scope.Bodies.rectangle( 110, bs - layerSize* 2 + 5084, 192, 333, { isStatic: true });
												spawnB.src = url + 'treeB.png';
												
											var spawnC = scope.Bodies.rectangle( 132, bs - layerSize * 2 + 5000, 192, 333, { isStatic: true });
												spawnC.src = url + 'treeB.png';

											var spawnD = scope.Bodies.rectangle( 224, bs - layerSize * 2 + 5057, 141, 264, { isStatic: true });
												spawnD.src = url + 'treeC.png';
												
											var spawnE = scope.Bodies.rectangle( 343, bs - layerSize * 2 + 5063, 51, 127, { isStatic: true });
												spawnE.src = url + 'stoneE.png';
											
											var spawnF = scope.Bodies.rectangle( 256, bs - layerSize * 2 + 5789, 148, 198, { isStatic: true });
												spawnF.src = url + 'stoneA.png';
												spawnF.fixedBounds = 45
												
											var spawnG = scope.Bodies.rectangle( 383, bs - layerSize * 2 +  5319, 336, 337, { isStatic: true });
												spawnG.src = url + 'stoneC.png';
												spawnG.fixedBounds = 45
												
											var spawnH = scope.Bodies.rectangle( 587, bs - layerSize * 2 + 5066, 91, 125, { isStatic: true });
												spawnH.src = url + 'sign.png';	
											
											var spawnHA = scope.Bodies.rectangle( 876, bs - layerSize * 2 + 5190, 170, 207, { isStatic: true });
												spawnHA.src = url + 'stoneD.png';
											
											var spawnI = scope.Bodies.rectangle( 1317, bs - layerSize * 2 +  5575, 192, 332, { isStatic: true });
												spawnI.src = url + 'treeD.png';

											var spawnJ = scope.Bodies.rectangle( 1443, bs - layerSize * 2 + 5539, 158, 278, { isStatic: true });
												spawnJ.src = url + 'treeE.png';
												
											var spawnK = scope.Bodies.rectangle( 1513, bs - layerSize * 2 + 5662, 158, 278, { isStatic: true });
												spawnK.src = url + 'treeE.png';
												
											var spawnL = scope.Bodies.rectangle( 1489, bs - layerSize * 2 + 5876, 76, 82, { isStatic: true });
												spawnL.src = url + 'stoneB.png';
												
											var spawnM = scope.Bodies.rectangle( 1900, bs - layerSize * 2 + 5802, 158, 278, { isStatic: true });
												spawnM.src = url + 'treeE.png';
												
											var spawnN = scope.Bodies.rectangle( 2002, bs - layerSize * 2 + 5732, 99, 85, { isStatic: true });
												spawnN.src = url + 'stoneF.png';
											
											
											
											var spawnO = scope.Bodies.rectangle( 2566 , bs - layerSize * 2 + 5881, 118, 110, { isStatic: true });
												spawnO.src = url + 'treeM.png';
												spawnO.fixedBounds = 45;
												
											var spawnP = scope.Bodies.rectangle( 2831, bs - layerSize * 2 + 5709, 122, 215, { isStatic: true });
												spawnP.src = url + 'treeI.png';
												
											var spawnQ = scope.Bodies.rectangle( 2751, bs - layerSize * 2 + 5632, 120, 217, { isStatic: true });
												spawnQ.src = url + 'treeH.png';
												
											var spawnR = scope.Bodies.rectangle( 2658, bs - layerSize * 2 + 5173, 135, 235, { isStatic: true });
												spawnR.src = url + 'treeL.png';
												
											var spawnS = scope.Bodies.rectangle( 2560, bs - layerSize * 2 + 5068, 122, 215, { isStatic: true });
												spawnS.src = url + 'treeI.png';
												
											var spawnT = scope.Bodies.rectangle( 2445, bs - layerSize * 2 + 5203, 158, 282, { isStatic: true });
												spawnT.src = url + 'treeK.png';
												
											var spawnU = scope.Bodies.rectangle( 2381, bs - layerSize * 2 + 5010, 158, 282, { isStatic: true });
												spawnU.src = url + 'treeK.png';
												
											var spawnV = scope.Bodies.rectangle( 2166, bs - layerSize * 2 + 5038, 218, 245, { isStatic: true });
												spawnV.src = url + 'stoneG.png';
												spawnV.fixedBounds = 45;
												
											var spawnW = scope.Bodies.rectangle( 1853, bs - layerSize * 2 + 5182, 448, 438, { isStatic: true });
												spawnW.src = url + 'houseA.png';
												spawnW.fixedBounds = 60;
												
											var spawnX = scope.Bodies.rectangle( 1588, bs - layerSize * 2 + 4925, 158, 282, { isStatic: true });
												spawnX.src = url + 'treeJ.png';
												
											var spawnY = scope.Bodies.rectangle( 1543, bs - layerSize * 2 + 4998, 120, 217, { isStatic: true });
												spawnY.src = url + 'treeH.png';
												
											var spawnZ = scope.Bodies.rectangle( 1429 , bs - layerSize * 2 + 5026, 158, 278, { isStatic: true });
												spawnZ.src = url + 'treeE.png';
											
											var spawnAA = scope.Bodies.rectangle( 89, bs - layerSize * 2 + 4717, 51, 127, { isStatic: true });
												spawnAA.src = url + 'stoneE.png';
												spawnAA.fixedBounds = 25;
												
											var spawnAB = scope.Bodies.rectangle( 164, bs - layerSize * 2 + 4552, 191, 172, { isStatic: true });
												spawnAB.src = url + 'treeQ.png';
												
											var spawnAC = scope.Bodies.rectangle( 296, bs - layerSize * 2 + 4607, 174, 156, { isStatic: true });
												spawnAC.src = url + 'stoneI.png';
												spawnAC.fixedBounds = 25;
												
											var spawnAD = scope.Bodies.rectangle( 651, bs - layerSize * 2 + 4483, 143, 167, { isStatic: true });
												spawnAD.src = url + 'treeN.png';
												
											var spawnAE = scope.Bodies.rectangle( 742, bs - layerSize * 2 + 4205, 160, 205, { isStatic: true });
												spawnAE.src = url + 'treeP.png';
												
											var spawnAF = scope.Bodies.rectangle( 798, bs - layerSize * 2 + 4212, 106, 128, { isStatic: true });
												spawnAF.src = url + 'treeO.png';
												
											var spawnAG = scope.Bodies.rectangle( 556, bs - layerSize * 2 + 4017, 160, 205, { isStatic: true });
												spawnAG.src = url + 'treeP.png';
													
											var spawnAH = scope.Bodies.rectangle( 358, bs - layerSize * 2 + 4263, 131, 205, { isStatic: true });
												spawnAH.src = url + 'stoneJ.png';
												spawnAH.fixedBounds = 25;
												
											var spawnAI = scope.Bodies.rectangle( 139, bs - layerSize * 2 + 4196, 314, 254, { isStatic: true });
												spawnAI.src = url + 'stoneK.png';
												spawnAI.fixedBounds = 25;
												
											var spawnAJ = scope.Bodies.rectangle( 157, bs - layerSize * 2 + 4122, 313, 261, { isStatic: true });
												spawnAJ.src = url + 'stoneL.png';
												spawnAJ.fixedBounds = 25;
												
											var spawnAK = scope.Bodies.rectangle( 173, bs - layerSize * 2 + 3981, 106, 126, { isStatic: true });
												spawnAK.src = url + 'treeR.png';
												
											var spawnAL = scope.Bodies.rectangle( 94, bs - layerSize * 2 + 3891, 139, 244, { isStatic: true });
												spawnAL.src = url + 'treeA.png';
												
											var spawnAM = scope.Bodies.rectangle( 113, bs - layerSize * 2 + 3714, 192, 333, { isStatic: true });
												spawnAM.src = url + 'treeB.png';	
												
											var spawnAN = scope.Bodies.rectangle( 133, bs - layerSize * 2 + 3629, 192, 333, { isStatic: true });
												spawnAN.src = url + 'treeB.png';
												
											var spawnAP = scope.Bodies.rectangle( 225, bs - layerSize * 2 + 3688, 141, 246, { isStatic: true });
												spawnAP.src = url + 'treeC.png';	
											
											
											
											var spawnAQ = scope.Bodies.rectangle( 1025, bs - layerSize * 2 + 4854, 148, 129, { isStatic: true });
												spawnAQ.src = url + 'treeS.png';
												spawnAQ.fixedBounds = 25;	
												
											var spawnAR = scope.Bodies.rectangle( 1266, bs - layerSize * 2 + 4790, 104, 122, { isStatic: true });
												spawnAR.src = url + 'treeR.png';
												
											var spawnAS = scope.Bodies.rectangle( 1301, bs - layerSize * 2 + 4588, 159, 205, { isStatic: true });
												spawnAS.src = url + 'treeU.png';
												
											var spawnAT = scope.Bodies.rectangle( 1681, bs - layerSize * 2 + 4637, 159, 192, { isStatic: true });
												spawnAT.src = url + 'treeT.png';
												spawnAT.fixedBounds = 25;	
												
											var spawnAU = scope.Bodies.rectangle( 2079, bs - layerSize * 2 + 4407, 160, 205, { isStatic: true });
												spawnAU.src = url + 'treeP.png';	
												
											var spawnAV = scope.Bodies.rectangle( 2390, bs - layerSize * 2 + 4682, 188, 172, { isStatic: true });
												spawnAV.src = url + 'treeX.png';
												spawnAV.fixedBounds = 25;		
												
											var spawnAW = scope.Bodies.rectangle( 2927, bs - layerSize * 2 + 4519, 336, 337, { isStatic: true });
												spawnAW.src = url + 'stoneM.png';	
												spawnAW.fixedBounds = 25;	
												
											var spawnAX = scope.Bodies.rectangle( 2903, bs - layerSize * 2 + 3744, 76, 82, { isStatic: true });
												spawnAX.src = url + 'stoneB.png';	
												
											var spawnAY = scope.Bodies.rectangle( 2452, bs - layerSize * 2 + 3771, 243, 239, { isStatic: true });
												spawnAY.src = url + 'ruinD.png';	
												spawnAY.fixedBounds = 40;
												
											var spawnAZ = scope.Bodies.rectangle( 2385, bs - layerSize * 2 + 3857, 181, 129, { isStatic: true });
												spawnAZ.src = url + 'ruinC.png';
												spawnAZ.fixedBounds = 40;	
												
											var spawnBA = scope.Bodies.rectangle( 2003, bs - layerSize * 2 + 4083, 197, 228, { isStatic: true });
												spawnBA.src = url + 'treeW.png';	
												
											var spawnBB = scope.Bodies.rectangle( 1752, bs - layerSize * 2 + 3888, 197, 122, { isStatic: true });
												spawnBB.src = url + 'root.png';
												spawnBB.fixedBounds = 40;
												
											var spawnBC = scope.Bodies.rectangle( 1578, bs - layerSize * 2 + 4006, 199, 109, { isStatic: true });
												spawnBC.src = url + 'ruinB.png';	
												spawnBC.fixedBounds = 40;
												
											var spawnBD = scope.Bodies.rectangle( 1302, bs - layerSize * 2 + 4271, 143, 168, { isStatic: true });
												spawnBD.src = url + 'treeV.png';
												
											var spawnBE = scope.Bodies.rectangle( 978, bs - layerSize * 2 + 3956, 157, 106, { isStatic: true });
												spawnBE.src = url + 'ruinA.png';
												spawnBE.fixedBounds = 30;
											
											
											var spawnBF = scope.Bodies.rectangle( 2761, bs - layerSize * 2 + 3396, 230, 276, { isStatic: true });
												spawnBF.src = url + 'treeAA.png';
												spawnBF.fixedBounds = 25;
											
											var spawnBG = scope.Bodies.rectangle( 2614, bs - layerSize * 2 + 3141, 120, 217, { isStatic: true });
												spawnBG.src = url + 'treeH.png';
											
											var spawnBH = scope.Bodies.rectangle( 2688, bs - layerSize * 2 + 3067, 122, 215, { isStatic: true });
												spawnBH.src = url + 'treeI.png';
											
											var spawnBI = scope.Bodies.rectangle( 2155, bs - layerSize * 2 + 3240, 106, 128, { isStatic: true });
												spawnBI.src = url + 'treeO.png';
											
											var spawnBJ = scope.Bodies.rectangle( 1808, bs - layerSize * 2 + 3463, 160, 205, { isStatic: true });
												spawnBJ.src = url + 'treeP.png';
											
											var spawnBK = scope.Bodies.rectangle( 1263, bs - layerSize * 2 + 3408, 218, 246, { isStatic: true });
												spawnBK.src = url + 'stoneN.png';
												spawnBK.fixedBounds = 35;
											
											var spawnBL = scope.Bodies.rectangle( 1592, bs - layerSize * 2 + 2980, 158, 278, { isStatic: true });
												spawnBL.src = url + 'treeE.png';
											
											var spawnBM = scope.Bodies.rectangle( 838, bs - layerSize * 2 + 2966, 307, 295, { isStatic: true });
												spawnBM.src = url + 'houseB.png';
												spawnBM.fixedBounds = 70;
											
											var spawnBN = scope.Bodies.rectangle( 481, bs - layerSize * 2 + 2963, 296, 282, { isStatic: true });
												spawnBN.src = url + 'houseC.png';
												spawnBN.fixedBounds = 70;
												
											var temp = [ spawnA, spawnB, spawnC, spawnD, spawnE, spawnF, spawnG, spawnH, spawnHA, spawnI, spawnJ, spawnK, spawnL, spawnM, spawnN, spawnO, spawnP, 
											spawnQ, spawnR, spawnS, spawnT, spawnU, spawnV, spawnW, spawnX, spawnY, spawnZ, spawnAA, spawnAB, spawnAC, spawnAD, spawnAE,spawnAF, spawnAG,
											spawnAH, spawnAI, spawnAJ, spawnAK, spawnAL, spawnAM, spawnAN, spawnAP, spawnAQ, spawnAR, spawnAS, spawnAT, spawnAU,
											spawnAV, spawnAW, spawnAX, spawnAY, spawnAZ, spawnBA, spawnBB, spawnBC, spawnBD, spawnBE, spawnBF, spawnBG, spawnBH, spawnBI, spawnBJ, spawnBK, spawnBL, spawnBM, spawnBN ];
											
											for(var ii = 0, len = temp.length; ii < len ; ii++ ){
												temp[ii].name = temp[ii].label = 'staticOriGPass'+scope.uniqueId();
												temp[ii].FixedPosition = {
													x : temp[ii].position.x,
													y : temp[ii].position.y - bs
												}
												if( !temp[ii].fixedBounds ) temp[ii].fixedBounds = 15;
											}
											
											return temp
											
										}()
								}),
								
							]
						}
						
						return scope.staticAllMap['value'].mapDungeonG.content
					}(),
					
					//dungeonMapH
					function(){
						var location = 'mapDungeonH', url = scope.path+'ornaments/l/' , 
						bs = scope.browserHeightUpdate, layerSize = 3000, ySize = bs - layerSize, actualYSize = bs - layerSize * 2 ;
						
						//background
						obj.createBackground( 6, '/ornaments/l/', location );
						
						//create mini Map 
						scope.staticGeometry.createMap({
							location : location,
							src : url + 'map.png'	
						})
					 
						var staticSpawnB = obj.createPoint({
							label : 'staticOriDngHPassStB',
							texture : scope.path+'1px.png',
							x : 3477,
							y : actualYSize + 4196,
							target : 'help'
						}); 
						
						var staticSpawnC = obj.createPoint({
							label : 'staticOriDngHPassStC',
							texture : scope.path+'1px.png',
							x : 2755,
							y : actualYSize + 5036,
							target : 'help'
						}); 
						   
						var staticSpawnD = obj.createPoint({
							label : 'staticOriDngHPassStD',
							texture : scope.path+'1px.png',
							x : 1625,
							y : actualYSize + 4645,
							target : 'help'
						}); 
	 			 
						
						var pointSpawnA = obj.createPoint({
							isVisible : true, 
							label : 'staticOriDngHPassSpawnA',
							texture : scope.path+'1px.png',
							x : 5092,
							y : actualYSize + 5401,
							target : 'help'
						})
						 
						var pointSpawnB = obj.createPoint({
							isVisible : true, 
							label : 'staticOriDngHPassSpawnB',
							texture : scope.path+'1px.png',
							x : 5049,
							y : actualYSize + 3728,
							target : 'help'
						})
						
						var pointSpawnC = obj.createPoint({
							isVisible : true, 
							label : 'staticOriDngHPassSpawnC',
							texture : scope.path+'1px.png',
							x : 2095,
							y : actualYSize + 4368,
							target : 'help'
						})
						
						var pointSpawnD = obj.createPoint({
							isVisible : true, 
							label : 'staticOriDngHPassSpawnD',
							texture : scope.path+'1px.png',
							x : 655,
							y : actualYSize + 3921,
							target : 'help'
						})
						
						
						obj.createSVGBuffer( url+'buffer-a.svg', location, 'staticOriDngHBufferA', { x : 1143, y :  actualYSize + 4919 })
						obj.createSVGPathBuffer( url+'path-buffer-a.svg', location, 'staticOriDngHPathBufferA', 'staticOriDngHBufferA', { x : -10, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-b.svg', location, 'staticOriDngHBufferB', { x : 521, y :  actualYSize + 4325 })
						obj.createSVGPathBuffer( url+'path-buffer-b.svg', location, 'staticOriDngHPathBufferB', 'staticOriDngHBufferB', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-c.svg', location, 'staticOriDngHBufferC', { x : 447, y :  actualYSize + 3754 })
						obj.createSVGPathBuffer( url+'path-buffer-c.svg', location, 'staticOriDngHPathBufferC', 'staticOriDngHBufferC', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-d.svg', location, 'staticOriDngHBufferD', { x : 1914, y :  actualYSize + 5239 })
						obj.createSVGPathBuffer( url+'path-buffer-d.svg', location, 'staticOriDngHPathBufferD', 'staticOriDngHBufferD', { x : 0, y :  10 } )
						
						obj.createSVGBuffer( url+'buffer-e.svg', location, 'staticOriDngHBufferE', { x : 2750, y :  actualYSize + 5636 })
						obj.createSVGPathBuffer( url+'path-buffer-e.svg', location, 'staticOriDngHPathBufferE', 'staticOriDngHBufferE', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-d.svg', location, 'staticOriDngHBufferF', { x : 3201, y :  actualYSize + 5115 })
						obj.createSVGPathBuffer( url+'path-buffer-d.svg', location, 'staticOriDngHPathBufferF', 'staticOriDngHBufferF', { x : 0, y :  10 } )
						
						obj.createSVGBuffer( url+'buffer-f.svg', location, 'staticOriDngHBufferG', { x : 2784, y :  actualYSize + 4500 })
						obj.createSVGPathBuffer( url+'path-buffer-f.svg', location, 'staticOriDngHPathBufferG', 'staticOriDngHBufferG', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-g.svg', location, 'staticOriDngHBufferH', { x : 3835, y :  actualYSize + 3331 })
						obj.createSVGPathBuffer( url+'path-buffer-g.svg', location, 'staticOriDngHPathBufferH', 'staticOriDngHBufferH', { x : -4, y :  -7 } )
						 
						obj.createSVGBuffer( url+'buffer-b.svg', location, 'staticOriDngHBufferI', { x : 4285, y :  actualYSize + 3970 })
						obj.createSVGPathBuffer( url+'path-buffer-b.svg', location, 'staticOriDngHPathBufferI', 'staticOriDngHBufferI', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-e.svg', location, 'staticOriDngHBufferJ', { x : 4424, y :  actualYSize + 5240 })
						obj.createSVGPathBuffer( url+'path-buffer-e.svg', location, 'staticOriDngHPathBufferJ', 'staticOriDngHBufferJ', { x : 0, y :  0 } )
						
						obj.createSVGBuffer( url+'buffer-h.svg', location, 'staticOriDngHBufferK', { x : 4922, y :  actualYSize + 4460 })
						obj.createSVGPathBuffer( url+'path-buffer-h.svg', location, 'staticOriDngHPathBufferK', 'staticOriDngHBufferK', { x : 0, y :  0 } )
						
						scope.staticAllMap['value'].mapDungeonH.content = {
							staticWallOuttermapDungeonH : obj.createWall( location, "medium" ),
							staticOriDngHPassStB : staticSpawnB, 
							staticOriDngHPassStC : staticSpawnC, 
							staticOriDngHPassStD : staticSpawnD,  
							staticOriDngHPassSpawnA : pointSpawnA,   
							staticOriDngHPassSpawnB : pointSpawnB,  
							staticOriDngHPassSpawnC : pointSpawnC,   
							staticOriDngHPassSpawnD : pointSpawnD,   
							staticOriGroupSVG : [],
							staticSpawnLabel : [ "staticOriDngHPassSpawnA", "staticOriDngHPassSpawnB", "staticOriDngHPassSpawnD" ],
							groupLayer : [
								obj.createLayer( 'staticOriHPassLayerA',
									{ x : 0, y : 0, location : location,  
										layer: function(){
											var spawnA = scope.Bodies.rectangle( 248 , bs - layerSize * 2 + 4718, 276, 356, { isStatic: true });
												spawnA.src = url + 'treeA.png';
											
											var spawnB = scope.Bodies.rectangle( 583, bs - layerSize* 2 + 5299, 276, 356, { isStatic: true });
												spawnB.src = url + 'treeA.png';
												
											var spawnC = scope.Bodies.rectangle( 1454 , bs - layerSize * 2 + 5736, 266, 343, { isStatic: true });
												spawnC.src = url + 'treeC.png';

											var spawnD = scope.Bodies.rectangle( 2702 , bs - layerSize * 2 + 5645, 242, 312, { isStatic: true });
												spawnD.src = url + 'treeB.png';
												
											var spawnE = scope.Bodies.rectangle( 2880 , bs - layerSize * 2 + 5542, 266, 343, { isStatic: true });
												spawnE.src = url + 'treeC.png';
											
											var spawnF = scope.Bodies.rectangle( 2099 , bs - layerSize * 2 + 5219,  242, 312, { isStatic: true });
												spawnF.src = url + 'treeB.png';
												spawnF.fixedBounds = 45
												
											var spawnG = scope.Bodies.rectangle( 1920 , bs - layerSize * 2 +  5116, 266, 343, { isStatic: true });
												spawnG.src = url + 'treeC.png';
												spawnG.fixedBounds = 45
												
											var spawnH = scope.Bodies.rectangle( 1304 , bs - layerSize * 2 + 5196, 91, 125, { isStatic: true });
												spawnH.src = url + 'sign.png';	
											
											var spawnHA = scope.Bodies.rectangle( 1128 , bs - layerSize * 2 + 4822, 339, 339, { isStatic: true });
												spawnHA.src = url + 'stone.png';
											
											
										
											var spawnI = scope.Bodies.rectangle( 2924 , bs - layerSize * 2 +  4527, 201, 295, { isStatic: true });
												spawnI.src = url + 'treeD.png';

											var spawnJ = scope.Bodies.rectangle( 2872 , bs - layerSize * 2 + 4370, 276, 356, { isStatic: true });
												spawnJ.src = url + 'treeA.png';
												
											var spawnK = scope.Bodies.rectangle( 2690 , bs - layerSize * 2 + 4376, 242, 312, { isStatic: true });
												spawnK.src = url + 'treeB.png';
												
											var spawnL = scope.Bodies.rectangle( 1496 , bs - layerSize * 2 + 4266, 266, 343, { isStatic: true });
												spawnL.src = url + 'treeC.png';
												
											var spawnM = scope.Bodies.rectangle( 1255 , bs - layerSize * 2 + 3846, 276, 356, { isStatic: true });
												spawnM.src = url + 'treeA.png';
												
											var spawnN = scope.Bodies.rectangle( 695 , bs - layerSize * 2 + 4310, 242, 312, { isStatic: true });
												spawnN.src = url + 'treeB.png';
											
											var spawnO = scope.Bodies.rectangle( 597  , bs - layerSize * 2 + 4246, 242, 312, { isStatic: true });
												spawnO.src = url + 'treeB.png';
												
											var spawnP = scope.Bodies.rectangle( 471 , bs - layerSize * 2 + 4321, 201, 295, { isStatic: true });
												spawnP.src = url + 'treeD.png';
												
											var spawnQ = scope.Bodies.rectangle( 507 , bs - layerSize * 2 + 3639, 459, 324, { isStatic: true });
												spawnQ.src = url + 'houseA.png';
												spawnQ.fixedBounds = 60;
												
											var spawnR = scope.Bodies.rectangle( 1613 , bs - layerSize * 2 + 3406, 134, 90, { isStatic: true });
												spawnR.src = url + 'ruinM.png';
												
											var spawnS = scope.Bodies.rectangle( 1720 , bs - layerSize * 2 + 3233, 275, 258, { isStatic: true });
												spawnS.src = url + 'treeF.png';
												
											var spawnT = scope.Bodies.rectangle( 2159 , bs - layerSize * 2 + 3712, 247, 292, { isStatic: true });
												spawnT.src = url + 'treeE.png';
												
											var spawnU = scope.Bodies.rectangle( 2581 , bs - layerSize * 2 + 3825, 157, 101, { isStatic: true });
												spawnU.src = url + 'ruinL.png';
												
											var spawnV = scope.Bodies.rectangle( 2610 , bs - layerSize * 2 + 3307, 149, 199, { isStatic: true });
												spawnV.src = url + 'stoneA.png';
												spawnV.fixedBounds = 45;
												
											var spawnW = scope.Bodies.rectangle( 2846 , bs - layerSize * 2 + 3077, 99, 85, { isStatic: true });
												spawnW.src = url + 'stoneB.png';
											
											
											
											var spawnX = scope.Bodies.rectangle( 2927 , bs - layerSize * 2 + 3859, 63, 113, { isStatic: true });
												spawnX.src = url + 'ruinC.png';
												
											var spawnY = scope.Bodies.rectangle( 2762 , bs - layerSize * 2 + 3964, 70, 113, { isStatic: true });
												spawnY.src = url + 'ruinK.png';
												
											var spawnZ = scope.Bodies.rectangle( 2538  , bs - layerSize * 2 + 4154, 63, 113, { isStatic: true });
												spawnZ.src = url + 'ruinC.png';
											
											var spawnAA = scope.Bodies.rectangle( 2340 , bs - layerSize * 2 + 4058, 128, 199, { isStatic: true });
												spawnAA.src = url + 'ruinJ.png';
												
											var spawnAB = scope.Bodies.rectangle( 2151 , bs - layerSize * 2 + 4001, 80, 180, { isStatic: true });
												spawnAB.src = url + 'ruinA.png';
												
											var spawnAC = scope.Bodies.rectangle( 1990 , bs - layerSize * 2 + 4106, 80, 179, { isStatic: true });
												spawnAC.src = url + 'ruinB.png';
												
											var spawnAD = scope.Bodies.rectangle( 1858 , bs - layerSize * 2 + 4226, 63, 113, { isStatic: true });
												spawnAD.src = url + 'ruinC.png';
												
											var spawnAE = scope.Bodies.rectangle( 1702 , bs - layerSize * 2 + 4307, 129, 200, { isStatic: true });
												spawnAE.src = url + 'ruinD.png';
												
											var spawnAF = scope.Bodies.rectangle( 1783, bs - layerSize * 2 + 4406, 80, 179, { isStatic: true });
												spawnAF.src = url + 'ruinB.png';
												
											var spawnAG = scope.Bodies.rectangle( 1946 , bs - layerSize * 2 + 4478, 80, 180, { isStatic: true });
												spawnAG.src = url + 'ruinA.png';
													
											var spawnAH = scope.Bodies.rectangle( 2075 , bs - layerSize * 2 + 4561, 71, 113, { isStatic: true });
												spawnAH.src = url + 'ruinE.png';
												
											var spawnAI = scope.Bodies.rectangle( 2194 , bs - layerSize * 2 + 4619, 63, 113, { isStatic: true });
												spawnAI.src = url + 'ruinI.png';
												
											var spawnAJ = scope.Bodies.rectangle( 2036 , bs - layerSize * 2 + 4737, 70, 113, { isStatic: true });
												spawnAJ.src = url + 'ruinK.png';
												
											var spawnAK = scope.Bodies.rectangle( 1909 , bs - layerSize * 2 + 4809, 129, 200, { isStatic: true });
												spawnAK.src = url + 'ruinD.png';
												
											var spawnAL = scope.Bodies.rectangle( 2074 , bs - layerSize * 2 + 4914, 80, 179, { isStatic: true });
												spawnAL.src = url + 'ruinB.png';
												
											var spawnAM = scope.Bodies.rectangle( 2263 , bs - layerSize * 2 + 5032, 80, 179, { isStatic: true });
												spawnAM.src = url + 'ruinF.png';	
												
											var spawnAN = scope.Bodies.rectangle( 2494 , bs - layerSize * 2 + 4887, 80, 179, { isStatic: true });
												spawnAN.src = url + 'ruinF.png';
												
											var spawnAP = scope.Bodies.rectangle( 2584 , bs - layerSize * 2 + 4830, 63, 113, { isStatic: true });
												spawnAP.src = url + 'ruinI.png';	
											
											var spawnAQ = scope.Bodies.rectangle( 2679 , bs - layerSize * 2 + 4713, 80, 179, { isStatic: true });
												spawnAQ.src = url + 'ruinB.png';
												
											var spawnAR = scope.Bodies.rectangle( 2780 , bs - layerSize * 2 + 4623, 128, 199, { isStatic: true });
												spawnAR.src = url + 'ruinJ.png';
												
											var spawnAS = scope.Bodies.rectangle( 2559 , bs - layerSize * 2 + 4284, 128, 199, { isStatic: true });
												spawnAS.src = url + 'ruinJ.png';
											
											var temp = [ spawnA, spawnB, spawnC, spawnD, spawnE, spawnF, spawnG, spawnH, spawnHA, spawnI, spawnJ, spawnK, spawnL, spawnM, spawnN, spawnO, spawnP, 
											spawnQ, spawnR, spawnS, spawnT, spawnU, spawnV, spawnW, spawnX, spawnY, spawnZ, spawnAA, spawnAB, spawnAC, spawnAD, spawnAE,spawnAF, spawnAG,
											spawnAH, spawnAI, spawnAJ, spawnAK, spawnAL, spawnAM, spawnAN, spawnAP, spawnAQ, spawnAR, spawnAS  ];
											
											for(var ii = 0, len = temp.length; ii < len ; ii++ ){
												temp[ii].name = temp[ii].label = 'staticOriGPass'+scope.uniqueId();
												temp[ii].FixedPosition = {
													x : temp[ii].position.x,
													y : temp[ii].position.y - bs
												}
												if( !temp[ii].fixedBounds ) temp[ii].fixedBounds = 25;
											}
											
											return temp
											
										}()
								}),
								obj.createLayer( 'staticOriHPassLayerB',  
									{ x : 3000, y : 0, location : location,  
										layer:  function(){
										
										var height = bs + -( layerSize * 2 );
										
										var spawnA = scope.Bodies.rectangle( 200 , height + 5022, 266, 343, { isStatic: true });
											spawnA.src = url + 'treeC.png';
										
										var spawnB = scope.Bodies.rectangle( 379 , height + 5125, 242, 312, { isStatic: true });
											spawnB.src = url + 'treeB.png';
											
										var spawnC = scope.Bodies.rectangle( 693 , height + 5602, 188, 243, { isStatic: true });
											spawnC.src = url + 'treeH.png';

										var spawnD = scope.Bodies.rectangle( 2037 , height + 5736, 266, 343, { isStatic: true });
											spawnD.src = url + 'treeC.png';
											
										var spawnE = scope.Bodies.rectangle( 2772 , height + 5240, 267, 356, { isStatic: true });
											spawnE.src = url + 'treeA.png';
											
										var spawnF = scope.Bodies.rectangle( 2303 , height + 4815, 266, 343, { isStatic: true });
											spawnF.src = url + 'treeC.png';
											
										var spawnG = scope.Bodies.rectangle( 2188 , height + 5196, 91, 125, { isStatic: true });
											spawnG.src = url + 'signB.png';
											
										var spawnH = scope.Bodies.rectangle( 1571 , height + 5116, 266, 343, { isStatic: true });
											spawnH.src = url + 'treeC.png';	
										
										var spawnI = scope.Bodies.rectangle( 1393 , height + 5219, 201, 259, { isStatic: true });
											spawnI.src = url + 'treeD.png';

										var spawnJ = scope.Bodies.rectangle( 1950 , height + 4333, 339, 339, { isStatic: true });
											spawnJ.src = url + 'stoneC.png';
											spawnJ.fixedBounds = 40
										
										var spawnK = scope.Bodies.rectangle( 2644 , height + 3400, 99, 85, { isStatic: true });
											spawnK.src = url + 'stoneD.png';
											
										var spawnL = scope.Bodies.rectangle( 2236 , height + 3846, 267, 356, { isStatic: true });
											spawnL.src = url + 'treeA.png';
											
										var spawnM = scope.Bodies.rectangle( 1879 , height + 3406, 134, 90, { isStatic: true });
											spawnM.src = url + 'ruinN.png';	
											
										var spawnN = scope.Bodies.rectangle( 1771  , height + 3233, 275, 258, { isStatic: true });
											spawnN.src = url + 'treeI.png';

										var spawnO = scope.Bodies.rectangle( 1481 , height + 3939, 201, 259, { isStatic: true });
											spawnO.src = url + 'treeD.png';
											
										var spawnP = scope.Bodies.rectangle( 1356  , height + 3864, 267, 356, { isStatic: true });
											spawnP.src = url + 'treeA.png';
											
										var spawnQ = scope.Bodies.rectangle( 1258 , height + 3928, 242, 312, { isStatic: true });
											spawnQ.src = url + 'treeB.png';
										
										var spawnR = scope.Bodies.rectangle( 1078  , height + 3180, 267, 356, { isStatic: true });
											spawnR.src = url + 'treeA.png';
											
										var spawnS = scope.Bodies.rectangle( 906 , height + 3319, 201, 259, { isStatic: true });
											spawnS.src = url + 'treeD.png';
											
										var spawnT = scope.Bodies.rectangle( 708 , height + 3221, 201, 259, { isStatic: true });
											spawnT.src = url + 'treeD.png';
											
										var spawnU = scope.Bodies.rectangle( 239  , height + 3143, 251, 281, { isStatic: true });
											spawnU.src = url + 'treeJ.png';
										
										
										
										var spawnV = scope.Bodies.rectangle( 56  , height + 4619, 129, 200, { isStatic: true });
											spawnV.src = url + 'ruinD.png';
											
										var spawnW = scope.Bodies.rectangle( 233  , height + 4707, 80, 179, { isStatic: true });
											spawnW.src = url + 'ruinB.png';
											
										var spawnX = scope.Bodies.rectangle( 411  , height + 4817, 63, 113, { isStatic: true });
											spawnX.src = url + 'ruinC.png';
											
										var spawnY = scope.Bodies.rectangle( 570  , height + 4673, 80, 180, { isStatic: true });
											spawnY.src = url + 'ruinA.png';
											
										var spawnZ = scope.Bodies.rectangle( 696  , height + 4557, 80, 180, { isStatic: true });
											spawnZ.src = url + 'ruinA.png';
											
										var spawnAA = scope.Bodies.rectangle( 837  , height + 4438, 80, 179, { isStatic: true });
											spawnAA.src = url + 'ruinB.png';
											
										var spawnAB = scope.Bodies.rectangle( 964  , height + 4366, 71, 113, { isStatic: true });
											spawnAB.src = url + 'ruinE.png';
											
										var spawnAC = scope.Bodies.rectangle( 1040  , height + 4242, 128, 119, { isStatic: true });
											spawnAC.src = url + 'ruinJ.png';
											
										var spawnAD = scope.Bodies.rectangle( 855  , height + 4206, 63, 113, { isStatic: true });
											spawnAD.src = url + 'ruinI.png';
											
										var spawnAE = scope.Bodies.rectangle( 662  , height + 4084, 80, 179, { isStatic: true });
											spawnAE.src = url + 'ruinB.png';
											
										var spawnAF = scope.Bodies.rectangle( 528  , height + 3996, 129, 200, { isStatic: true });
											spawnAF.src = url + 'ruinD.png';
											
										var spawnAG = scope.Bodies.rectangle( 688  , height + 3883, 80, 179, { isStatic: true });
											spawnAG.src = url + 'ruinF.png';
											
										var spawnAH = scope.Bodies.rectangle( 543  , height + 3831, 63, 113, { isStatic: true });
											spawnAH.src = url + 'ruinI.png';
											
										var spawnAI = scope.Bodies.rectangle( 383  , height + 3734, 80, 179, { isStatic: true });
											spawnAI.src = url + 'ruinF.png';
											
										var spawnAJ = scope.Bodies.rectangle( 145  , height + 3723, 80, 179, { isStatic: true });
											spawnAJ.src = url + 'ruinB.png';

										
										var temp = [ spawnA, spawnB, spawnC, spawnD, spawnE, spawnF, spawnG, spawnH, spawnI, spawnJ , spawnK, spawnL, spawnM, spawnN, spawnO, spawnP, 
										spawnQ, spawnR, spawnS, spawnT, spawnU, spawnV, spawnW, spawnX, spawnY, spawnZ, spawnAA, spawnAB , spawnAC , spawnAD , spawnAE , spawnAF, spawnAG, spawnAH , spawnAI, spawnAJ ]
										for(var ii = 0, len = temp.length; ii < len ; ii++ ){
											temp[ii].name = temp[ii].label = 'staticOriDPass'+scope.uniqueId();
											temp[ii].FixedPosition = {
												x : temp[ii].position.x,
												y : temp[ii].position.y - bs
											}
											if( !temp[ii].fixedBounds ) temp[ii].fixedBounds = 15;
										}
										
										return temp
										
									}()
								}),
							]
							
						}

						return scope.staticAllMap['value'].mapDungeonH.content
						
					}(),
					//item
					function(){
						var createItem = function( name, width, height, isItemWithAngle ){
							
							if( name === "Ness Scale" ) name = "drop-item";
							
							var src = scope.path+  name +'.png';
							item = scope.Bodies.rectangle( 0, 0, width, height, {
								isStatic : true,
								render: {
									sprite: {
										texture: src
									}
								}
							}); 
				
							item.label = 'itemPass_'+name +'_'+scope.uniqueId();
							item.name = isItemWithAngle ? "itemWithAngle" : 'item';
							item.inverseInertia = 0;
							return 	item
						}

						return {
							createItem : createItem
						}
					}(),
					
					//create damage area
					function(){
						var createAreaDmg = function( pos, width, height ){
							var src = scope.path+'1px.png',
							areaDmg = scope.Bodies.rectangle( pos.x, pos.y, width, height, {
								isStatic : true,
								collisionFilter: {
									category :  0x0004
								},	
								render: {
									sprite: {
										texture: src
									}
								}
							
							});
							areaDmg.monsterParameters = [];
							areaDmg.label = 'areaDmg-'+scope.uniqueId();
							areaDmg.inverseInertia = 0;
							areaDmg.name = 'areaDmg';
							areaDmg.visible = true;
							areaDmg.pass = true;

							return areaDmg
						}

						return {
							staticAreaDmg : createAreaDmg
						}
					}(),
					
					//create general monster
					function(){
						var createGeneralMonster = function( name, boundValue, boundWidth , boundHeight, behaveRig ){
							var behave = [], render, src, generalMonster;
							
							for(var ii in behaveRig ) {
								behave.push( ii )
							}
							if( behave.length ){
								
								src = scope.path +  name +'-right.png',
								render = {
									behave : behave ,
									behaveRig : behaveRig ,
									sprite: {
										texture: src
									}
								}
							
								
							}else{
								src = scope.path + name +'-right.png',
								render = {
									behave : ["idle"] ,
									behaveRig : {
										idle : {
											totalOfFrames : 1,
											speed : 10
										}
									} ,
									sprite: {
										texture: src
									}
								}
								
							}
							
							generalMonster = scope.Bodies.rectangle( 0, 0, 60, 70, {
								collisionFilter: {
									category :  0x0004
								},
								render : render
							});

							generalMonster.label = 'monster-'+ name +'-'+scope.uniqueId();
							generalMonster.inverseInertia = 0;
							generalMonster.name = 'monster-'+ name ;
							generalMonster.initialName = name ;
							generalMonster.additionalBoundsValue = boundValue;
							generalMonster.additionalBoundsHeightValue = boundHeight;
							generalMonster.additionalBoundsWidthValue = boundWidth;
							generalMonster.visible = true;
							generalMonster.mapMark = new scope.draw.mapMark();
							generalMonster.stateStorage = 'monster'+ name.charAt(0).toUpperCase() + name.slice(1) +'State';
							
							scope[ generalMonster.stateStorage ] = new scope.storageState['value'];
							
							behave.length  && scope.getTexture( generalMonster.render, src, false, name );
							
							return generalMonster;
							
						}

						return {
							staticGeneralMonster : createGeneralMonster
						}
					}(),
					//Oval
					function(){
						
						var src = scope.path+'warrior-character-idle-right.png',
						oval = scope.Bodies.rectangle( scope.browserWidthUpdate / 2, scope.browserHeightUpdate / 2, 60, 70,{
								friction : 1,
								collisionFilter: {
									mask:  0x0001
								}
							} )
							oval.label = 'oval'
							oval.behave = 'idle';
							oval.stateStorage = 'characterState';
							scope[ oval.stateStorage ] = new scope.storageState['value'];
							
							oval.initialName = 'warrior-character' ;
							oval.additionalBoundsHeightValue = 25;
							oval.additionalBoundsWidthValue = 0;
							oval.pions = [];
							oval.totalOfFrames = 25;
							oval.additionalBoundsValue = 60;
							oval.mapMark = new scope.draw.mapMark();
							oval.name = 'character';
							oval.inverseInertia = 0;
							/*
							
							,
							render: {
								behave : ["walk","idle","upperAttack","rollingAttack","massiveAttack","attack2","attack3","attack4","attack5","attack6","attack7","attack8"], 
								behaveRig : {
									walk : {
										totalOfFrames : 15,
										speed : 1
									},
									idle : {
										totalOfFrames : 9,
										speed : 3
									},
									upperAttack : {
										totalOfFrames : 9,
										speed : 3
									},
									massiveAttack : {
										totalOfFrames : 9,
										speed : 2
									},
									rollingAttack : {
										totalOfFrames : 25,
										speed : 1
									},
									attack2 : {
										totalOfFrames : 9,
										speed : 2
									},
									attack3 : {
										totalOfFrames : 9,
										speed : 2
									},
									attack4 : {
										totalOfFrames : 9,
										speed : 2
									},
									attack5 : {
										totalOfFrames : 9,
										speed : 2
									},
									attack6 : {
										totalOfFrames : 15,
										speed : 3
									},
									attack7 : {
										totalOfFrames : 9,
										speed : 2
									},
									attack8 : {
										totalOfFrames : 9,
										speed : 2
									}
								},
								sprite: {
									texture: src
								}
							}
							
							
							scope.getTexture( oval.render, src, false, oval.initialName  )
							*/
						return {
							oval : oval
						}

					}()
				]
			},
			
			initilizeObject: function(){
				var scope = this;
				var  MouseConstraint = Matter.MouseConstraint,
				MouseMatter = Matter.Mouse,
				mouseMatter = MouseMatter.create( scope.canvas ),
				world = scope.engine.world;
				
				// 33.33 was from 1000 / 30;
				//formula find milisecond // ? = seconds * 1000 / 33.33;
				//formula find second // milisecond * 33.33 / 1000 = ?;

				for( var jj = 0, kk = scope.fragment; jj < kk.length ; jj++ )
				{
					for( var ll in kk[jj]) if(ll in kk[jj])
					{
						if( !/staticWall|staticOri/i.test( ll ) ){
								
								
						scope.World.add( world, kk[jj][ll] )
						} else if( 'staticWallOuttermapA' === ll  ){
							//first load only install map A
							scope.World.add( world, kk[jj][ll] )
						}
						
						scope.objFragment[ll] = kk[jj][ll];
					}
				}

				world.gravity.y = 0;
				world.gravity.x = 0;
				
				var mouseConstraint = MouseConstraint.create( scope.engine, {
					mouse: mouseMatter,
					constraint: {
						stiffness: 0.2,
						render: {
							visible: true
						}
					}
				});
		
				//scope.World.add( world, mouseConstraint );

					/**/
				scope.extend( scope.objFragment, { 
				
					staticDrawImage : {
						fn : new scope.draw.enviOrnaments,
						hpMedTexture : new function(){
							this.render = {
								textures : "",
								src : scope.path + "hp-medium-bar.png"
							}
							this.textures = scope.getTexture( this.render,  this.render.src )
						},
						hpMedConver : new function(){
							this.render = {
								textures : "",
								src : scope.path + "hp-medium-cover.png"
							}
							this.textures = scope.getTexture( this.render,  this.render.src );
						
						},
						hpMedTick : new function(){
							this.render = {
								textures : "",
								src : scope.path + "hp-medium-tick.png"
							}
							this.textures = scope.getTexture( this.render,  this.render.src );
						
						}
					},
					staticWallOutter : '',
					areaDmgPool : new scope.storageState['value'],
					monsterAttribute : function( level, attribut, boss ){
						if( level >= 0 && level < 5 ){
							if( attribut === 'soul' ){
								var soul = scope.random( 13, 7  );
								return boss ? soul * 2 : soul;
							}else if( attribut === 'exp' ){
								var exp = scope.random( 45, 31 );
								return boss ? exp * 2 : exp;
							}
						}else if( level >= 5 && level < 10 ){
							if( attribut === 'soul' ){
								var soul = scope.random( 17, 11 );
								return boss ? soul * 2 : soul;
							}else if( attribut === 'exp' ){
								var exp = scope.random( 84, 63  );
								return boss ? exp * 2 : exp;
							}
						}else if( level >= 10 && level < 13 ){
							if( attribut === 'soul' ){
								var soul = scope.random( 21, 9 );
								return boss ? soul * 2 : soul;
							}else if( attribut === 'exp' ){
								var exp = scope.random( 155, 105 );
								return boss ? exp * 2 : exp;
							}
						}else if( level >= 13 && level < 16 ){
							if( attribut === 'soul' ){
								var soul = scope.random( 28, 15  );
								return boss ? soul * 2 : soul;
							}else if( attribut === 'exp' ){
								var exp = scope.random( 185, 135 );
								return boss ? exp * 2 : exp;
							}
						}else if( level >= 16 && level < 19 ){
							if( attribut === 'soul' ){
								var soul = scope.random( 35, 23  );
								return boss ? soul * 2 : soul;
							}else if( attribut === 'exp' ){
								var exp = scope.random( 235, 175 );
								return boss ? exp * 2 : exp;
							}
						}else if( level >= 19 && level < 21 ){
							if( attribut === 'soul' ){
								var soul = scope.random( 45, 33  );
								return boss ? soul * 2 : soul;
							}else if( attribut === 'exp' ){
								var exp = scope.random( 237, 185 );
								return boss ? exp * 2 : exp;
							}
						}else if( level >= 21 && level < 23 ){
							if( attribut === 'soul' ){
								var soul = scope.random( 21, 15  );
								return boss ? soul * 2 : soul;
							}else if( attribut === 'exp' ){
								var exp = scope.random( 215, 165 );
								return boss ? exp * 2 : exp;
							}
						}else if( level >= 23 && level < 25 ){
							if( attribut === 'soul' ){
								var soul = scope.random( 42, 34  );
								return boss ? soul * 2 : soul;
							}else if( attribut === 'exp' ){
								var exp = scope.random( 295, 215 );
								return boss ? exp * 2 : exp;
							}
						}else if( level >= 25 && level < 27 ){
							if( attribut === 'soul' ){
								var soul = scope.random( 58, 43  );
								return boss ? soul * 2 : soul;
							}else if( attribut === 'exp' ){
								var exp = scope.random( 435, 375 );
								return boss ? exp * 2 : exp;
							}
						}else if( level >= 27 && level < 30 ){
							if( attribut === 'soul' ){
								var soul = scope.random( 91, 73  );
								return boss ? soul * 2 : soul;
							}else if( attribut === 'exp' ){
								var exp = scope.random( 565, 495 );
								return boss ? exp * 2 : exp;
							}
						}
					},
					registerMagicBoxItem : new scope.storageState['value'],
					itemShop : new scope.storageState['value'],
					characterQuest : new scope.storageState['value'],
					characterSkills : new scope.storageState['value'],
					characterGetDamage : new scope.storageState['value'],
					characterInventoryBag : new scope.storageState['value'],	
					characterParameters : '',
					characterStatus : '',
					caracterSkillToogleFn :function( pass ){
						var skills = scope.characterSkills['value'].get( scope.oval["value"].label  ),
						mpChara = scope.characterParameters['value'].mp,
						disableGUI = [],
						enableGUI = [],
						undeadToogle = true,
						
						buff = scope.buffGUI['value'].storage,
						buffPass = true;
						for( var ff in buff ){
							if( /lightningShock/i.test( buff[ff].name ) ){
								buffPass = false;
							}
						}
						 
						if( buffPass ){
							
							for(var ii = 0, jj = skills.length; ii < jj ; ii++  ){
								
								var prop = skills[ii]; 
								
								if( mpChara < prop.mp 
									&& !prop.disable 
									&& prop.tick < prop.tickUpdate  ||
									!prop.state || pass ){
									prop.disable = true;
									disableGUI.push( prop );
						
									
								}else if( mpChara < prop.mp 
									&& !prop.disable 
									&& prop.tick === prop.tickUpdate ){
									prop.disable = true;
									disableGUI.push( prop );
									
								}else if(  mpChara >= prop.mp 
									&& prop.disable 
									&& prop.tick === prop.tickUpdate  || pass ){
									prop.disable = false;
									enableGUI.push( prop );
								}
								
							}
							
							
							disableGUI.length && scope.disableSkill['value']( 'disable', disableGUI );
							enableGUI.length && scope.disableSkill['value']( 'enable', enableGUI );
							
						}
						
					},
					disableSkill : function( init, selectedSkills ){
						var elements = scope.slice( scope.qsAll('disable-skill') );
						for(var ii = 0; ii < elements.length; ii++ ){
							if( selectedSkills ){
								var label = elements[ii].parentNode.getAttribute('label')
								for( var kk = 0; kk < selectedSkills.length ; kk++ ){
									if( label === selectedSkills[kk].label ){
										if( init === "enable" ){
											scope.sibling( elements[ii], "previous" ).innerHTML = "";
											elements[ii].style.display = 'none' ;
										}else{
											elements[ii].style.display = 'block' 
										}
									}	
								}
							}else{
								if( init === "enable" ){
									scope.sibling( elements[ii], "previous" ).innerHTML = "";
									elements[ii].style.display = 'none' 
								}else{
									elements[ii].style.display = 'block' 
								}
							}
						}
						
					},
					
					characterMobileControl : {
						status : '',
						charObj : '',
						top : false,
						left : false,
						bottom : false,
						right : false,
						jump : false,
						firstTouch : false
					},
					characterLevel : function( monsterParameters, slayer ){
						var charParams = scope.characterParameters['value'],
						mergerParams = [ charParams ],
						characterAttribute = function( level, params  ){
							var obj = {
								attributLvl :{
									mage : {
										statA : {
											attackRange : 2,
											attack: 1,
											hp : 4.2, // in percentage
											mp : 4.7, // in percentage
											magicDefense : 8,
											defense : 3
										},
										statB : {
											attackRange : 12,
											attack: 8,
											hp : 5.7, // in percentage
											mp : 5.8, // in percentage
											magicDefense : 16,
											defense : 12
										},
										statC : {
											attackRange : 17,
											attack: 12,
											hp : 6.8, // in percentage
											mp : 6.3, // in percentage
											magicDefense : 24,
											defense : 22
										},
										statD : {
											attackRange : 24,
											attack: 18,
											hp : 8.8, // in percentage
											mp : 9.3, // in percentage
											magicDefense : 31,
											defense : 21
										},
										statE : {
											attackRange : 36,
											attack: 28,
											hp : 10.8, // in percentage
											mp : 10.3, // in percentage
											magicDefense : 41,
											defense : 41
										}
									},
									warrior : {
										statA : {
											attackRange : 1,
											attack: 6,
											hp : 5, // in percentage
											mp : 70, // in percentage
											magicDefense : 3,
											defense : 13
										},
										statB : {
											attackRange : 5,
											attack: 21,
											hp : 7.4, // in percentage
											mp : 35, // in percentage
											magicDefense : 6,
											defense : 17
										},
										statC : {
											attackRange : 9,
											attack: 37,
											hp : 9.7, // in percentage
											mp : 15, // in percentage
											magicDefense : 9,
											defense : 25
										},
										statD : {
											attackRange : 13,
											attack: 47,
											hp : 10.7, // in percentage
											mp : 13, // in percentage
											magicDefense : 12,
											defense : 22
										},
										statE : {
											attackRange : 23,
											attack: 41,
											hp : 12.7, // in percentage
											mp : 10, // in percentage
											magicDefense : 22,
											defense : 29
										}
									},
									archer : {
										statA : {
											attackRange : 6,
											attack: 3,
											hp : 4.1, // in percentage
											mp : 70, // in percentage
											magicDefense : 7,
											defense : 13
										},
										statB : {
											attackRange : 24,
											attack: 6,
											hp : 4.7, // in percentage
											mp : 35, // in percentage
											magicDefense : 11,
											defense : 15
										},
										statC : {
											attackRange : 41,
											attack: 12,
											hp : 7.7, // in percentage
											mp : 15, // in percentage
											magicDefense : 13,
											defense : 17
										},
										statD : {
											attackRange : 53,
											attack: 19,
											hp : 9.4, // in percentage
											mp : 12, // in percentage
											magicDefense : 24,
											defense : 19
										}
									}
								},
								instantceFormula : function( objParams ){
									var container = scope.isMobile() ? scope.qs('items-equipment-mb') : scope.qs('passive-magic'),
									magicBox = scope.slice( container.getElementsByTagName('li') ), 
									loot = scope.characterInventoryBag['value'].get( scope.oval["value"].label  ),
									filter = [];
									for( var ii = 0, jj = magicBox.length; ii < jj ; ii++ ){
										var magicItem = magicBox[ii].getElementsByTagName('div');
										if( magicItem.length ){
											for( var kk = 0; kk < loot.length; kk++ ){
												if( magicItem[0].getAttribute('label') === loot[kk].label ){
													filter.push( loot[kk] )
												}
											}
										}
									}
									
									filter = scope.uniqueArray( filter ); // prevent cheat
									
									if( filter.length ){
										for( var ii = 0, oriParam = objParams.originalParams; ii < filter.length; ii++){
											if( filter[ii].effect ){
												var effect = filter[ii].effect;
												for( var jj in effect ){
													switch( jj ) {
														case 'attack': 
															objParams.attackRangeMax = objParams.attackRangeMax + ( oriParam.attackRangeMax * effect[jj].value / 100 );
															objParams.attackRangeMin = objParams.attackRangeMin + ( oriParam.attackRangeMin * effect[jj].value / 100 );
															objParams.attackMax = objParams.attackMax + ( oriParam.attackMax * effect[jj].value / 100 );
															objParams.attackMin = objParams.attackMin + ( oriParam.attackMin * effect[jj].value / 100 );
															break;
														case 'defense': 
															objParams.defenseMax = objParams.defenseMax + ( oriParam.defenseMax * effect[jj].value / 100 );
															objParams.defenseMin = objParams.defenseMin + ( oriParam.defenseMin * effect[jj].value / 100 );
															break;
														case 'magicDefense': 
															objParams.magicDefenseMax = objParams.magicDefenseMax + ( oriParam.magicDefenseMax * effect[jj].value / 100 );
															objParams.magicDefenseMin = objParams.magicDefenseMin + ( oriParam.magicDefenseMin * effect[jj].value / 100 );
															break;
													}
												}
											}
										}
									}
									
									
								},
								changeCharStat : function ( classJob, stat, isSlayer ){
									var newParams = params.originalParams  ? params.originalParams : params,
									selectedStat = this.attributLvl[ classJob ][ stat ];
									
									
									percentageKill = isSlayer ?  1 : scope.randomFloat( 0.99, 0.80 );
									
									params.attackRangeMax = newParams.attackRangeMax += Math.round( selectedStat.attackRange * percentageKill );
									params.attackRangeMin = newParams.attackRangeMin += Math.round( selectedStat.attackRange * percentageKill );
									params.attackMax = newParams.attackMax += Math.round( selectedStat.attack * percentageKill );
									params.attackMin = newParams.attackMin += Math.round( selectedStat.attack * percentageKill );
									params.magicDefenseMax = newParams.magicDefenseMax += Math.round( selectedStat.magicDefense * percentageKill );
									params.magicDefenseMin = newParams.magicDefenseMin += Math.round( selectedStat.magicDefense * percentageKill );
									params.defenseMax = newParams.defenseMax += Math.round( selectedStat.defense * percentageKill );
									params.defenseMin = newParams.defenseMin += Math.round( selectedStat.defense * percentageKill );
									params.maxHealth = newParams.maxHealth += Math.round( Math.round( newParams.maxHealth * ( selectedStat.hp / 100 ) ) * percentageKill  );
									params.maxMp = newParams.maxMp += Math.round( Math.round( newParams.maxMp * ( selectedStat.mp / 100 ) )  * percentageKill );
								
									params.originalParams  && this.instantceFormula( params );
									
								}
							}
						
							
							var selectedName = params.name === scope.oval["value"].label  ? 'mage' : 
								params.name === 'Blood Lich Warrior' ? 'warrior' : 'archer';
							
							var selectedSlayer = params.name === slayer;
							
							( level >= 0 && level < 3 ) ? 
								obj.changeCharStat( selectedName ,'statA', selectedSlayer ) :
							( level >= 3 && level < 7 ) ?
								obj.changeCharStat( selectedName ,'statA', selectedSlayer ) :
							( level >= 7 && level < 13 ) ?
								obj.changeCharStat( selectedName ,'statB', selectedSlayer ) : 
							( level >= 13 && level < 15 ) ?
								obj.changeCharStat( selectedName ,'statC', selectedSlayer ) : 
							( level >= 15 && level < 18 ) ?
								obj.changeCharStat( selectedName ,'statD', selectedSlayer ) : 
							( level >= 18 && level <= 25 ) ?
								obj.changeCharStat( selectedName ,'statE', selectedSlayer ) : '';
								
						},
						expLevel = {
							levelA : [ 25, 50, 75, 100, 125, 150, 175, 200, 225, 250],
							levelB : [ 300, 350, 400, 450, 500, 550, 600, 650, 700, 750],
							levelC : [ 750, 1050, 1350, 1700, 4200, 4700, 5200, 5700, 6200, 6700]
						},
						sumExp = function( params, level, levelExp, totalExp ){
							for(var ii = 0, jj = levelExp.length + level; ii < jj; ii++ ){
								totalExp.tot += levelExp[ii];
								if(  ii + 1 === params.level ){
									if( ii + 1 === 10 ) totalExp.tot += expLevel.levelB[0];
									else if( ii + 1  === 20 ) totalExp.tot += expLevel.levelC[0];
									else totalExp.tot += levelExp[ ii + 1 ];
									break;
								}
							}
						},
						levelSelect = function( params, totalExp ){
							if( params.level <= 10 ){
								sumExp( params, 0 , expLevel.levelA, totalExp )
							}else if( params.level > 10 && params.level <= 20 ){
								sumExp( params, params.level, expLevel.levelA.concat( expLevel.levelB ), totalExp )
							}else if( params.level > 20 && params.level <= 30 ){
								sumExp( params, params.level, expLevel.levelA.concat( expLevel.levelB ).concat( expLevel.levelC ), totalExp  )
							}
						};
						
						//collect itemLabel from pions rigBody
						var pions = charParams.object.pions,
						loot = scope.characterInventoryBag['value'].get( scope.oval["value"].label  ),
						pionParams = [];
						if( pions.length ){
							self : for(var ii = 0; ii < pions.length ; ii++ ){
								var itemLabel = pions[ii].rigBody.itemLabel;
								for(var jj = 0, kk = loot.length; jj < kk ; jj++ ){
									if( loot[jj].label === itemLabel ){
										pionParams.push( loot[jj].familiar )
										continue self;
									}
								}
							}
						}
						
						mergerParams = mergerParams.concat( pionParams );
						
						//console.log( mergerParams )	
						
						
						for(var ii = 0, jj = mergerParams.length; ii < jj; ii++ ){
							var selectedParams = mergerParams[ii],
							isOval = mergerParams[ii].name === scope.oval["value"].label  ? true : false,
							totExp = { tot : 0 };
							if( !!monsterParameters ){
								var selectedSlayer = selectedParams.name === slayer ? 1 : scope.randomFloat( 0.85, 0.65 ),
								addedXp = Math.round( monsterParameters.exp * selectedSlayer );
								
								selectedParams.expTemp += addedXp;
								
								if( isOval ){
									scope.text( scope.qs('addedExp'), '+'+addedXp )
									$('.addedExp').show()
									$('.addedExp').fadeOut(4500)
									scope.text( scope.qs('currentExp'), selectedParams.expTemp );
									scope.infoLogFn['value']({
										title : 'regular-title',
										text : {
											white : 'Got',
											chocolate : ' +'+addedXp+' ' ,
											skyBlue : 'Exp'
										}
									})
								}
							}
							
							if( isOval ){
								scope.text( scope.qs('level'), selectedParams.level )
								scope.text( scope.qs('currentExp'), selectedParams.expTemp );
							}
							
							levelSelect( selectedParams, totExp );
							
							//add level
							if( selectedParams.expTemp > selectedParams.exp + totExp.tot ){
								selectedParams.exp = selectedParams.expTemp;
								selectedParams.level ++;
								if( isOval ) selectedParams.skillPoint ++;
								characterAttribute( selectedParams.level, selectedParams );
							}
							
							if( isOval ){
								//console.log(selectedParams.exp + totExp.tot+' '+ selectedParams.exp +' '+ totExp.tot)
								var percentage = (  ( selectedParams.expTemp - selectedParams.exp ) /  totExp.tot ) * 100;
								scope.css( scope.qs('exp-bar'),{ 'width' : Math.round( percentage )+'%' });
								scope.text( scope.qs('nextEpx'), selectedParams.exp + totExp.tot );
								scope.text( scope.qs('level'), selectedParams.level );
							}
							
							
						}
						
					},
					updateGoldtoLocalStorageHero : function( gold, object ){
						//save gold hero
						var goldHero = localStorage.getItem( 'goldHero' ),
						fnAddGoldtoLocalStorage = function( format ){
							 
							if( /archer/i.test(  object.label ) ){
								format.heroArcher = gold
							}else if( /armor/i.test(  object.label ) ){ //armor
								format.heroArmor = gold
							}
							
							
						}
						if( goldHero ){
								
							var format = JSON.parse( localStorage.getItem( 'goldHero') )
							
							
						}else{
							var format = {
								heroArcher : 0,
								heroArmor : 0
							}
							 
						}
						
						fnAddGoldtoLocalStorage( format );
						
						localStorage.setItem( 'goldHero', scope.JSONstringfy( format ) );
						
						 
					},
					addGoldToHero : function( parent ){
						
						if( !/hero/i.test( parent.object.label ) &&
							/hero/i.test( parent.character.label )
							&& !parent.isStatic ){
								
							var gold = 0,
							monsterName = parent.monsterParameters.name,
							monsterLevel = parent.monsterParameters.monsterLevel.toLowerCase();
							
							switch( monsterLevel ){
								case "e" : gold = scope.random( 50, 20 ); break;
								case "d" : gold = scope.random( 120, 50 ); break;
								case "c" : gold = scope.random( 210, 150 ); break;
								case "b" : gold = scope.random( 500, 350 ); break;
								case "a" : gold = scope.random( 1000, 750 ); break;
								case "s" : gold = scope.random( 2500, 2000 ); break;
							}
						 
							
							scope.kongPoints["value"] += gold;
							 
							 
							parent.character.statParameters.gold += gold;
							
							scope.playAudio('Pickup_Gold_04')
							scope.infoLogFn['value']({
								title : 'regular-title',
								text : {
									chocolate :  parent.character.statParameters.name,
									white : owlData.lang.fn( "gui", "accuredItem", "detail" )+ gold+' G '+
										owlData.lang.fn( "gui", "accuredItemB", "detail" ), 
									gold : monsterName
									
								}
							})
							
							scope.updateGoldtoLocalStorageHero["value"]( parent.character.statParameters.gold, parent.character )
						}
					},
					items :  '',
					pickUpDropItem : function( params ){
						var parent = params.parent,
						itemName = params.initial,
						value = params.value;
					
						if( scope.items['value'][ parent ][ itemName ] ){
							var items = scope.characterInventoryBag['value'].get( scope.oval['value'].label  ); 
							items.push( new scope.items['value'][ parent ][ itemName ]({ quantity : value }) ); 
							
						}
					},
					characterDropItem : function( item ){
						
						var loot = scope.characterInventoryBag['value'].get( scope.oval['value'].label ),
						chara = scope.oval['value'].position,
						dir = scope.random( 1, 0 ) ? 'left' : 'right',
						obj,
						itemName = item.displayName ? item.displayName : item.name, // drop monster property only have 'name'
						texture = {
							name : "Ness Scale",
							width : 74,
							height : 68 
						},
						x = chara.x + ( dir === 'left' ? 
							scope.random( 1,0 ) ? 
								scope.random( -50, -100 ) :
								scope.random( 50, 100 ) :
							scope.random( 1,0 ) ? 	
								scope.random( 50, 100 ) :
								scope.random( -50, -100 ) ) ,
								
						y = chara.y + ( dir === 'left' ? 
							scope.random( 1,0 ) ? 
								scope.random( -50, -100 ) :
								scope.random( 50, 100 ) :
							scope.random( 1,0 ) ? 	
								scope.random( 50, 100 ) :
								scope.random( -50, -100 ) ) ,
								
						obj = new scope.monsterControl.item.create( 
							x, 
							y,
							itemName,
							texture,
							item.root
						);
						
						obj.object.itemVal = item.quantity;
						
						scope.monsterControl.itemTemp.push( obj );
						scope.World.add( scope.staticWorld['value'], obj.object );

					},
					controlGUICheck : function(){
							var el = scope.slice( scope.qsAll('.med-divice-nav') )
							if( scope.isMobile() ) {
								scope.qs('.nav-left-b').style.display = 'block';
								for(var ii in el) el[ii].style.display = 'block';
								scope.qs('hidden-menu').style.display = 'block';
								scope.removeClass( scope.qs('mini-map-mobile'), 'hidden' );
								scope.addClass( scope.qs('menu-map-mobile'), 'hidden' )
								scope.qs('nav-bottom').style.display = 'none';
								scope.qs('nav-bottom-mobile').style.display = 'block';
								scope.qs('info-menu').style.display = 'none';
								scope.qs('nav-info-text').style.display = 'none';
								scope.qs('info-text').style.display = 'none';
								scope.qs('menu-map').style.display = 'none';
							}else{
								scope.qs('nav-left-b').style.display = 'none';
								for(var ii in el) el[ii].style.display = 'none';
								scope.qs('hidden-menu').style.display = 'none';
								scope.qs('nav-bottom').style.display = 'block';
								scope.qs('nav-bottom-mobile').style.display = 'none';
								scope.addClass( scope.qs('mini-map-mobile'), 'hidden' );
								scope.addClass( scope.qs('menu-map-mobile'), 'hidden' );
								scope.qs('info-menu').style.display = 'block';
								scope.qs('nav-info-text').style.display = 'block';
								scope.qs('info-text').style.display = 'block';
								scope.qs('menu-map').style.display = 'block';
								
							}
							
							//scope.characterLevel['value']()
							
						},
					orderObjectFn : function(){
						// additionOrderValue
						//order object per 100 milisecond
						var bodies = scope.Composite.allBodies( scope.engine.world ),
						temp = [], tempBg = [], tempBgOrder = []; //tempBg is dungeon background
						 
						for(var ii = 0, jj = bodies.length ; ii <  jj ; ii++ ){
							var posY = bodies[ii].bounds.max.y
							if( !/PassBG/i.test( bodies[ii].label ) ){
								temp.push( posY )
							}else{
								tempBgOrder.push ( posY ) 
							}
						}

						temp.sort( function( a, b ){return a - b } );
						scope.orderObj = temp
						
						tempBgOrder.sort( function( a, b ){return a - b } );
						tempBg = tempBgOrder
						
						self : for(var ii = 0, jj = bodies.length ; ii <  jj ; ii++ ){
							var posY = bodies[ii].bounds.max.y
							
							for(var kk = 0, ll = temp ; kk < ll.length ; kk++ ){
								if( posY === ll[kk] && !/PassBG/i.test( bodies[ii].label )){
									scope.orderObj[kk] = bodies[ii]
									continue self;
								}
							}
							
							for(var mm = 0, nn = tempBgOrder ; mm < nn.length ; mm++ ){
								if( posY === nn[mm] && /PassBG/i.test( bodies[ii].label )){
									tempBg[mm] = bodies[ii]
									continue self;
								}
							}
						
						}
						
						var temp =  tempBg.concat( scope.orderObj ), tempObj = '';
						//if added markerMonster for mobile order to backward
						for(var ii = 0; ii < temp.length ; ii ++ ){
							if( /controlRigh/i.test( temp[ii].label ) ){
								tempObj = temp[ii];
								temp.splice( ii, 1 );
								temp.unshift( tempObj );
							}
						}
						scope.orderObj = temp
					},
					mouseConstraint : mouseConstraint,
					buffGUI : new scope.storageState['value'],
					guiSupportAvailable : [],
					globalCharacterState : "",
					globalLoadGame : scope.loadGame,
					globalEngine : scope.engine,
					globalWorld : scope.World,
					globalBody : scope.Body,
					globalObjectGUI :"",
					globalSaveLoad : function(){},
					globalSaveGame : '',
					globalLoopingAudio : new scope.storageState['value'],
					globalAnimation : scope,
					monsterParameters : new scope.storageState['value'],
					monsterGetDamage : new scope.storageState['value'],
					pushMsgText : function( textPopup, tickRemove, msgLevel, callback ){
						var divPopup = document.createElement('div'),
						closeMsg = document.createElement('div'),
						classRandom = 'msg-'+scope.uniqueId(),
						listFNs = scope.intervalList,
						pass = false, count = 0, tempMsg = [];
						
						/******/
						//remove old msg when msg more than two
						for( var ii in listFNs ){
							if( /mimic/i.test( ii ) ){
								count++;
								
								tempMsg.push( listFNs[ii] );
								if( count >= 2 ){
									pass = true
								}
							}
						}
						
						if( pass ){
							tempMsg[0].tick = 0;
						}
						
						tempMsg.length = 0;
						
						/*********/
						
						var msgLevel = msgLevel ? msgLevel : "",
						msg = scope.qs('info-important').getElementsByTagName('div');
						for(var ii = 0, jj = msg.length; ii < jj ; ii++ ){
							if( !/close-msg/i.test( msg[ii].className ) ){
								scope.addClass( msg[ii], 'pop-up-text-move' ) ;
							}
						}
						 
						
						closeMsg.className = 'close-msg';
						divPopup.className = 'pop-up-text '+msgLevel+' '+classRandom;
						scope.text( divPopup, textPopup );
						
						divPopup.appendChild( closeMsg );
						scope.qs('info-important').appendChild( divPopup );
						
						scope.attachListener( closeMsg, 'click', function(){
							if( !/pop-up-text-move/i.test( scope.qs( classRandom ).className) ){
								scope.addClass( scope.qs( classRandom ), 'pop-up-text-out' )
							}else{
								scope.addClass( scope.qs( classRandom ), 'pop-up-text-out pop-up-text-move' )
							}
						})
						
						
						scope.intervalList[ classRandom ] = {
							name : 'msg-text',
							classNm : classRandom,
							tick : 10,
							fn : function(){
								scope.qs( this.classNm ) &&
									scope.addClass( scope.qs( this.classNm ), 'pop-up-text-in' )
							}
						}
						
						scope.intervalList[ classRandom+'_mimic' ] = {
							name : 'msg-text',
							classNm : classRandom,
							tick : tickRemove,
							fn : function(){
								if( !/pop-up-text-move/i.test( scope.qs(  this.classNm  ).className) ){
									scope.addClass( scope.qs(  this.classNm  ), 'pop-up-text-out' )
								}else{
									scope.addClass( scope.qs(  this.classNm  ), 'pop-up-text-out pop-up-text-move' )
								}
								
								setTimeout( function( callback ){
									callback && callback()
									scope.qs(  this.classNm  ).remove();
								}.bind( this, callback ),450)
							}
						}
					},
					infoLog : new scope.storageState['value'],
					infoLogFn : function( addInfo ){
						
						scope.infoLog['value'].set( scope.uniqueId(), addInfo );
					
						var storage = scope.infoLog['value'].storage, len = storage.length,
						cnt = scope.qs('wrap-box-text'), //desktop
						cntMobile = scope.qs('wrap-box-text-mobile'), 
						appendText = function( parent, className, text ){
							var abbr = document.createElement('abbr');
							abbr.className = className;
							scope.text( abbr, text )
							parent.appendChild( abbr )
									
						};
						
						cntMobile.innerHTML = cnt.innerHTML = ''
						
						scope.css( cnt , { 
							'transform': '0px, 0px,0px', 
						})
						scope.css( cntMobile , { 
							'transform': '0px, 0px,0px', 
						})
						
						if( len > 50 ){ storage.splice( 0, 1 ); len--; }
						
						for( ;  len-- ; ){
							var span = document.createElement('span');
							span.className = storage[ len ].status.title;
							
							for( var ii in storage[ len ].status.text ){
								var text = storage[ len ].status.text[ii];
								appendText( span, ii, text );
							}
							
							cnt.appendChild( span );
							cntMobile.appendChild( span.cloneNode(true) );
						}
						
						//apply filter
						var elInfo = scope.slice(scope.qs('nav-info-text').getElementsByTagName('div'));
						for(var ii = 0, jj = elInfo.length; ii < jj; ii++ ){
							var infoClassName = elInfo[ii].className
							if( scope.getFirstChild( elInfo[ii] ) ){
								if( infoClassName === 'checkbox-all') {
									scope.infoFilter['value']( 0 )
								}else if( infoClassName === 'checkbox-quest' ){
									scope.infoFilter['value']( 2 )
								}else if( infoClassName === 'checkbox-item' ){
									scope.infoFilter['value']( 3 )
								}
								break;
							}
						}
						
						
					},
					infoFilter : function( index ){
						var elSpan = scope.slice( scope.qs('wrap-box-text').getElementsByTagName('span') );
							
						for(var kk = 0, ll = elSpan.length; kk < ll; kk++){
							scope.addClass( elSpan[kk], 'hidden');
						}
						if( index === 0 ){
							for(var kk = 0, ll = elSpan.length; kk < ll; kk++){
								scope.removeClass( elSpan[kk], 'hidden');
							}
						}else if( index === 2 ){
							for(var kk = 0, ll = elSpan.length; kk < ll; kk++){
								if(/primary-title/i.test( elSpan[kk].className ) ){
									scope.removeClass( elSpan[kk], 'hidden');
								}
							}
						}else if( index === 3 ){
							for(var kk = 0, ll = elSpan.length; kk < ll; kk++){
								if(/regular-title|exp-title/i.test( elSpan[kk].className ) ){
									scope.removeClass( elSpan[kk], 'hidden');
								}
							}
						}
						
					},
					scaleMap : {
						map : 6,
						mark : 24,
						centerMark : {
							x : 65,
							y : 35
						},
						centerMap : {
							x : 410,
							y : -220
						},
						
						close : false
					},
					kongPoints : 0
				}, true )
				
				scope.accessor.call( scope, {
					global : scope.objFragment,
					accessorName : '_worldObject',
					namespace : _owlBird.namespace
				})
				
				//clear fragment
				scope.fragment = scope.objFragment.length = 0;
				
				//all items here, item or skill
				scope.items['value'] = {
					magic : {
						manaStrongPotion : function( params ){
							this.name = 'manapotion';
							this.displayName = owlData.lang.fn( "items", "manaStrongPotion", "displayName" );
							this.root = {
								parent : 'magic',
								initial : 'manaStrongPotion'
							};
							this.quantity = params && params.quantity || 1;
							this.cure = 350;
							this.cooldown = 105;
							this.cooldownTick = 0;
							this.className = 'mana-strong-potion';
							this.enchantment = false;
							this.type = 'potion';
							this.usage = 'healing';
							this.size = 'small';
							this.bagLocation = '';
							this.detail =  owlData.lang.fn( "items", "manaStrongPotion", "detail" );
							this.unique = false;
							this.label = scope.uniqueId();
						},
						manaMediumPotion : function( params ){
							this.name = 'manapotion';
							this.displayName = owlData.lang.fn( "items", "manaMediumPotion", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'manaMediumPotion'
							};
							this.quantity = params && params.quantity || 1;
							this.cure = 200;
							this.cooldown = 90;
							this.cooldownTick = 0;
							this.className = 'mana-medium-potion';
							this.enchantment = false;
							this.type = 'potion';
							this.usage = 'healing';
							this.size = 'small';
							this.bagLocation = '';
							this.detail =  owlData.lang.fn( "items", "manaMediumPotion", "detail" );
							this.unique = false;
							this.label = scope.uniqueId();
						},
						manaPotion : function( params ){
							this.name = 'manapotion';
							this.displayName = owlData.lang.fn( "items", "manaPotion", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'manaPotion'
							};
							this.quantity = params && params.quantity || 1;
							this.cure = 100,
							this.cooldown = 60;
							this.cooldownTick = 0;
							this.className = 'mana-potion';
							this.enchantment = false;
							this.type = 'potion';
							this.usage = 'healing';
							this.size = 'small';
							this.bagLocation = '';
							this.detail =  owlData.lang.fn( "items", "manaPotion", "detail" ); 
							this.unique = false;
							this.label = scope.uniqueId();
						},
						healthStrongPotion : function( params ){
							this.name = 'healthpotion';
							this.displayName = owlData.lang.fn( "items", "healthStrongPotion", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'healthStrongPotion'
							};
							this.quantity = params && params.quantity || 1;
							this.cure = 750;
							this.cooldown = 105;
							this.cooldownTick = 0;
							this.className = 'health-strong-potion';
							this.enchantment = false;
							this.type = 'potion';
							this.usage = 'healing';
							this.size = 'small';
							this.bagLocation = '';
							this.detail =  owlData.lang.fn( "items", "healthStrongPotion", "detail" );
							this.unique = false;
							this.label = scope.uniqueId();
						},
						healthMediumPotion : function( params ){
							this.name = 'healthpotion';
							this.displayName = owlData.lang.fn( "items", "healthMediumPotion", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'healthMediumPotion'
							};
							this.quantity = params && params.quantity || 1;
							this.cure = 450;
							this.cooldown = 75;
							this.cooldownTick = 0;
							this.className = 'health-medium-potion';
							this.enchantment = false;
							this.type = 'potion';
							this.usage = 'healing';
							this.size = 'small';
							this.bagLocation = '';
							this.detail =  owlData.lang.fn( "items", "healthMediumPotion", "detail" );
							this.unique = false;
							this.label = scope.uniqueId();
						},
						healthPotion : function( params ){
							this.name = 'healthpotion';
							this.displayName = owlData.lang.fn( "items", "healthPotion", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'healthPotion'
							};
							this.quantity = params && params.quantity || 1;
							this.cure = 300;
							this.cooldown = 60;
							this.cooldownTick = 0;
							this.className = 'health-potion';
							this.enchantment = false;
							this.type = 'potion';
							this.usage = 'healing';
							this.size = 'small';
							this.bagLocation = '';
							this.detail =  owlData.lang.fn( "items", "healthPotion", "detail" ); 
							this.unique = false;
							this.label = scope.uniqueId();
						},
						explosionRedBoom : function( params ){
							this.name = 'explosionRedBoom';
							this.displayName = owlData.lang.fn( "items", "explosionRedBoom", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'explosionRedBoom'
							};
							this.quantity = params && params.quantity || 1;
							this.damageMax = 110;
							this.damageMin = 54;
							this.className = 'explosion-red';
							this.type = 'equipmentThrowBoom';
							this.enchantment = false;
							this.itemfor = "archer";
							this.bagLocation = '';
							this.detail =  owlData.lang.fn( "items", "explosionRedBoom", "detail" ); 
							this.unique = false;
							this.label = scope.uniqueId();
						},
						explosionBlueBoom : function( params ){
							this.name = 'explosionBlueBoom';
							this.displayName = owlData.lang.fn( "items", "explosionBlueBoom", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'explosionBlueBoom'
							};
							this.quantity = params && params.quantity || 1;
							this.damageMax = 110;
							this.damageMin = 54;
							this.stunMax = 25;
							this.stunMin = 20;
							this.reduceMovement = 1;
							this.className = 'explosion-blue';
							this.type = 'equipmentThrowBoom';
							this.enchantment = false;
							this.itemfor = "archer";
							this.bagLocation = '';
							this.detail =  owlData.lang.fn( "items", "explosionBlueBoom", "detail" );  
							this.unique = false;
							this.label = scope.uniqueId();
						},
						blueJewel : function( params ){
							this.name = 'bluejewel';
							this.displayName = owlData.lang.fn( "items", "blueJewel", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'blueJewel'
							};
							this.quantity = params && params.quantity || 1;
							this.className = 'blue-jewel';
							this.enchantment = false;
							this.type = 'Mistik';
							this.usage = 'upgrade';
							this.bagLocation = '';
							this.effect = {
								attack : {
									target : [ 'character' ],
									value : 15
								} 
							}
							this.registered = [];
							this.detail =  owlData.lang.fn( "items", "blueJewel", "detail" );  
							this.unique = true;
							this.label = scope.uniqueId();
						},
						redJewel : function( params ){
							this.name = 'redjewel';
							this.displayName = owlData.lang.fn( "items", "redJewel", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'redJewel'
							};
							this.quantity = params && params.quantity || 1;
							this.className = 'red-jewel';
							this.enchantment = false;
							this.type = 'mystic';
							this.usage = 'upgrade';
							this.bagLocation = '';
							this.effect = {
								avoid : {
									target : [ 'character' ],
									value : 15
								}
							}
							this.registered = [];
							this.detail =  owlData.lang.fn( "items", "redJewel", "detail" );  
							this.unique = true;
							this.label = scope.uniqueId();
						},
						greenJewel : function( params ){
							this.name = 'greenJewel';
							this.displayName = owlData.lang.fn( "items", "greenJewel", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'greenJewel'
							};
							this.quantity = params && params.quantity || 1;
							this.className = 'green-jewel';
							this.enchantment = false;
							this.type = 'mystic';
							this.usage = 'upgrade';
							this.bagLocation = '';
							this.itemfor = "leader";
							this.effect = {
								defense : {
									target : [ 'character','pion' ],
									value : 15
								},
								attack : {
									target : [ 'character','pion' ],
									value : 20
								}
							}
							this.registered = [];
							this.detail =  owlData.lang.fn( "items", "greenJewel", "detail" );  
							this.unique = true;
							this.label = scope.uniqueId();
						},
						ornamentPurple : function( params ){
							this.name = 'ornamentPurple';
							this.displayName = owlData.lang.fn( "items", "ornamentPurple", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'ornamentPurple'
							};
							this.quantity = params && params.quantity || 1;
							this.className = 'ornament-purple';
							this.enchantment = false;
							this.type = 'mystic';
							this.usage = 'upgrade';
							this.bagLocation = '';
							this.effect = {
								stun : {
									target : [ 'character' ],
									value : 15
								}
							}
							this.registered = [];
							this.detail =  owlData.lang.fn( "items", "ornamentPurple", "detail" );  
							this.unique = true;
							this.label = scope.uniqueId();
						},
						ornamentGreen : function( params ){
							this.name = 'ornamentGreen';
							this.displayName = owlData.lang.fn( "items", "ornamentGreen", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'ornamentGreen'
							};
							this.quantity = params && params.quantity || 1;
							this.className = 'ornament-green';
							this.enchantment = false;
							this.type = 'mystic';
							this.usage = 'upgrade';
							this.bagLocation = '';
							this.effect = {
								block : {
									target : [ 'character' ],
									value : 15
								}
							}
							this.registered = [];
							this.detail =  owlData.lang.fn( "items", "ornamentGreen", "detail" );  
							this.unique = true;
							this.label = scope.uniqueId();
						},
						greenLightNecklace : function( params ){
							this.name = 'greenlightnecklace';
							this.displayName = owlData.lang.fn( "items", "greenLightNecklace", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'greenLightNecklace'
							};
							this.quantity = params && params.quantity || 1;
							this.className = 'green-light-necklace';
							this.enchantment = false;
							this.type = 'mystic';
							this.usage = 'upgrade';
							this.bagLocation = '';
							this.effect = {
								criticalChance : {
									target : [ 'character'  ],
									value : 15
								}
							}
							
							this.registered = [];
							this.detail =  owlData.lang.fn( "items", "greenLightNecklace", "detail" ); 
							this.unique = true;
							this.label = scope.uniqueId();
						},
						redGemStone : function( params ){
							this.name = 'redgemstone';
							this.displayName = owlData.lang.fn( "items", "redGemStone", "displayName" );
							this.root = {
								parent : 'magic',
								initial : 'redGemStone'
							};
							this.quantity = params && params.quantity || 1;
							this.className = 'red-gem-stone';
							this.type = 'mystic';
							this.usage = 'upgrade';
							this.itemfor = "leader";
							this.enchantment = false;
							this.bagLocation = '';
							this.effect = {
								criticalChance : {
									target : [ 'character','pion' ],
									value : 15
								},
								defense : {
									target : [ 'character','pion' ],
									value : 20
								}
							}
							
							this.registered = [];
							this.detail = owlData.lang.fn( "items", "redGemStone", "detail" );
							this.unique = true;
							this.label = scope.uniqueId();
						},
						goldGemStone : function( params ){
							this.name = 'goldgemstone';
							this.displayName = owlData.lang.fn( "items", "goldGemStone", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'goldGemStone'
							};
							this.quantity = params && params.quantity || 1;
							this.className = 'gold-gem-stone';
							this.enchantment = false;
							this.type = 'mystic';
							this.usage = 'upgrade';
							this.bagLocation = '';
							this.effect = {
								critical : {
									target : [ 'character' ],
									value : 34
								}
							}
							this.registered = [];
							this.detail = owlData.lang.fn( "items", "goldGemStone", "detail" );  
							this.unique = true;
							this.label = scope.uniqueId();
						},
						golemSummoner : function( params ){
							this.name = 'golemSummoner';
							this.displayName = owlData.lang.fn( "items", "golemSummoner", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'golemSummoner'
							};
							this.quantity = params && params.quantity || 1;
							this.className = 'golemSummoner';
							this.mp = 232;
							this.state = true;
							this.disable = false;
							this.life = 200;
							this.spawnTick = 45;
							this.selectedSkillFrame = "skill";
							this.initialParams = {
								aiParams : "golem",
								spawn : {
									x : 0,
									y : 0
								},
								spawnTotal : 1,
								aIParent : "",
								forceGravity : false,
								maximumPawns : 4
							}
							this.enchantment = false;
							this.itemfor = "leader";
							this.type = 'mystic'; 
							this.bagLocation = '';
							this.detail = owlData.lang.fn( "items", "golemSummoner", "detail" ); 
							this.unique = true;
							this.label = scope.uniqueId();
						},
						sekletonSummoner : function( params ){
							this.name = 'sekletonSummoner';
							this.displayName = owlData.lang.fn( "items", "sekletonSummoner", "displayName" ); 
							this.root = {
								parent : 'magic',
								initial : 'sekletonSummoner'
							};
							this.quantity = params && params.quantity || 1;
							this.className = 'sekletonSummoner';
							this.mp = 232;
							this.state = true;
							this.disable = false;
							this.life = 200;
							this.spawnTick = 25;
							this.selectedSkillFrame = "skill";
							this.initialParams = {
								aiParams : "sekletonSpear",
								spawn : {
									x : 0,
									y : 0
								},
								spawnTotal : 1,
								aIParent : "",
								forceGravity : false,
								maximumPawns : 4
							}
							this.enchantment = false;
							this.itemfor = "leader";
							this.type = 'mystic'; 
							this.bagLocation = '';
							this.detail = owlData.lang.fn( "items", "sekletonSummoner", "detail" ); 
							this.unique = true;
							this.label = scope.uniqueId();
						}
						
					},
					skills : {
						intimidation : function(){
							this.name = 'intimidation';
							this.className = 'roar-of-protection';
							this.displayName = owlData.lang.fn( "skill", "intimidation", "displayName" ); 
							this.type = 'active';
							this.tick = 1800;
							this.tickUpdate = 1800;
							this.mp = 150;
							
							this.defenseRateMax = 25;
							this.defenseRateMin = 25;
							this.blockMax = 25;
							this.blockMin = 25;
							
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "intimidation", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						rollingAttack : function(){
							this.name = 'rollingAttack';
							this.className = 'rolling-attack';
							this.displayName = owlData.lang.fn( "skill", "rollingAttack", "displayName" ); 
							this.type = 'active';
							this.tick = 240;
							this.tickUpdate = 240;
							this.damageMax = 332;
							this.damageMin = 280;
							this.damageType = "vitallity";
							this.mp = 200;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "rollingAttack", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						upperAttack : function(){
							this.name = 'upperAttack';
							this.className = 'upper-attack';
							this.displayName = owlData.lang.fn( "skill", "upperAttack", "displayName" ); 
							this.type = 'active';
							this.tick = 150;
							this.tickUpdate = 150;
							this.mp = 172;
							this.damageMax = 372;
							this.damageMin = 240;
							this.damageType = "vitallity";
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "upperAttack", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						sliceAttack : function(){
							this.name = 'sliceAttack';
							this.className = 'slice-attack';
							this.displayName = owlData.lang.fn( "skill", "sliceAttack", "displayName" ); 
							this.type = 'active';
							this.tick = 150;
							this.tickUpdate = 150;
							this.mp = 150;
							this.damageMax = 1212;
							this.damageMin = 940;
							this.damageType = "vitallity";
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "sliceAttack", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						throwBoom : function(){
							this.name = 'throwBoom';
							this.className = 'throw-boom';
							this.displayName = owlData.lang.fn( "skill", "throwBoom", "displayName" ); 
							this.type = 'active';
							this.tick = 240;
							this.tickUpdate = 240;
							this.stringRequired = "boom";
							this.damageMax = 0;
							this.damageMin = 0;
							this.triggerName = "explosionNormalBoom";
							this.damageType = "vitallity";
							this.mp = 235;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "throwBoom", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						piercingShoot : function(){
							this.name = 'piercingShoot';
							this.className = 'piercing-shoot';
							this.displayName = owlData.lang.fn( "skill", "piercingShoot", "displayName" ); 
							this.type = 'active';
							this.tick = 150;
							this.tickUpdate = 150;
							this.damageMax = 355;
							this.damageMin = 538;
							this.mp = 144;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "piercingShoot", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						piercingSpear : function(){
							this.name = 'piercingSpear';
							this.className = 'piercing-spear';
							this.displayName = owlData.lang.fn( "skill", "piercingSpear", "displayName" ); 
							this.type = 'active';
							this.tick = 600;
							this.tickUpdate = 600;
							this.mp = 211;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.life = 18;
							this.uniqueFrame = "piercingSpear";
							this.selectedFrame = "piercingSpear";
							this.damageType = "vitallity";
							this.speed = 30;
							this.damageMax = 1100;
							this.damageMin = 750;
							this.criticalMax = 70;
							this.criticalMin = 45;
							this.criticalChanceMax = 25;
							this.criticalChanceMin = 15;
							this.detail = owlData.lang.fn( "skill", "piercingSpear", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						piercingSpeed : function(){
							this.name = 'piercingSpeed';
							this.className = 'piercing-spear';
							this.displayName = owlData.lang.fn( "skill", "piercingSpeed", "displayName" ); 
							this.type = 'active';
							this.tick = 400;
							this.tickUpdate = 400;
							this.mp = 121;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.life = 30;
							this.uniqueFrame = "piercingSpeed";
							this.selectedFrame = "attackB";
							this.damageType = "vitallity";
							this.speed = 25;
							this.damageMax = 1120;
							this.damageMin = 865;
							this.detail = owlData.lang.fn( "skill", "piercingSpeed", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						}, 
						createBlue : function(){
							this.name = 'createBlue';
							this.className = 'create-blue';
							this.displayName = owlData.lang.fn( "skill", "createBlue", "displayName" ); 
							this.type = 'active';
							this.tick = 30000;
							this.tickUpdate = 30000;
							this.enemyTolerance = true;
							this.particleParams = {
								cyrcle : "blue-cycle.png",
								ring : "blue-ring.png",
								sizeCyrcle : 75
							};
							this.attackRange = false;
							this.mp = 45;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "createBlue", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						createRed : function(){
							this.name = 'createRed';
							this.className = 'create-red';
							this.displayName = owlData.lang.fn( "skill", "createRed", "displayName" ); 
							this.type = 'active';
							this.tick = 30000;
							this.tickUpdate = 30000;
							this.enemyTolerance = true;
							this.particleParams = {
								cyrcle : "red-ring-cyrcle.png",
								ring : "tower-red-ring.png",
								sizeCyrcle : 120
							};
							this.attackRange = false;
							this.mp = 45;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "createRed", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						arrowRain : function(){
							this.name = 'arrowRain';
							this.className = 'arrow-rain';
							this.displayName = owlData.lang.fn( "skill", "arrowRain", "displayName" ); 
							this.type = 'active';
							this.tick = 900;
							this.tickUpdate = 900;
							this.enemyTolerance = true;
							this.attackRange = false;
							this.damageMax = 132;
							this.damageMin = 76;
							this.damageType = "magic";
							this.mp = 315;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "arrowRain", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						teleportation : function(){
							this.name = 'teleportation';
							this.className = 'teleportation';
							this.displayName = owlData.lang.fn( "skill", "teleportation", "displayName" ); 
							this.type = 'active';
							this.tick = 250;
							this.tickUpdate = 250;
							this.enemyTolerance = true;
							this.attackRange = false;
							this.mp = 145;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "teleportation", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						teleport : function(){
							this.name = 'teleport';
							this.className = 'teleport';
							this.displayName = owlData.lang.fn( "skill", "teleport", "displayName" ); 
							this.type = 'active';
							this.tick = 250;
							this.tickUpdate = 250;
							 
							this.opacityStart = 0.07;
							this.frameStart = "teleport";
							this.frameSkillStart = "die";
							
							this.opacityEnd = 0.05;
							this.frameEnd = "summon";
							this.frameSkillEnd = "summon";
							
							this.mp = 145;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "teleport", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						bloodDrain : function(){
							this.name = 'bloodDrain';
							this.className = 'roar-of-protection';
							this.displayName = owlData.lang.fn( "skill", "bloodDrain", "displayName" ); 
							this.type = 'active';
							this.tick = 1200;
							this.tickUpdate = 1200;
							this.damageMax = 570;
							this.damageMin = 520;
							this.healthConvertion = 100;
							this.mp = 115;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "bloodDrain", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						
						healing : function(){
							this.name = 'healing';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "healing", "displayName" ); 
							this.type = 'active';
							this.tick = 600;
							this.tickUpdate = 600;
							this.healthIncreaseMax = 321,
							this.healthIncreaseMin = 264,
							this.mp = 220;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "healing", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						
						massHealing : function(){
							this.name = 'massHealing';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "massHealing", "displayName" ); 
							this.type = 'active';
							this.tick = 600;
							this.tickUpdate = 600;
							this.healthIncreaseMax = 251,
							this.healthIncreaseMin = 184,
							this.mp = 279;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "massHealing", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						growHowl : function(){
							this.name = 'growHowl';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "growHowl", "displayName" ); 
							this.type = 'active';
							this.tick = 1000;
							this.tickUpdate = 600;
							this.damageIncreaseMax = 60,
							this.damageIncreaseMin = 40,
							this.mp = 253;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "growHowl", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						bodyCharge : function(){
							this.name = 'bodyCharge';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "bodyCharge", "displayName" ); 
							this.type = 'active';
							this.tick = 400;
							this.tickUpdate = 400;
							this.mp = 244;
							this.damageMax = 672;
							this.damageMin = 440;
							this.damageType = "vitallity";
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "bodyCharge", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						bindingRoot : function(){
							this.name = 'bindingRoot';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "bindingRoot", "displayName" ); 
							this.type = 'active';
							this.tick = 990;
							this.tickUpdate = 990;
							this.mp = 188;
							this.reduceMovement = 0.75;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "bindingRoot", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						defenseSteal : function(){
							this.name = 'defenseSteal';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "bindingRoot", "displayName" ); 
							this.type = 'active';
							this.tick = 600;
							this.tickUpdate = 600;
							this.defenseRateMax = 25;
							this.defenseRateMin = 20;
							this.icon = 'defense-steal-small.png';
							this.life = 20;
							this.mp = 124;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "bindingRoot", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						abilitiesSteal : function(){
							this.name = 'abilitiesSteal';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "abilitiesSteal", "displayName" ); 
							this.type = 'active';
							this.tick = 600;
							this.tickUpdate = 600;
							this.avoidMax = 15;
							this.avoidMin = 8;
							this.blockMax = 15;
							this.blockMin = 8;
							this.icon = 'abilities-steal-small.png';
							this.life = 20;
							this.mp = 45;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "abilitiesSteal", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						earthShake : function(){
							this.name = 'earthShake';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "earthShake", "displayName" ); 
							this.type = 'active';
							this.tick = 200;
							this.tickUpdate = 200;
							this.mp = 211;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.damageMax = 420;
							this.damageMin = 350;
							this.damageType = "magic";
							this.detail = owlData.lang.fn( "skill", "earthShake", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						sekletonSummoner : function(){
							this.name = 'sekletonSummoner'; 
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "sekletonSummoner", "displayName" ); 
							this.type = 'active';
							this.tick = 1000;
							this.tickUpdate = 1000;
							this.mp = 232;
							this.state = true;
							this.disable = false;
							this.life = 200;
							this.spawnTick = 25;
							this.selectedSkillFrame = "idle";
							this.initialParams = {
								aiParams : "sekletonSpear",
								spawn : {
									x : 0,
									y : 0
								},
								spawnTotal : 1,
								aIParent : "",
								forceGravity : false,
								maximumPawns : 4
							};
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "sekletonSummoner", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						golemSummoner : function(){
							this.name = 'golemSummoner'; 
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "golemSummoner", "displayName" ); 
							this.type = 'active';
							this.tick = 1000;
							this.tickUpdate = 1000;
							this.mp = 232;
							this.state = true;
							this.disable = false;
							this.life = 200;
							this.spawnTick = 45;
							this.selectedSkillFrame = "skill";
							this.initialParams = {
								aiParams : "golem",
								spawn : {
									x : 0,
									y : 0
								},
								spawnTotal : 1,
								aIParent : "",
								forceGravity : false,
								maximumPawns : 4
							}
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "golemSummoner", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						beresekYeti : function(){
							this.name = 'beresekYeti';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "beresekYeti", "displayName" ); 
							this.type = 'active';
							this.tick = 1200;
							this.tickUpdate = 600;
							this.damageIncreaseMax = 25;
							this.damageIncreaseMin = 15;
							this.speedIncrease =  5.5;
							this.mp = 221;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "beresekYeti", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						earthQuake : function(){
							this.name = 'earthQuake';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "earthQuake", "displayName" ); 
							this.type = 'active';
							this.tick = 600;
							this.tickUpdate = 600;
							this.mp = 143;
							this.target = '';
							this.damageMax = 450;
							this.damageMin = 323;
							this.damageType = "magic";
							this.detail = '';
							this.state = true;
							this.detail = owlData.lang.fn( "skill", "earthQuake", "detail" ); 
							this.label = scope.uniqueId();
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						mindControl : function(){
							this.name = 'mindControl';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "mindControl", "displayName" ); 
							this.type = 'active';
							this.tick = 1000;
							this.tickUpdate = 1000;
							this.mp = 231;
							this.state = true;
							this.disable = false;
							this.life = 200;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "mindControl", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						powerDefenese : function(){
							this.name = 'powerDefenese';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "powerDefenese", "displayName" ); 
							this.type = 'active';
							this.tick = 1200;
							this.tickUpdate = 600;
							this.defenseRateMax = 15;
							this.defenseRateMin = 10;
							this.blockMax = 15;
							this.blockMin = 10;
							this.criticalMax = 0;
							this.criticalMin = 0;
							this.criticalChanceMax = 0;
							this.criticalChanceMin = 0;
							this.icon = 'power-defense-small.png';
							this.mp = 118;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "powerDefenese", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						powerDefeneseII : function(){
							this.name = 'powerDefeneseII';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "powerDefeneseII", "displayName" ); 
							this.type = 'active';
							this.tick = 1200;
							this.tickUpdate = 600;
							this.defenseRateMax = 20;
							this.defenseRateMin = 15;
							this.blockMax = 20;
							this.blockMin = 15;
							this.criticalMax = 113;
							this.criticalMin = 77;
							this.criticalChanceMax = 15;
							this.criticalChanceMin = 10;
							this.icon = 'power-defense-ii-small.png';
							this.mp = 201;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "powerDefeneseII", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						powerDefeneseIII : function(){
							this.name = 'powerDefeneseIII';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "powerDefeneseIII", "displayName" );
							this.type = 'active';
							this.tick = 1200;
							this.tickUpdate = 600;
							this.defenseRateMax = 20;
							this.defenseRateMin = 15;
							this.blockMax = 25;
							this.blockMin = 15;
							this.criticalMax = 245;
							this.criticalMin = 152;
							this.criticalChanceMax = 25;
							this.criticalChanceMin = 15;
							this.icon = 'power-defense-iii-small.png';
							this.mp = 258;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "powerDefeneseIII", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						}, 
						
						powerAgility : function(){
							this.name = 'powerAgility';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "powerAgility", "displayName" );
							this.type = 'active';
							this.tick = 1200;
							this.tickUpdate = 600;
							this.defenseRateMax = 20;
							this.defenseRateMin = 15;
							this.avoidMax = 20;
							this.avoidMin = 10;
							this.criticalMax = 0;
							this.criticalMin = 0;
							this.criticalChanceMax = 0;
							this.criticalChanceMin = 0;
							this.icon = 'power-agility-small.png';
							this.mp = 118;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "powerAgility", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						powerAgilityII : function(){
							this.name = 'powerAgilityII';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "powerAgilityII", "displayName" );
							this.type = 'active';
							this.tick = 1200;
							this.tickUpdate = 600;
							this.defenseRateMax = 25;
							this.defenseRateMin = 20;
							this.avoidMax = 15;
							this.avoidMin = 10;
							this.criticalMax = 101;
							this.criticalMin = 65;
							this.criticalChanceMax = 15;
							this.criticalChanceMin = 10;
							this.icon = 'power-agility-ii-small.png';
							this.mp = 201;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "powerAgilityII", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						},
						powerAgilityIII : function(){
							this.name = 'powerAgilityIII';
							this.className = '';
							this.displayName = owlData.lang.fn( "skill", "powerAgilityIII", "displayName" );
							this.type = 'active';
							this.tick = 1200;
							this.tickUpdate = 600;
							this.defenseRateMax = 25;
							this.defenseRateMin = 20;
							this.avoidMax = 15;
							this.avoidMin = 10;
							this.criticalMax = 225;
							this.criticalMin = 192;
							this.criticalChanceMax = 25;
							this.criticalChanceMin = 15;
							this.icon = 'power-agility-iii-small.png';
							this.mp = 258;
							this.state = true;
							this.disable = false;
							this.label = scope.uniqueId();
							this.target = '';
							this.detail = owlData.lang.fn( "skill", "powerAgilityIII", "detail" ); 
							this.firstLoad = true;
							this.active = true;
							this.slotLocation = '';
							this.level = 1;
						}
						
						
					},
					buffSkills : {
						powerAgilityIII : function( options ){
							this.name = 'powerAgilityIII';
							this.interval = 0;
							this.intervalUpdate = 600;
							this.tick =  600; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						powerAgilityII : function( options ){
							this.name = 'powerAgilityII';
							this.interval = 0;
							this.intervalUpdate = 600;
							this.tick =  600; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						powerAgility : function( options ){
							this.name = 'powerAgility';
							this.interval = 0;
							this.intervalUpdate = 600;
							this.tick =  600; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						powerDefeneseIII : function( options ){
							this.name = 'powerDefeneseIII';
							this.interval = 0;
							this.intervalUpdate = 600;
							this.tick =  600; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						powerDefeneseII : function( options ){
							this.name = 'powerDefeneseII';
							this.interval = 0;
							this.intervalUpdate = 600;
							this.tick =  600; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						powerDefenese : function( options ){
							this.name = 'powerDefenese';
							this.interval = 0;
							this.intervalUpdate = 600;
							this.tick =  600; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						mindControl : function( options ){
							this.name = 'mindControl';
							this.interval = 30
							this.intervalUpdate = 30;
							this.tick =  600; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						bereseker : function( options ){
							this.name = 'bereseker';
							this.interval = 0;
							this.intervalUpdate = 600;
							this.tick =  600; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						defenseSteal : function( options ){
							this.name = 'defenseSteal';
							this.interval = 0;
							this.intervalUpdate = 600;
							this.tick =  600; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						abilitiesSteal : function( options ){
							this.name = 'abilitiesSteal';
							this.interval = 0;
							this.intervalUpdate = 600;
							this.tick =  600; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						healing : function( options ){
							this.name = 'healing';
							this.interval = 50;
							this.intervalUpdate = 50;
							this.tick =  600; // 30 seconds
							this.icon = 'healing-small.png';
							this.chance = options && options.chance || 100;
						},
						massHealing : function( options ){
							this.name = 'massHealing';
							this.interval = 50;
							this.intervalUpdate = 50;
							this.tick =  600; // 30 seconds
							this.icon = 'healingSmall.png';
							this.chance = options && options.chance || 100;
						},
						bindingRoot : function( options ){
							this.name = 'bindingRoot';
							this.interval = 0 // active buff immadietlly
							this.intervalUpdate = 750;
							this.tick =  750;
							this.chance = options && options.chance || 100;
						},
						stunEffect : function( options ){
							this.name = 'stunEffect';
							this.interval = 0
							this.intervalUpdate = 1;
							this.tick =  90; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						
						burningEffect : function( options ){
							this.name = 'burningEffect';
							this.interval = 30
							this.intervalUpdate = 30;
							this.tick =  600; // 30 seconds
							this.chance = options && options.chance || 100;
						},
						growHowl : function( options ){
							this.name = 'growHowl';
							this.interval = 0 // active buff imedietlly
							this.intervalUpdate = 600
							this.tick =  600; // 30 seconds
							this.damageIncreaseMax = options && options.damageIncreaseMax || 25;
							this.damageIncreaseMin = options && options.damageIncreaseMin || 15;
							this.chance = options && options.chance || 100;
						},
						intimidation : function( options ){
							this.name = 'intimidation';
							this.interval = 30;
							this.intervalUpdate = 30;
							this.tick =  1000; // 30 seconds
							this.damageMax = options && options.damageMax || 25;
							this.damageMin = options && options.damageMin || 5;
							this.chance = options && options.chance || 100;
						},
						bloodDrain : function( options ){
							this.name = 'bloodDrain';
							this.interval = 30;
							this.intervalUpdate = 30;
							this.tick =  900; // 30 seconds
							this.chance = options && options.chance || 100;
						}
					}
				}
 
				//formula find milisecond // ? = seconds * 1000 / 25;
				//formula find second // milisecond * 25 / 1000 = ?;
				
				scope.staticWallOutter['value'] = function(){
					var map = 'staticWallOutter'+scope.activeMap['value'];
					return scope[ map ].value;
				}
				
				scope.infoFilter['value'] =  function( index ){
					var elSpan = scope.slice( scope.qs('wrap-box-text').getElementsByTagName('span') );
						
					for(var kk = 0, ll = elSpan.length; kk < ll; kk++){
						scope.addClass( elSpan[kk], 'hidden');
					}
					if( index === 0 ){
						for(var kk = 0, ll = elSpan.length; kk < ll; kk++){
							scope.removeClass( elSpan[kk], 'hidden');
						}
					}else if( index === 2 ){
						for(var kk = 0, ll = elSpan.length; kk < ll; kk++){
							if(/primary-title/i.test( elSpan[kk].className ) ){
								scope.removeClass( elSpan[kk], 'hidden');
							}
						}
					}else if( index === 3 ){
						for(var kk = 0, ll = elSpan.length; kk < ll; kk++){
							if(/regular-title|exp-title/i.test( elSpan[kk].className ) ){
								scope.removeClass( elSpan[kk], 'hidden');
							}
						}
					}
					
				}
				
				
				scope.globalCharacterState["value"] = scope[ scope.oval["value"].stateStorage ]; //replace character stateStorage as reference
				
				//push available gui chara support
				scope.guiSupportAvailable["value"] = ["chara-support-b"]
				
				//scope.characterGetDamage['value'].set( scope.oval['value'].label, [] );	
				
				//scope.characterSkills['value'].set( scope.oval['value'].label, [])
				
				scope.characterSkills['value'].set( 'initial',{
					label : '',
					state : false,
					target : ''
				})
				 
				//scope.characterInventoryBag['value'].set( scope.oval['value'].label, [ ])
				 
				scope.characterParameters['value'] = {
					name : 'oval',
					mainCharacter : true,
					range : 100, //scope.browserWidth() - scope.browserWidth() / 2,
					attackRangeMax : 45,
					attackRangeMin : 31,
					rigBody : '',
					health : 480000,
					maxHealth : 500000,
					maxHealthCure : 490000,
					mp : 1500,
					maxMp : 1500,
					maxMpCure : 1500,
					attackMax : 725,
					attackMin : 415,
					defenseMax : 74,
					defenseMin : 25,
					magicDefenseMax : 35,
					magicDefenseMin : 25,
					buffSkill : {},
					setting : {
						mpPercentage : 100,
						healthPercentage : 100,
						effect : true
					},
					activeSkill :[],
					modifierAbilities : {
						block : 70
					},
					abilitySkill : {
						intimidation : true,
						rollingAttack : true,
						upperAttack :  true,
						sliceAttack :  true
					},
					exp : 0,
					expTemp : 0,
					skillPoint : 0,
					gold : 50000,
					level : 1,
					attackType : 'melee',
					object : scope.oval['value']
				}
 	
				scope.staticWorld['value'] = scope.engine.world;
				
				//starting main quest
				var fpsOut = document.getElementById('fps');
				if( !localStorage.getItem('load') ){
					scope.itemShop['value'].set( 'global', owlData.shop )
					scope.character()// to prevent character execute twice let initialize handle it
					 
					scope.intervalList[ "orerObjManual" ] = {
							always : true,
							tick : 10, // 8 m
							tickUpdate : 10, // 1 s
							fn : function(){
								 
								scope.orderObjectFn['value']();
							}
					}
				
					scope.intervalList[ "updateObjManual" ] = {
							always : true,
							tick : 10, // 8 m
							tickUpdate : 60, // 2 s
							fn : function(){
								   
								scope.monsterControl.triggerMonsterFn('update');
								scope.caracterSkillToogleFn['value']();
								//fpsOut.innerHTML = ( 1000/ scope.frameTime).toFixed(1) + " fps";
							}
					}
					
					
				}
				
				
			}

	}	


	_owlBird.GUI = function( _obj )
	{
		var scope = this;

		scope['fn'] = new _obj.utils;

		var obj = {
			path: "assets/2d/",
		};

		for(var ii in obj) _obj[ii] = obj[ii];

		for(var ii = arguments, jj = ii.length; jj--;)
		{
			if('function' === typeof ii[jj])
			{
				ii[jj].apply(null, [scope, _obj])
				ii[jj].apply(null, [scope, obj])
				
				
				scope.controllers();
				scope.bagAndSkill();
				
				scope.mouseCreate( document.body );
			}
		}

	}

	_owlBird.GUI.prototype = {
		controllers : function(){
			var scope = this,
			jump = scope.qs('jump-right-nav'),
			attack = scope.qs('attack-right-nav'),
			menuMap =  scope.slice( scope.qs('menu-map').getElementsByTagName('li') ),
			menuMapMb = scope.slice( scope.qs('menu-map-mobile').getElementsByTagName('li') ),
			menuMapCnt = menuMap.concat( menuMapMb ),
			guiTowerDef = scope.qs("gui-tower-def"),
			btnNewGame = scope.qs('menu-ui-left'), 
			btnSaveGame = scope.qs('menu-ui-right'),
			closeQsDialog = scope.qs('close-dialog'),
			gui =  scope.qs('gui-player'),
			init = {
				outterObj : scope.qs('outter'),
				innerObj : scope.qs('inner'),
				move : false,
				pointRad : {},
				angle : 0,
				offset : {
					top : 0,
					left : 0
				}
			},
			 
			obj = {
				getControlRad : function( init ){ 
					var boundsCtr = init.outterObj.getBoundingClientRect();
					init.pointRad.x = boundsCtr.left + ( boundsCtr.width / 2 );
					init.pointRad.y = boundsCtr.top + ( boundsCtr.height / 2 );
					init.offset.left = boundsCtr.left ;
					init.offset.top = boundsCtr.top;
					init.outterWidth =  init.outterObj.offsetWidth;
					init.innerWidth =  init.innerObj.offsetWidth;
				},
				
				getPointRad : function( angle )
				{
					return {
					  x: Math.cos( angle ),
					  y: Math.sin( angle )
					};
				},
				getAngle : function( lengthX, lengthY )
				{
					if ( lengthX === 0 && lengthY === 0 ) return init.angle;
					
					var angle = Math.atan( lengthY / lengthX );

					if ( 0 > lengthX && 0 <= lengthY ) {
					  //the second quadrant
					  angle += Math.PI;

					} else if ( 0 > lengthX && 0 > lengthY ) {
					  //the third quadrant
					  angle += Math.PI;

					} else if ( 0 <= lengthX && 0 > lengthY ) {
					  //the fourth quadrant
					  angle += Math.PI * 2;

					}
					init.angle = angle;
					return angle;
				},
				
				isInside : function( distance, diameter ){
					return distance <= diameter / 2
				},
				setBtnPosition : function( x, y, init ){
					var  rInner = init.innerWidth / 2;
					scope.css( init.innerObj , {
						'top': ( init.offset.top - rInner - init.innerWidth + 5 ) + init.outterWidth - y * init.outterWidth / 2 /** for 135px size outter add - rInner  */ +'px', 
						'left': ( init.offset.left - rInner - 30 )  + init.outterWidth + x * init.outterWidth / 2 /** for 135px outter size add - rInner  */ +'px', 
						'position' : 'fixed'
					});
				},
				
				setIdle : function( dir, state, clearUpDown ){
					
					var xPos = scope.browserWidth() / 2,
					xClient = scope.mousePosition['value'].pos.mousedown.x;
					 
					if( xClient < xPos ){
					
						var mobileCtr = scope.characterMobileControl['value'],
						fn = function(){
							var charState = scope.oval['value'].stateStorage,
							charLabel = scope.oval['value'].label;
							
							if( scope.isMobile() ) {
								if( dir !== 'up') scope.objTranslate['value'].moveUp =  false;
								if( dir !== 'down') scope.objTranslate['value'].moveDown =  false;
								if( dir !== 'left' ) scope.objTranslate['value'].moveLeft =  false;
								if( dir !== 'right' ) scope.objTranslate['value'].moveRight =  false;
								if( dir !== 'left' ) mobileCtr.charObj.moveLeft = false;
								if( dir !== 'right' ) mobileCtr.charObj.moveRight = false;
								if( dir !== 'up') mobileCtr.charObj.moveUp = false;
								if( dir !== 'down') mobileCtr.charObj.moveDown = false;
								
								if( dir === 'right' ) mobileCtr.charObj.dirSwitch.right = true;
								if( dir === 'left' ) mobileCtr.charObj.dirSwitch.left = true;
								
								mobileCtr.firstTouch = false; //reset
								
								if( /idle|die/i.test( dir ) ){
									/idle/i.test( dir ) && scope.globalCharacterState['value'].set( charLabel, 'idle' );
								}
								mobileCtr.status = state
							}
						}
						
						if( clearUpDown ){
							scope.objTranslate['value'].moveUp =  false;
							scope.objTranslate['value'].moveDown =  false;
							mobileCtr.charObj.moveUp = false;
							mobileCtr.charObj.moveDown = false;
							
						}
						
						if( dir !== mobileCtr.status ){
							fn( dir )
						}
					
					}
					
				},
			
				control : function( dir ){
					var mobileCtr = scope.characterMobileControl['value'],
					dirSwitch = mobileCtr.charObj.dirSwitch;
					
					if( !mobileCtr.mobileCtr ){
						mobileCtr.charObj.dirSwitch.delayDir = 1;
						mobileCtr.firstTouch = true;
					}
					
					if( dir === 'left' ){
						if( !mobileCtr.charObj.moveLeft ){
							scope.objTranslate['value'].moveLeft = true
							mobileCtr.charObj.moveLeft = true;
						}
					}else if( dir === 'right' ){
						if( !mobileCtr.charObj.moveRight ){
							scope.objTranslate['value'].moveRight = true
							mobileCtr.charObj.moveRight = true;
						}
						
					}else if( dir === 'up' ){
						if( !mobileCtr.charObj.moveUp ){
							scope.objTranslate['value'].moveUp = true
							mobileCtr.charObj.moveUp = true;
						}
					}else if( dir === 'down' ){
						if( !mobileCtr.charObj.moveDown ){
							scope.objTranslate['value'].moveDown = true
							mobileCtr.charObj.moveDown = true;
						}
					}
					
					
				},
				centerMap : function( objMap ){
					if( objMap.mark === 6 ) {
						objMap.centerMap.x = -10;
						objMap.centerMap.y = 55;
						objMap.centerMark.x = 0;
						objMap.centerMark.y = 25;
					}else if( objMap.mark === 8 ){
						objMap.centerMap.x = 40;
						objMap.centerMap.y = 0;
						objMap.centerMark.x = 25;
						objMap.centerMark.y = 35;
					}else if( objMap.mark === 10 ){
						objMap.centerMap.x = 85;
						objMap.centerMap.y = -62;
						objMap.centerMark.x = 40;
						objMap.centerMark.y = 45;
					};
				},
				
				inMobleControl : function( pos ){
					
					if( !scope.isMobile() ) return false;
					
					
					var boundsBody = document.body.getBoundingClientRect(),
					bounds = {};
					bounds.max = {};
					bounds.min = {};
					
					bounds.max.x = boundsBody.right / 4;
					bounds.min.x = 0;
					bounds.max.y = boundsBody.bottom;
					bounds.min.y = boundsBody.bottom / 2;
		
					if( pos.x > bounds.min.x && pos.x < bounds.max.x && pos.y > bounds.min.y && pos.y < bounds.max.y ){
						
						
						var outterWidth = init.outterWidth ? init.outterWidth : 102;
					 
					 
						init.outterObj.style.marginLeft = pos.x - outterWidth / 2 +'px';
						init.outterObj.style.marginTop = pos.y - boundsBody.bottom - outterWidth / 2 + 5 +'px';
						scope.removeClass( init.innerObj, "center" );
						scope.removeClass( init.outterObj, "hidden" );
						scope.addClass( scope.qs("controller-appear"), "hidden" )
						init.move = true;
					}
				},
				 
				initControl : function( init ){
					obj.getControlRad( init )
					var posX = scope.mousePosition['value'].pos.mousemove.x ,
					posY = scope.mousePosition['value'].pos.mousemove.y,
					vecInner = scope.distanceAndAngleBetweenTwoPoints( init.pointRad.x, init.pointRad.y, posX, posY ),
					r = init.outterWidth / 2,
					x = (   ( posX - init.offset.left + r  ) - init.outterWidth ) / init.outterWidth * 2,
					y = ( - ( posY - init.offset.top + r ) + init.outterWidth ) / init.outterWidth * 2,
					radian =  obj.getAngle( x, y ),
					degree =  radian * ( 180/ Math.PI );
					
					
					if( obj.isInside( vecInner.distance, init.outterWidth ) ){
						scope.css( init.innerObj, {
							'top': posY  +'px',
							'left':  posX  +'px',
							'position' : 'fixed'
						});
						
					}else{
						//get relative pos to outter box
						var pointRad = obj.getPointRad( radian );
						obj.setBtnPosition( pointRad.x, pointRad.y, init );
					}
					
					return {
						radian : radian,
						degree : degree,
						pos : {
							x : posX,
							y : posY
						}
					};
				},
				removeMarkerMonster : function( name ){
					var allBodies = scope.globalEngine['value'].world.bodies;
					for(var ii = 0; ii < allBodies.length ; ii++ ){
						if( /controlRight/i.test( allBodies[ii].label ) ){
							scope.globalWorld['value'].remove( scope.globalEngine['value'].world, allBodies[ii] );
						}
					}
				}
				
			};
			 
			scope.attachListener( scope.qs('credit-close'), 'click', function( e ){ 
				scope.addClass( scope.nthParent( this, 2 ), 'hidden' );
			})
			 
			for( var ii = 0, btns = scope.slice( scope.qsAll('loading-header li') ); ii < btns.length ; ii++ ){
				scope.attachListener( btns[ii], 'click', function( index, activeEl ){
					
					scope.playAudio('tab-selected')
					
					if( index === 2 ){
						scope.removeClass( scope.qs('credit-alert'), 'hidden' );
					}else if( index === 1 ){
						
						scope.fullscreenToogle( activeEl )
						
					}else if( index === 0 ){
						
						this.toggleButton( true )
						
						if( /off/i.test( activeEl.className ) ){
							activeEl.className = "speaker-on";
							scope.objTranslate['value'].volume = true;
							scope.globalObjectGUI["value"].audioBackground.setVolume("on");
							
						}else{
							activeEl.className = "speaker-off";
							scope.globalObjectGUI["value"].audioBackground.setVolume("off");
							scope.objTranslate['value'].volume = false;
						}
					}
				}.bind( this, ii, btns[ii]))
			}
			 
			scope.scrollSlide();
			//btn save and load game ui
			
			scope.attachListener( btnNewGame, 'click', function( e ){ 
				//localStorage.setItem( 'load', scope.JSONstringfy( owlDATA.jsonData ) );
				//location.reload();
				//scope.addClass( this.parentNode, 'hidden' )
				//scope.globalLoadGame['value']('mapDungeonG')

				scope.playAudio('tab-selected')
					
				scope.audioBackground.fn("start");
				scope.addClass( scope.qs('loading-ui'), 'hidden');
				scope.removeClass( guiTowerDef, 'hidden' );
			})
			
			scope.attachListener( btnSaveGame, 'click', function( e ){ 
				if( /expand/i.test( this.className ) ){
					scope.css( scope.qs('menu-save') , { 
						'width': '0px', 
						'transition' : 'width 450ms ease-in-out'
					})
					scope.css( this , { 
						'transform': '0px,0px,0px', 
						'transition' : 'transform 450ms ease-in-out'
					})
					scope.removeClass( this, 'expand')
				}else{
					
					scope.css( scope.qs('menu-save') , { 
						'width': '250px', 
						'transition' : 'width 450ms ease-in-out'
					})
					scope.css( this , { 
						'transform': '170px,0px,0px', 
						'transition' : 'transform 450ms ease-in-out'
					})
					scope.addClass( this, 'expand')
				}
				
			})
			
			//quest text
			scope.attachListener( closeQsDialog, 'click', function( e ){ 
				scope.addClass( scope.nthParent( this, 2 ), 'hidden' )
			})
			 
			//info txt & box quest
			var rectInfo = scope.qs('info-text').getBoundingClientRect(),
			rectQuest = scope.qs('init-box').getBoundingClientRect(),
			rectBrowser = document.body.getBoundingClientRect();
			scope.qs('info-text').style.height = ( rectBrowser.bottom - rectInfo.top ) / 1.5+'px';
			scope.qs('init-box').style.maxHeight = ( rectBrowser.bottom - rectQuest.top ) / 2 +'px';
			
			var elInfo = scope.slice(scope.qs('nav-info-text').getElementsByTagName('div'));
			for(var ii = 0, jj = elInfo.length; ii < jj; ii++ ){
				if( /checkbox/i.test( elInfo[ii].className ) ){	
					scope.attachListener( elInfo[ii], 'click', function( element, index ){
						element.appendChild( scope.qs('check') )
						scope.infoFilter['value']( index )
						
					}.bind(this, elInfo[ii], ii ) )
				}
			}
			
			//mini map mobile
			scope.attachListener( scope.qs('mini-map-mobile'), 'click', function( index ){
				if( /hidden/i.test( scope.qs('menu-map-mobile').className ) ){
					scope.removeClass( scope.qs('menu-map-mobile'), 'hidden' )
					scope.removeClass( scope.qs('box-map'), 'hidden' )
					var scaleMap = scope.scaleMap['value'];
					if(scaleMap ){
						scope.qs('progress-exp').style.marginTop = '180px';
						scope.qs('progress-exp').style.marginRight = '0';
						scaleMap.close = false;
					}
				}else{
					scope.addClass( scope.qs('menu-map-mobile'), 'hidden' )
				}
			})
			
			//mini map desktop
			scope.attachListener( scope.qs('mini-map'), 'click', function( index ){
				var scaleMap = scope.scaleMap['value'];
				this.style.display = 'none';
				scope.removeClass( scope.qs('box-map'), 'hidden' )
				scope.qs('menu-map').style.display = 'block';
				if( !scope.isMobile() ) scope.qs('info-menu').style.display = 'block';
				scope.qs('progress-exp').style.marginTop = '180px';
				scope.qs('progress-exp').style.marginRight = '0';
				scaleMap.close = false;
			})
			
			for( var ii = 0, jj = menuMapCnt.length; ii < jj; ii++ ){
				scope.attachListener( menuMapCnt[ii], 'click', function( index ){
					var scaleMap = scope.scaleMap['value'];
					if( ( index === 0 || index === 5 ) ){
						scaleMap.close = true;
						if( index === 5){
							scope.addClass( scope.qs('menu-map-mobile'), 'hidden');
							scope.removeClass( scope.qs('mini-map-mobile'), 'hidden')
						}else{
							scope.qs('menu-map').style.display = 'none';
							scope.qs('mini-map').style.display = 'block';
							scope.qs('info-menu').style.display = 'none';
							
						}
						
						scope.addClass( scope.qs('box-map'), 'hidden' )
						scope.qs('progress-exp').style.marginTop = '-5px';
						scope.qs('progress-exp').style.marginRight = '55px';
					}else if( ( index === 2 || index === 3 ) && scaleMap.mark > 6){
						scaleMap.map -= 0.5;
						scaleMap.mark -= 2;
						obj.centerMap( scaleMap )
						
					}else if( ( index === 1 || index === 4 ) && scaleMap.mark < 10 ){
						scaleMap.map += 0.5;
						scaleMap.mark += 2;
						obj.centerMap( scaleMap )
					}
				}.bind( this, ii ) )
			}
			
			//attack mobile
			scope.attachListener( attack, "click", function( event ){
				var charObj = scope.characterMobileControl['value'].charObj;
				charObj.findTargetToAttack()
				
			})
			
			
			scope.attachListener( jump, scope.CursorStartEvent, function( event ){
				if( scope.oval['value'].forceGravity ){
					scope.characterMobileControl['value'].charObj.jump = true;
				}
			})
			
				
			scope.attachListener( document, scope.CursorStartEvent , function( event ){
				if( /hidden/i.test( gui.className ) ){
					obj.inMobleControl( scope.mousePosition['value'].pos.mousemove );
				}
			 
			})
		

			scope.attachListener( document.body, scope.CursorMoveEvent, function( e ){
				var status = scope.globalCharacterState['value'].storage[0].status;
				if( status !== 'die' ){
					  
					if( init.move && /hidden/i.test( gui.className )){
						
						obj.getControlRad( init )
						
						var mobileCtr = scope.characterMobileControl['value'].charObj;
						
						var objCOntrol = obj.initControl( init ),
						degree =  objCOntrol.degree,
						radian = objCOntrol.radian,
						lengthDirX = Math.abs ( Math.cos ( radian ) * mobileCtr.moveReplaceX ),
						lengthDirY = Math.abs ( Math.sin ( radian ) * mobileCtr.moveReplaceY );
						
						if( !self.objTranslate.isCenter.state ){
						
							mobileCtr.objTranslate.staticObjMoveX = lengthDirX;
							mobileCtr.objTranslate.staticObjMoveY = lengthDirY;
						
						}
						
						if( degree >= 90 && degree <= 180  ){
							obj.setIdle('left','left')
							obj.control('left')
							obj.control('up')
							mobileCtr.changeDir("left")
						}else if( degree >= 0 && degree < 90 ){
							obj.setIdle( 'right', 'right', true );
							obj.control('right')
							obj.control('up')
							mobileCtr.changeDir("right")
						}else if( degree >= 180 && degree <= 270 ){
							obj.setIdle( 'down', 'down' );
							obj.control('left')
							obj.control('down')
							mobileCtr.changeDir("left")
						}else if( degree >= 270 && degree <= 360 ){
							obj.setIdle( 'right', 'right', true );
							obj.control('right')
							obj.control('down')
							mobileCtr.changeDir("right")
						}
						 
						
						
					}
				}else{
					obj.setIdle( 'die' );
				}
			})
			
		
			scope.attachListener( document.body, scope.CursorEndEvent , function( event ){
					var status = scope.globalCharacterState['value'].storage[0].status;
					if( status === 'die' ){
						obj.setIdle( 'die' ) 
					}else{
						 !scope.characterMobileControl['value'].charObj.jump && obj.setIdle( 'idle' );
					}
					
					init.innerObj.setAttribute('style', '') 
					scope.addClass( init.outterObj, "hidden" );
					window.scope.virtualControl && scope.removeClass( scope.qs("controller-appear"), "hidden" )
					init.move = false; 
					
			})
		},
		bagAndSkill : function(){
			setTimeout( function(){
				var scope = this,
				bagA = scope.bagLoot.getElementsByTagName('div')[0],
				magicBox = scope.slice( scope.qs('passive-magic').getElementsByTagName('li') ),
				enchantSlots =  scope.slice( scope.qs('body-box').getElementsByTagName('div') ),
				slots = scope.slice( scope.bagLoot.getElementsByTagName('li') )
							.concat( [ scope.slotButtonHp, scope.slotButtonMp ] )
							.concat( magicBox )
							.concat( enchantSlots ),
				activeSlotSkill = [ scope.slotSkillA , scope.slotSkillB, scope.slotSkillC, scope.id('slot-skill-i') , scope.id('slot-skill-j'), 
				scope.id('slot-skill-k'), scope.id('slot-skill-l'), scope.id('slot-skill-m'), scope.id('slot-skill-n'), scope.id('slot-skill-o'),
				scope.id('slot-skill-p'), scope.id('slot-skill-q') ],
				passiveSlotSkill = scope.slice( scope.slotPassiveSkill.getElementsByTagName('li') ),
				allSkill = activeSlotSkill.concat( passiveSlotSkill ),
				detailSkills = scope.slice( scope.qs('list-skills').getElementsByTagName('li') ),
				containerSkill = scope.qs('container-skill'),
				slotSkills = scope.slice( scope.skillBox.getElementsByTagName('li') )
							.concat( activeSlotSkill )
							.concat( passiveSlotSkill )
							.concat( detailSkills ),
				localStorage =  window.localStorage,
				switchBtn = scope.qs('switch-right-nav'),
				navRight = scope.qsAll('nav-right'),
				gui =  scope.qs('gui-player'),
				skillBox = scope.skillBox,
				skillPoint = scope.qs('skill-point'),
				soulPoint = scope.qs('soul-point'),
				upgradeContent = scope.qs('upgrade-msg'),
				saveContent = scope.qs('save-msg'),
				loadContent = scope.qs('load-msg'),
				loadAlert = scope.qs('load-alert'),
				loadAlertBtn = scope.qs('load-alert').getElementsByTagName('button'),
				upgradeHeader = scope.qs('upgrade-header'),
				upgradeAlert = scope.qs('upgrade-alert'),
				alertButtons = scope.qs('upgrade-alert').getElementsByTagName('button')[0],
				upgradeButtons = scope.qs('upgrade-msg').getElementsByTagName('button'),
				saveButtons = scope.qs('save-msg').getElementsByTagName('button'),
				loadButtons = scope.qs('load-msg').getElementsByTagName('button'),
				upgradeDetail = scope.qs('upgrade-msg').getElementsByTagName('p')[1],
				staticDetail = scope.qs('static-detail'),
				controlDetail = scope.slice(scope.qs('control-container-detail').getElementsByTagName('div')) ,
				controlMenu = scope.qs('main-config').getElementsByTagName('li'),
				saveCnt = scope.qs('save-detail-cnt'),
				saveMenu = scope.qs('menu-save').getElementsByTagName('ul')[0],
				saveAlert = scope.qs('save-alert'),
				saveAlertBtn = scope.qs('save-alert').getElementsByTagName('button')[0], 
				dropMenu =  scope.qs('drop-alert'),
				dropBtnClose = dropMenu.getElementsByTagName('button')[0],
				dropBtnDone = dropMenu.getElementsByTagName('button')[1],
				sortCutBtn = scope.slice( scope.qs('button-small').getElementsByTagName('div') ),
				sortCutnBtnMb =  scope.slice( scope.qs('hidden-menu').getElementsByTagName('li') ),
				btnMonsterParams = scope.qs('box-level'),
				monsterParamsDialog = scope.qs('monster-params'),
				monsterParamsDialogClose = monsterParamsDialog.getElementsByTagName('button')[0],
				miningButton = scope.qs("mining-button"),
				miningDialog = scope.qs('mining-box'),
				miningBtnClose = miningDialog.getElementsByTagName('button')[0],
				shopDialog = scope.qs('shop-box'),
				shopBtnClose = shopDialog.getElementsByTagName('button')[0],
				shopOpen = scope.qs('shop'),
				buyBox = scope.qs('buy-box'),
				buyBoxBtnClose = scope.qs('buy-box').getElementsByTagName('button')[0],
				lanscapeBox = scope.qs('orientation-alert'),
				lanscapeBtnClose = lanscapeBox.getElementsByTagName('button')[0],
				sortCutnExpand = sortCutnBtnMb[0],
				sortCutBtnBagMb = sortCutnBtnMb[1],
				sortCutBtnSkillMb = sortCutnBtnMb[2],
				sortCutBtnQuestMb = sortCutnBtnMb[3],
				sortCutBtnControlMb = sortCutnBtnMb[4],
				sortCutBtnControl = sortCutBtn[0],
				sortCutBtnQuest = sortCutBtn[1],
				sortCutBtnSkill = sortCutBtn[2],
				sortCutBtnBag = sortCutBtn[3],
				sortCutFullscreen = sortCutBtn[4],
				sortCutSpeaker = sortCutBtn[5],
				sortCutAutoSkill = sortCutBtn[6],
				sortCutAutoSwitch = sortCutBtn[7],
				formula,
				bags = scope.slice( scope.qs('menu-bag-bottom').getElementsByTagName('li') ).slice( 2, 5), 
				
				//prevent error when user play on desktop
				hpSlotMb = scope.slotButtonMp,
				mpSlotMb = scope.slotButtonHp,
				
				isMobile = scope.isMobile();
				
				
				//parameters will change when mobile is detected
				if( isMobile ){ 
				
					magicBox = scope.slice( scope.qs('items-equipment-mb').getElementsByTagName('li') ),
					potions = scope.slice( scope.qs('items-hidden-potion-mb').getElementsByTagName('li') ),
					itemsBag = scope.slice( scope.qs('items-bag-mb').getElementsByTagName('li') ),
					slots = itemsBag
						.concat( magicBox )
						.concat( enchantSlots )
						.concat( potions ),
					bags =  scope.slice( scope.qs('control-itembg-mb').getElementsByTagName('div') ),
					staticDetail = scope.qs('wrap-item-info-mb'),
					gui = scope.qs('gui-player-mb'),
					hpSlotMb = potions[0],
					mpSlotMb = potions[1],
					skillPoint = scope.qs('skill-point-mb'),
					soulPoint = scope.qs('soul-point-mb'),
					slotSkillActiveMb = scope.slice( scope.qs('items-slot-skill-mb').getElementsByTagName('li') ),
					detailSkills = scope.slice( scope.qs('items-skill-mb').getElementsByTagName('li') ),
					allSkill = activeSlotSkill
							.concat( passiveSlotSkill )
							.concat( slotSkillActiveMb ),
					slotSkills = scope.slice( scope.skillBox.getElementsByTagName('li') )
							.concat( activeSlotSkill )
							.concat( passiveSlotSkill )
							.concat( detailSkills )
							.concat( slotSkillActiveMb ),
					saveCnt = scope.qs('save-detail-cnt-mb'),
					sortCutAutoSkill = scope.qs("auto-skill-nav"),
					sortCutAutoSwitch = scope.qs('auto-switch-nav');
					
					//replace font dialog to mobile
					var boxDialogs = scope.slice( scope.qsAll('sc-confirm') );
					
					//move upgrader box to mobile
					scope.addClass( scope.qs('upgrader-box'), 'mobile')
					scope.qs('cnt-bag-mb').insertBefore( scope.qs('upgrader-box'), scope.qs('cnt-bag-mb').firstChild );
					
					for(var ii = 0, jj = boxDialogs.length; ii < jj ; ii++ ){
						scope.addClass( boxDialogs[ii], 'mobile')
					}
					
					
					//layout box monster
					var height = document.getElementsByTagName('html')[0].getBoundingClientRect().height - 55;
					scope.css( scope.qs('monster-content') , { 
						'height': height +'px' 
					})
					
					
					//monster-content
					
				}
				
			
				var obj = {
					formula : { // for magicFormula 
						operators : {
							'+': function(a, b) { return a + b },
							'-': function(a, b) { return a - b },
						},
						removeNotExistObjectinItem : function( objParams ){
							//remove register label in item by object label if object not exist
							var allBody = scope.globalEngine['value'].world.bodies;
							self : for(var ii = 0, jj = objParams.item.registered.length; ii < jj; ii++){
								for(var kk = 0, ll = allBody.length; kk < ll; kk++){
									if( objParams.item.registered[ii] === allBody[kk].label ){
										continue self;
									}
								}
								objParams.item.registered.splice( ii, 1);
							}
						},
						
						isObjectRegistered : function( item, target, init, toggle ){
							for(var ii = 0, jj = item.registered.length; ii < jj; ii++){
								if( init === 'check' && item.registered[ii] === target ){
									if( toggle ==='attach' ) return false;
									else  return true;
								}else if( init === 'delete' && item.registered[ii] === target ){
									item.registered.splice( ii , 1 )
									break;
								}
							}
							return true;
						},
						require : function( objParams, targetLabel, targetParams ){
							if( this.isObjectRegistered( targetParams.item, targetLabel, 'check', targetParams.status ) ){
					
								if( !objParams.originalParams ){
									objParams.originalParams = {};
									scope.extend( objParams.originalParams, objParams , true)
								};
								
								if( !objParams.modifierAbilities ){
									objParams.modifierAbilities = {};
								};
								
								if( targetParams.status === 'detached' ){
									this.isObjectRegistered( targetParams.item, targetLabel, 'delete' );
								}else{
									
									//check label aleardy registered
									
									var reg = true,
									regList = targetParams.item.registered;
									for(var ii = 0, jj = regList.length; ii < jj; ii++){
										if( regList[ii] === targetLabel ){
											reg = false;
											break;
										}
									}
									
									reg && targetParams.item.registered.push( targetLabel );
									
								}
								
								return true;
							}
							return false;
						},
						stunOrCriticalChange : function( objParams, targetLabel, targetParams, init  ){
							if( this.require( objParams, targetLabel, targetParams ) ){
								var op = targetParams.status === 'attached' ? '+' : '-';
								if( targetParams.status === 'attached' ){
									if( !objParams.modifierAbilities[ init ] ){
										var newObj = {}
										newObj[ init ] = targetParams.prop.value;
										scope.extend( objParams.modifierAbilities, newObj , true)
									}else{
										objParams.modifierAbilities[ init ]  = this.operators[ op ]( objParams.modifierAbilities[ init ] , targetParams.prop.value );
									}
								}else{
									
									objParams.modifierAbilities[ init ]  = this.operators[ op ]( objParams.modifierAbilities[ init ] , targetParams.prop.value );
								}
							}
							 
							
						},
						defenseChange : function( objParams, targetLabel, targetParams ){
							if( this.require( objParams, targetLabel, targetParams ) ){
								var defMax  = objParams.originalParams.defenseMax,
								defMin  = objParams.originalParams.defenseMin, 
								op = targetParams.status === 'attached' ? '+' : '-';
								objParams.defenseMax = this.operators[ op ]( objParams.defenseMax, defMax * targetParams.prop.value / 100 );
								objParams.defenseMin = this. operators[ op ]( objParams.defenseMin, defMin * targetParams.prop.value / 100 );
							}
						},
						magicDefenseChange : function( objParams, targetLabel, targetParams ){
							if( this.require( objParams, targetLabel, targetParams ) ){
								var defMax  = objParams.originalParams.magicDefenseMax,
								defMin  = objParams.originalParams.magicDefenseMin, 
								op = targetParams.status === 'attached' ? '+' : '-';
								objParams.magicDefenseMax = this.operators[ op ]( objParams.magicDefenseMax, defMax * targetParams.prop.value / 100 );
								objParams.magicDefenseMin = this. operators[ op ]( objParams.magicDefenseMin, defMin * targetParams.prop.value / 100 );
								
							}
						},
						attackChange : function( objParams, targetLabel, targetParams ){
							if( this.require( objParams, targetLabel, targetParams ) ){

								var atkRngMax  = objParams.originalParams.attackRangeMax,
								atkRngMin  = objParams.originalParams.attackRangeMin, 
								atkMax  = objParams.originalParams.attackMax,
								atkMin  = objParams.originalParams.attackMin,
								op = targetParams.status === 'attached' ? '+' : '-';
								objParams.attackRangeMax = this.operators[ op ]( objParams.attackRangeMax, atkRngMax * targetParams.prop.value / 100 );
								objParams.attackRangeMin = this. operators[ op ]( objParams.attackRangeMin, atkRngMin * targetParams.prop.value / 100 );
								objParams.attackMax = this.operators[ op ]( objParams.attackMax, atkMax * targetParams.prop.value / 100 );
								objParams.attackMin = this.operators[ op ]( objParams.attackMin, atkMin * targetParams.prop.value / 100 );
								
							}
						},
						initControl:function( charaterParams, charaterLabel, params ){
							 
							switch( params.init ) {
								case 'attack': this.attackChange( charaterParams, charaterLabel, params ); break;
								case 'defense': this.defenseChange( charaterParams, charaterLabel, params ); break;
								case 'magicDefense': this.magicDefenseChange( charaterParams, charaterLabel, params ); break;
								case 'stun': this.stunOrCriticalChange( charaterParams, charaterLabel, params, 'stun' ); break;
								case 'critical': this.stunOrCriticalChange( charaterParams, charaterLabel, params, 'critical' ); break;
								case 'criticalChance': this.stunOrCriticalChange( charaterParams, charaterLabel, params, 'criticalChance' ); break;
								case 'avoid': this.stunOrCriticalChange( charaterParams, charaterLabel, params, 'avoid' ); break;
								case 'block': this.stunOrCriticalChange( charaterParams, charaterLabel, params, 'block' ); break;
							}
						}
					},
					autoUpdateEffectItemLeader : function(){
						var regItems =  scope.registerMagicBoxItem['value'].storage,
						pawns = scope.globalAnimation["value"].characterControl.bossObject.pions;
						
						for( var ii = 0, jj = regItems.length ; ii < jj ; ii++ ){
							var item = regItems[ii].status;
							 
							if( item.itemfor === "leader" ){//check item leader
							
								var regItem = item.registered;
								
								//recheck every pawn is registered or not
								for( var kk = 0, ll = pawns.length ; kk < ll ; kk++ ){
									
									var pawnIsReg = false,
									pawnObj = pawns[kk];
									
									for( var mm = 0, nn = item.registered ; mm < nn.length ; mm++ ){
										if( nn[mm] === pawnObj.label ){
											pawnIsReg = true;
										}
									
									}
									
									//this pawn is not registered
									//then register this pawn to its item 
									if( !pawnIsReg ){
										 
										for( var oo in item.effect ){
											var effect = item.effect[oo];
											this.formula.initControl( pawnObj.statParameters, pawnObj.label, {
												init : oo,
												prop : effect,
												label : item.label,
												item : item,
												status : "attached"
											});
										}
										
									}
								}
								
								
							}
						}
						
						
					},
					
					magicFormula : function( params ){
						var formula = this.formula,
						effected = params.prop,
						charaterParams = scope.characterParameters['value'],
						pions = scope.oval['value'].pions;
						for(var ii = 0, jj = effected.target.length; ii < jj ; ii++ ){
							if( effected.target[ii] === 'character' ){
								
								formula.initControl( charaterParams, charaterParams.object.label, params );
								
							}else if( effected.target[ii] === 'pion' && pions.length ){
									
								for(var mm = 0; mm < pions.length ; mm++ ){
									formula.initControl( pions[mm].rigBody.monsterParameters, pions[mm].rigBody.label, params );
								}
								
							}
						}
						 
						//register to active magic box
						( params.status === 'attached' ) && scope.registerMagicBoxItem['value'].set( params.item.label, params.item )
					
					},
					
					getSkillByProperty : function( prop, init ){
						var skills = scope.characterSkills['value'].get( scope.oval["value"].label  );
						for(var ii in skills ){
							for(var jj in skills[ii] ){
								if( skills[ii][jj] === prop && init === jj ){
									return skills[ii]
								}
							}
						} 
					},
					
					checkAndRegisterItem : function( magicItem, status, slotId ){
						var  loot = scope.characterInventoryBag['value'].get( scope.oval['value'].label ),
						registerMagicBox = scope.registerMagicBoxItem['value'];
						
						for(var kk = 0,  ll = loot.length; kk < ll; kk++ )
						{		
							if( status === 'detached' || function(){
								for(var ii = 0, jj = registerMagicBox.storage.length; ii < jj; ii++ ){
									if(  loot[kk] && registerMagicBox.storage[ii].name === loot[kk].label ){
										return false;
									}
								}
								return true;
							}()){ 
							
								if( loot[kk] && loot[kk].label === magicItem && loot[kk].unique ){
									
									//fetch box magic effect
									loot[kk].bagLocation = slotId;
									for( var mm in loot[kk].effect ){
										var effect = loot[kk].effect[mm];
										this.magicFormula({
											init : mm,
											prop : effect,
											label : loot[kk].label,
											item : loot[kk],
											status : status
										})
									}
						
									break;
								}			
							}	
						
						}
					},
					magicBox : function( slotId ){
						 
						//attaching and registering items
						var registerMagicBox = scope.registerMagicBoxItem['value'],
						checkItemOwner =  function( label ){
							var loot = scope.characterInventoryBag['value'].get( scope.oval['value'].label );
							for( var ii = 0, jj = loot.length; ii < jj ; ii++ ){
								if( loot[ii].label === label ){
									return true;
								}
							}
							return false
						};
						
						for( var ii = 0, jj = magicBox.length; ii < jj ; ii++ ){
							var magicItem = magicBox[ii].getElementsByTagName('div');
							if( magicItem.length  ){
								var label = magicItem[0].getAttribute('label')
								checkItemOwner( label ) && this.checkAndRegisterItem( label, 'attached', slotId );
							}
						}
						
						
						//is item detached
						self : for(var kk = 0, ll = registerMagicBox.storage.length; kk < ll ; kk++ ){
							
							var itemReg =  registerMagicBox.storage[kk];
							
							if( itemReg && checkItemOwner( itemReg.name ) ){ 
								
								for( var mm = 0, nn = magicBox.length; mm < nn ; mm++ ){
									var magicItem = magicBox[mm].getElementsByTagName('div');
									if( magicItem.length && itemReg.name === magicItem[0].getAttribute('label') ){
										
										// item still attach;
										continue self
									}
								}
								
								// item detached
								this.checkAndRegisterItem( itemReg.name, 'detached', slotId )
								itemReg && scope.registerMagicBoxItem['value'].remove( itemReg.name )
								
							}
						}
					},
					upgrade : function( btn, prop, prevLabel ){
						var self = this ;
						scope.attachListener( btn, 'click', function(){
							scope.playAudio('tab-selected')
							scope.removeClass( upgradeContent, 'hidden' )
							var selectedSkill = self.getSkillByProperty( prop, 'className' );
							scope.text( upgradeDetail, selectedSkill.detail );
							scope.text( upgradeHeader, selectedSkill.displayName );
							upgradeContent.setAttribute('label', selectedSkill.label );
							upgradeContent.setAttribute('prev-label',prevLabel )
						})
						
					},
					enchantFormula : function( enchantMaterial ){
						var self = this, 
						formula = {
							healthPotion : {
								tierA : {
									root : 'magic',
									item : 'healthPotion',
									type : 'small',
									material : [ 'health potion' ]
								},
								tierB : {
									root : 'magic',
									item : 'healthMediumPotion',
									type : 'small',
									material : [ 'health medium potion' ]
								},
								tierC : {
									root : 'magic',
									item : 'healthStrongPotion',
									type : 'small',
									material : [ 'health strong potion' ]
								}
							},
							manaPotion : {
								tierA : {
									root : 'magic',
									item : 'manaPotion',
									type : 'small',
									material : [ 'mana potion' ]
								},
								tierB : {
									root : 'magic',
									item : 'manaMediumPotion',
									type : 'small',
									material : [ 'mana medium potion' ]
								},
								tierC : {
									root : 'magic',
									item : 'manaStrongPotion',
									type : 'small',
									material : [ 'mana strong potion' ]
								}
							},
							nortusShield : {
								tierA : {
									root : 'dropMonster',
									item : 'nortusShield',
									type : 'small',
									material : [ 'nortus shield' ]
								}
							},
							telsadian : {
								tierA : {
									root : 'dropMonster',
									item : 'telsadian',
									type : 'small',
									material : [ 'telsadian fragment' ]
								}
							},
							redGemStone : {
								tierA : {
									root : 'magic',
									item : 'redGemStone',
									type : 'small',
									material : [ 'red gem stone' ]
								}
							},
							taintedJewel : {
								tierA : {
									root : 'magic',
									item : 'taintedJewel',
									type : 'small',
									material : ['tainted material']
								}
							}
						}
						var loot = scope.characterInventoryBag['value'].get( scope.oval["value"].label  ),
						materials = [], enchantSacrifice = enchantMaterial.sacrifice && enchantMaterial.sacrifice || 1;
						for( var ii = 0, jj = enchantSlots.length; ii < jj ; ii++ ){
							var item = enchantSlots[ ii ].getElementsByTagName('div');
							if( item.length ){
								var itemLabel = item[0].getAttribute('label');
								for(var kk = 0, ll = loot.length; kk < ll ; kk++){
									for(var mm = 0, nn = enchantMaterial.enchant.length ; mm < nn ; mm++ ){								
										if( itemLabel === loot[kk].label 
											&& !loot[kk].enchant 
											&& enchantMaterial.enchant[mm] === loot[kk].type 
											&& loot[kk].quantity >= enchantSacrifice ){
											materials.push( loot[kk] );
										}
									}
								}
							}
						}
						
						//generate formula
						var enchantFormula = enchantMaterial.formula;
						forEnchant : for( var oo in  enchantFormula ){
							if( formula[ oo ] ){
								var itemFormula = formula[ oo ][ enchantFormula[ oo ] ];
								for( var pp = 0, qq = itemFormula.material, selectedItems = [], deduction = 0, count = 0 ; pp < qq.length ; pp++ ){
									for(var rr = 0; rr < materials.length ; rr++ ){
										if( materials[ rr ].usage === qq[ pp ] ){
											selectedItems.push( materials[ rr ] )
											count++;
											
										}
									}
									
									if( count === enchantMaterial.enchant.length ){
										var deduction, smallestNumberArr = [];
										
										smallestNumberArr.push( enchantMaterial.quantity )
										for( var ss = 0, tt = selectedItems.length; ss < tt; ss++ ){
											smallestNumberArr.push( selectedItems[ ss ].quantity );
										}
										
										
										deduction = enchantMaterial.sacrifice ? 
											enchantMaterial.sacrifice : smallestNumberArr.sort(function(a, b){return a-b})[0];
											
										
										for( var ss = 0, tt = selectedItems.length; ss < tt; ss++ ){
											selectedItems[ ss ].quantity -= deduction;
										}
										
										if( enchantMaterial.sacrifice  ){
											enchantMaterial.quantity = 0;
										}else if( deduction < enchantMaterial.quantity ){
											enchantMaterial.quantity -= deduction;
										}else{
											enchantMaterial.quantity = 0;
										}
										
										
										
										var newItem = new scope.items['value'][ itemFormula.root ][ itemFormula.item ]({ quantity : enchantMaterial.sacrifice ? 1 : deduction });
										newItem.bagLocation = 'slot-upgrd-f'
										newItem.enchantment = true;
										smallestNumberArr.length = 0;
										loot.push( newItem )
										this.createItem( newItem)
										
										// if quest available 
										scope.characterUpdateQuest['value']( itemFormula.item );
										
										self.fetchLoot()
										
										break forEnchant;
									}
									
								}
							}
						}
						
						self.fetchLoot()
					},
					upgrader : function(){
						var upgraderBox = scope.qs('upgrader-box'),
						self = this;
						if( /hidden/i.test( upgraderBox.className ) ){
							scope.removeClass( upgraderBox, 'hidden' )
						}else{
							scope.addClass( upgraderBox, 'hidden' )
						}
						
						
						var elClone = scope.qs('head-box').cloneNode(true);
						scope.qs('head-box').parentNode.replaceChild( elClone, scope.qs('head-box'));
						
						scope.attachListener( elClone, 'click', function(){
							scope.playAudio('tab-selected')
							scope.addClass( this.parentNode, 'hidden' );
							for( var ii = 0; ii < enchantSlots.length; ii++ ){
								 enchantSlots[ii].innerHTML = '';
								 self.fetchLoot({
									 preventBagLocation : true
								 });
							}
						})
						
						var elClone = scope.qs('footer-box').cloneNode(true);
						scope.qs('footer-box').parentNode.replaceChild( elClone, scope.qs('footer-box'));
						scope.attachListener( scope.qs('footer-box'), 'click', function(){
							scope.playAudio('tab-selected')
							if( !scope.id('slot-upgrd-f').getElementsByTagName('div').length ){
								
								
								var loot = scope.characterInventoryBag['value'].get( scope.oval["value"].label  );
								for( var ii = 0, jj = enchantSlots.length; ii < jj ; ii++ ){
									var item = enchantSlots[ ii ].getElementsByTagName('div');
									if( item.length ){
										var itemLabel = item[0].getAttribute('label');
										for(var kk = 0, ll = loot.length; kk < ll ; kk++){
											if( itemLabel === loot[kk].label && loot[kk].enchant ){
												self.enchantFormula( loot[kk] )
												break;
											}
										}
									}
								}
							}
						})
						
					},
					fetchQuest : function(){
						var storageQuest = scope.characterQuest['value'].storage,
						quest = isMobile ? 'main-quest-mb' : 'main-quest', 
						childQuest = isMobile ? 'child-quest-mb' : 'quest-detail' ,
						addActive = function( el ){
							var cntLi = scope.slice( document.querySelectorAll( '.'+quest+' > li') );
							for(var ii = 0, jj = cntLi.length; ii < jj; ii++ ){
								scope.removeClass( cntLi[ii], 'active' );
							}
								
							scope.addClass( el, 'active' );
						},
						fetchChildQuest = function( parent ){
							var state = true,
							removeHidden = function( el ){
								var divCnt = scope.slice( el.getElementsByTagName( 'div' ) );
								for( var ll = 0; ll < divCnt.length; ll++ ){
									if( /click/i.test( divCnt[ll].className )
										&& tree.active
										&& scope[ tree.mapMark ]
										&& scope[ tree.mapMark ]['value'].quest.update.length ){
									   scope.removeClass( divCnt[ll], 'hidden' );
									}
								}
							};
							scope.qs( childQuest ).innerHTML = '';
							
							for(var kk in parent ){
								var tree = parent[kk];
								li = document.createElement('li');
								
								if( tree.active || tree.isFinish ){
								
									scope.addChildQuest['value']( tree, li );
									scope.qs( childQuest ).appendChild( li );
									
									var needDot = tree.mapMark === '' ? 'dot-quest' : '';
									if( tree.isFinish ) scope.getFirstChild( li ).className = 'quest-tree gold linethrough '+ needDot ;
									
									state = false;
									
									removeHidden( li );
								}
							}
							//first quest
							if( state ){
								for(var kk in parent ){
									var tree = parent[kk],
									li = document.createElement('li');
									scope.addChildQuest['value']( tree, li );
									scope.qs( childQuest ).appendChild( li );
									
									removeHidden( li );
									break;
								}
							}
						};
						
						scope.qs( childQuest ).innerHTML = scope.qs( quest ).innerHTML = '';
				
						for( var oo in storageQuest ){
							var objQuest = storageQuest[ oo ].status;
							if( objQuest ){
								var li = document.createElement('li');
								scope.text( li, objQuest.title );
								
								addActive( li )
								
								scope.attachListener( li, 'click', function( el, parent){
									
									scope.playAudio('tab-selected')
									
									addActive( el )
							
									fetchChildQuest( parent )
								}.bind(this, li, objQuest.questTree ) )
								scope.qs( quest ).insertBefore( li, scope.qs( quest ).firstChild );
							}
						}
						
						if( storageQuest.length) fetchChildQuest( storageQuest[ storageQuest.length - 1 ].status.questTree );
						
					},
					fetchSkillOnload : function(){
						
						//clear slots
						for( var ii = 0, jj = slotSkills.length ; ii < jj ; ii++ ){
							slotSkills[ii].innerHTML = ""
						}
						
						//attach slot to new skill when slotLocation is not empty
						var skills = scope.characterSkills['value'].get( scope.oval['value'].label );
						if( skills ){
							for(var nn = 0; nn < skills.length; nn++ ){
								if( skills[nn].slotLocation !== '' ){
									var div = document.createElement('div');
									div.className  = 'item clone '+ skills[nn].className;
									div.setAttribute( 'label', skills[nn].label );
									div.setAttribute( 'type', skills[nn].type );
									
									var timeSpan = document.createElement('div');
									timeSpan.className = 'time-span time-span-'+skills[nn].label;
									div.appendChild( timeSpan )
									
									var disbale = document.createElement('div');
									disbale.className = 'disable-skill';
									div.appendChild( disbale )
									
									
									scope.id( skills[nn].slotLocation ).innerHTML = '';
									scope.id( skills[nn].slotLocation ).appendChild( div )
							
								}
							}
						}
					},
					fetchSkill : function(){
						var registerSkill = scope.characterSkills['value'].get( scope.oval["value"].label ),
						registerSlotsMb = isMobile ? slotSkillActiveMb : scope.qs("browser-skill").getElementsByTagName('li'),
						charParams = scope.characterParameters['value'];
						//scope.text( skillPoint, charParams.skillPoint );
						scope.text( soulPoint, charParams.gold );
						  
						//fetch skill
						for( var ll = 0, mm = scope.slice( containerSkill.getElementsByTagName('li') ); ll < mm.length ; ll++){
							mm[ll].innerHTML = '';
						}

							
						for(var ii = 0, jj = activeSlotSkill.length; ii < jj ; ii++ ){
							var el = scope.getFirstChild( activeSlotSkill[ii] );
							if( el ){
								for( var kk = 0, len = registerSkill.length ; kk < len ; kk++ ){
									var skill = registerSkill[kk];
									if( el.getAttribute('label') === skill.label ){
										var div = document.createElement('div');
										for( var mm = 0; mm < slotSkills.length ; mm++ ){
											if( !slotSkills[mm].getElementsByTagName('div').length && /slot-skill/i.test( slotSkills[mm].className ) ){
												
												div.className  = 'item '+ skill.className;
												div.setAttribute( 'label', skill.label )
												div.setAttribute( 'type', skill.type )
												slotSkills[mm].appendChild( div );
												
												break;
											}
										}
									}
								}
							}
						}
						
						
						var registerSkill = scope.characterSkills['value'].get(scope.oval["value"].label );
						 
						//fetch skill detail and add attribut id to element
						for(var ii = 0, jj = 0; ii < detailSkills.length ; ii++ ){
							
							var itemSkill;
							//reappend dom element to prevent bug when switch character
							detailSkills[ii].innerHTML = "" ;
							
							//append new skill when firstchild is empty
							if( registerSkill[ii] ){
											  
								var itemSkill = document.createElement("div");
								itemSkill.className = "item "+ registerSkill[ii].className;
								itemSkill.setAttribute('type', 'active')
								detailSkills[ii].appendChild( itemSkill );
								
								
								/**********/
								//clone skill and attach to its slot
								var clone = itemSkill.cloneNode(true);
								clone.setAttribute("label", registerSkill[ii].label );
								scope.addClass( clone, "clone" )
								
								var timeSpan = document.createElement('div');
								timeSpan.className = 'time-span time-span-'+registerSkill[ii].label ;
								
								var disable = document.createElement('div');
								disable.className = 'disable-skill';
								
								clone.appendChild( timeSpan );
								
								clone.appendChild( disable );
								 
								registerSlotsMb[ii].innerHTML = "";
								registerSlotsMb[ii].appendChild( clone );
								/***/
								 
								for( var kk = 0, len = registerSkill.length ; kk < len ; kk++ ){
									var skill = registerSkill[kk];
									if( itemSkill.className.split(' ')[1] === skill.className ){
										
										//clear first to prevent block when skill is actived
										itemSkill.innerHTML = '';
										itemSkill.parentNode.setAttribute('drag', 'true')
											
										if( registerSkill[kk].level > charParams.level 
										 || // next idetify skill need upgrade
											registerSkill[kk].next && !registerSkill[kk].active
										 || //wizard idetify skill is advance without next property
											/wizard/i.test( registerSkill[kk].caracterClass  ) && !registerSkill[kk].active  ){ 
											
											
											var divOutter = document.createElement('div')
											divInner = document.createElement('div')
											divOutter.className = 'cover-up';
											divInner.className = 'cover-level';
											scope.text( divInner, skill.level )
											divOutter.appendChild( divInner );
											itemSkill.innerHTML = '';
											itemSkill.parentNode.setAttribute('drag', 'false')
											itemSkill.appendChild( divOutter );
										}
										
										itemSkill.setAttribute( 'label', skill.label )
									}
								}
							
							}
							
							//hidden empty slot
							if( !itemSkill ) detailSkills[ii].style.opacity = 0 ;
							else  detailSkills[ii].style.opacity = 1;
							
							
						}
						
						
					},
					
					
					fetchLoot : function( prop ){
						
						var updateSlot = prop ? prop.updateSlot : true,
						preventBagLocation = prop ? prop.preventBagLocation : false;
						
						if( updateSlot ){
							//when switch a hero, loot need update
							this.attachMainPotions();
							this.lootNeedClear();
						}
						
						var activeHpSlot = scope.slotButtonHp.getElementsByTagName('div'),
						activeMpSlot = scope.slotButtonMp.getElementsByTagName('div'),
						loot = scope.characterInventoryBag['value'].get( scope.oval['value'].label );
 
						for(var jj = 0; jj < loot.length ; jj++ ){
							
							
							for( var ii = 0; ii < slots.length ; ii++ ){
								
								if( slots[ii] && loot[jj] ){
									
									
									var item = scope.slice( slots[ii].getElementsByTagName('div') ),
									allow = item.length && loot[jj].label === item[0].getAttribute('label');
						
									
									if(  allow ){
										
										if( loot[jj].quantity  >= 1){ 
											scope.text( item[1], loot[jj].quantity );
										}else if( loot[jj].quantity === 0 ){ 
											scope.nthParent( item[0], 1 ).innerHTML = '';
											loot.splice( jj, 1 );
										}
									}
									
									
									
									loot[jj].indexBagLocation = ii;
									
									if( allow
										|| activeHpSlot.length && loot[jj].label === activeHpSlot[0].getAttribute('label')
										|| activeMpSlot.length && loot[jj].label === activeMpSlot[0].getAttribute('label') ){
										break;
									}

									if( ii === ( slots.length - 1 ) &&  loot[jj].quantity ){
										 
										this.createItem( loot[jj], preventBagLocation )
									}
									
									
									
								}
							}
						}
					},
					markPotions : function(){ // add prop slotPotion to attached potions
						
						//mark if its hp/mp slot, mobile or desktop are marked here
						//it will be required for switchCharacter
						
						var loot = scope.characterInventoryBag['value'].get( scope.oval['value'].label );
						
						//remove unique prop required for switch hero
						loot.forEach(function( obj ){
							if( obj.slotPotion ) delete obj.slotPotion;
						})
						
						var activeHpSlot = scope.slotButtonHp.getElementsByTagName('div'),
						activeMpSlot = scope.slotButtonMp.getElementsByTagName('div');
						 
						for(var ii = 0, hpState = false, mpState = false; ii < loot.length ; ii++ ){
							//set init active slot
							if( activeHpSlot.length
								&& !hpState
								&& loot[ii].label === activeHpSlot[0].getAttribute('label') ){
								loot[ii].slotPotion = true;
								hpState = true;
							}else if( activeMpSlot.length
								&& !mpState
								&& loot[ii].label === activeMpSlot[0].getAttribute('label') ){
								loot[ii].slotPotion = true;
								mpState = true;
							}
							
						}	
					},
					attachMainPotions : function( isSwitchHero ){
						 
						var loot = scope.characterInventoryBag['value'].get( scope.oval['value'].label );
						   
						var hpAttached  = scope.getFirstChild( scope.slotButtonMp ),
						mpAttached = scope.getFirstChild( scope.slotButtonHp ),
						manaState = !isSwitchHero ? hpAttached : false,
						healthState = !isSwitchHero ? mpAttached : false;
						 
						for(var ii = 0; ii < loot.length ; ii++ ){
							 
							if( /manapotion/i.test( loot[ii].name ) 
								&&  loot[ii].slotPotion 
								&& !manaState ){ 
							
								scope.slotButtonMp.innerHTML = "";
								this.createItem( loot[ii], "", scope.slotButtonMp )
								
								if( isMobile ){
									mpSlotMb.innerHTML = "";
									this.createItem( loot[ii], "", mpSlotMb )
								}
								
								manaState = true;
							}else if( /healthpotion/i.test( loot[ii].name )
								&& loot[ii].slotPotion
								&& !healthState ){
									
								scope.slotButtonHp.innerHTML = "";
								this.createItem( loot[ii], "", scope.slotButtonHp )
								 
								if( isMobile ){
									hpSlotMb.innerHTML = "";
									this.createItem( loot[ii], "", hpSlotMb )
								}
								
								healthState = true;
							}
						}
						
						//attach firstload
						for(var ii = 0; ii < loot.length ; ii++ ){
							 						
							if( /manapotion/i.test( loot[ii].name ) && !manaState ){ 
								scope.slotButtonMp.innerHTML = ""; 
								this.createItem( loot[ii], "", scope.slotButtonMp ); 
								
								if( isMobile ){
									mpSlotMb.innerHTML = "";
									this.createItem( loot[ii], "", mpSlotMb )
								}
								 
								manaState = true;  
								
							}else if( /healthpotion/i.test( loot[ii].name ) && !healthState ){
								scope.slotButtonHp.innerHTML = "";
								this.createItem( loot[ii], "", scope.slotButtonHp )
								
								if( isMobile ){
									hpSlotMb.innerHTML = "";
									this.createItem( loot[ii], "", hpSlotMb )
								}
								
								healthState = true;
								 
							} 
						}
					
						//recheck this hp/mp is available
						var hpPotion = scope.slotButtonHp.getElementsByTagName('div'),
						mpPotion = scope.slotButtonMp.getElementsByTagName('div'),
						manaState =  false, healthState = false;
					 
						for(var ii = 0; ii < loot.length ; ii++ ){
							var item = loot[ii];
							if( hpPotion.length && item.label === hpPotion[0].getAttribute('label') ){
								manaState =  true;
							}
							if( mpPotion.length && item.label === mpPotion[0].getAttribute('label') ){
								healthState = true;
							}
						}
						
						if( !manaState ){
							isMobile && ( hpSlotMb.innerHTML = "" );
							scope.slotButtonHp.innerHTML = "";
						}
						
						if( !healthState ){
							isMobile && ( mpSlotMb.innerHTML = "" );
							scope.slotButtonMp.innerHTML = "";
						}
						
						
					}, 
					
					lootNeedClear : function(){
						
						var loot = scope.characterInventoryBag['value'].get( scope.oval['value'].label ),
						activeHpSlot = scope.slotButtonHp.getElementsByTagName('div'),
						activeMpSlot = scope.slotButtonMp.getElementsByTagName('div');
						 			
						for( var ii = 0; ii < slots.length ; ii++ ){
							var item = scope.slice( slots[ii].getElementsByTagName('div') );
								
							if( item.length ){
								
								var label = item[0].getAttribute('label'),
								slot = slots[ii],
								owner = false
								
								if( slot.id !== "slot-hp" && slot.id !== "slot-mp" ){
									if( activeHpSlot.length &&  label === activeHpSlot[0].getAttribute('label') ){
										slot.innerHTML = "";
									}else if( activeMpSlot.length && label === activeMpSlot[0].getAttribute('label') ){
										slot.innerHTML = "";
									}
								}
								
								self : for(var jj = 0; jj < loot.length ; jj++ ){
									if( label === loot[jj].label ){
										owner = true;
										break self;
									}
								}
								
								if( !owner ){
									slot.innerHTML = "";
								}
								
							}
						}
						
						
						this.fetchSkillOnload();
						
					},
					skillDetail : function( target ){
						
						//remove container skill when perform event click 
						//scope.addClass( scope.qs('list-skills'), "hidden" );
						
						var skills = scope.characterSkills['value'].get( scope.oval['value'].label ),
						skillsCnt = scope.items['value'].skills,
						container = !isMobile ? scope.detailSkill : scope.qs('innerwrap-info-skill-mb');
						//skill detail
					
						for(var jj = 0; jj < skills.length ; jj++ ){
							if( skills[jj] && skills[jj].label === target ){
								  
								if( skills[jj].name !== 'undead' ){
								
									container.innerHTML = '';
									self : for( var kk in skills[jj] ){
										if( /displayName|mp|detail|next|upgradeClass|require/i.test(kk) && kk !== 'className' ){
											var li = document.createElement('li'),
											spanInfo = document.createElement('span'),
											spanDetail = document.createElement('span'),
											isUpgraded = skillsCnt[ skills[jj].upgradeProperty ];
											
											//prevent execute when upgrade is already active
											if( isUpgraded && isUpgraded.active && /next|upgradeClass|require/i.test(kk)  )
												continue self;
												
											if( kk === 'require' ){
												var requireText =  'skill points : '+skills[jj][kk].skillPoint +', Required Level  : '+ skills[jj][kk].level
												scope.text( spanInfo, kk )
												scope.text( spanDetail, requireText )
												li.appendChild( spanInfo )
												li.appendChild( spanDetail );
												
												var upgrade = document.createElement('li'),
												abbr = document.createElement('abbr');
												scope.text( abbr, 'Unlock' )
												upgrade.className ='upgrade-button';
												upgrade.appendChild( abbr );
												
												//attachListener
												obj.upgrade( upgrade, skills[jj].upgradeClass, target )
											}else if( kk === 'upgradeClass' ){
												var div = document.createElement('div');
												div.className='item '+skills[jj][kk];
												li.className = 'box';
												li.appendChild( div );
											}else {
												
												var title = kk === "mp" ? owlData.lang.fn( "gui", "htmlGUI", "mpNeed" ) : kk;
												
												scope.text( spanInfo, ( title === 'displayName' ? 'Name' : title ) )
												scope.text( spanDetail, skills[jj][kk] )
												li.appendChild( spanInfo )
												li.appendChild( spanDetail )
											}
											
											container.appendChild( li )
											
											if( kk === 'require' && !!isUpgraded && !isUpgraded.active  ){
												container.appendChild( upgrade )
											}
										}
									}
								
								
								}
									
								break;
							}
						}
					
					},
					skillInfoDetail : function( target ){
						var skills = scope.characterSkills['value'].get(scope.oval["value"].label ),
						container = scope.detailInventory ;
						
						if( /clone/i.test( target.className ) ) return false;
						
						for(var ii = 0, jj = skills.length ; ii < jj ;  ii++ ){
						
							if( skills[ii] && skills[ii].label === target.getAttribute('label') ){
								container.innerHTML = '';
								for(var jj in skills[ii] ){
									if( /displayName|mp|detail/i.test(jj) && jj !== 'className'){
										container.appendChild( this.createDetail( jj, skills[ii][jj] ) )
										
									}
								}
								
								if( !isMobile ){
									var divRect = target.parentNode.getBoundingClientRect();
									scope.css( scope.qs('item-popup'), {
										'top': divRect.top +'px',
										'left':  divRect.left + 5 +'px'
									});
								}
								
								break;
							}
						}
								
						
					},
					skillGUITriggered : function(){
						
						var triggerFn = function( labelSkill, skillSlot, disableMsg ){
							var charSkills = scope.characterSkills['value'].get( scope.oval['value'].label ),
							charParams = scope.characterParameters['value'];
							 
							
							for(var jj = 0; jj < charSkills.length; jj++)
							{ 
								
								if( ( charSkills[jj].label === labelSkill
									&& charSkills[jj].state
									&&  function(){
										// disable monster target to certain skill
										return /intimidation/i.test( charSkills[jj].name ) ? true : (  scope.globalAnimation["value"].monsterTarget );
									}() && charParams.mp > charSkills[jj].mp ) /*&&  charSkills[jj].firstLoad*/  ){
									
									if( charSkills[jj].active 
									&& charParams.level >=  charSkills[jj].level
									&& !charSkills[jj].disable ){
										
										
										charSkills[jj].firstLoad = false
										var initial = scope.characterSkills['value'].get( 'initial' )
										
										initial.label = labelSkill
										initial.state = true
										initial.target = skillSlot[0]
										
										break;
											
									}
									
								}else if( !disableMsg && charSkills[jj].label === labelSkill 
									&& !charSkills[jj].disable 
									&& !scope.globalAnimation["value"].monsterTarget
									&& charParams.health ){
										 
									scope.pushMsgText['value']( owlData.lang.fn( "gui", "tapSkill", "detail" ) , 100 );
								}
							}
						}
						
						//manual active skill
						for(var ii = 0; ii < activeSlotSkill.length; ii++){
							scope.attachListener( activeSlotSkill[ii], 'click', function(){
								var skillSlot = this.getElementsByTagName('div') ||  this.getElementsByTagName('li')
								if( skillSlot.length ){
									var labelSkill = skillSlot[0].getAttribute('label');
									triggerFn( labelSkill, skillSlot );
								}
							})
						}
						
						var autoSkill; 
						 
						scope.attachListener( sortCutAutoSkill, 'click', function(){
							
							if( /on/i.test( this.className ) ){
								
								scope.removeClass( this, "auto-on" );
								scope.addClass( this, "auto-off" );
								clearInterval( autoSkill );
							}else{
								
								scope.removeClass( this, "auto-off" );
								scope.addClass( this, "auto-on" );
								autoSkill = setInterval(function() {
									
									if( scope.globalAnimation["value"].characterControl.isAttacking ){
									
										for(var ii = 0; ii < activeSlotSkill.length; ii++){
											var parentSlotSkill = activeSlotSkill[ii],
											skillSlot = parentSlotSkill.getElementsByTagName('div') ||  parentSlotSkill.getElementsByTagName('li')
											if( skillSlot.length ){
												var labelSkill = skillSlot[0].getAttribute('label'),
												activeSpan  =  scope.getLastChild( skillSlot[0] );
												if( !/block/i.test( activeSpan.getAttribute('style') ) ){
													triggerFn( labelSkill, skillSlot, true );
												}
											}
										}
									}
								},1000);
							}
						})
						
						
						
						//switch mobile
						var flip = true;
						scope.attachListener( sortCutAutoSwitch, "click", function( event ){
							
							var charObj = scope.characterMobileControl['value'].charObj;
								 
								scope.addClass( this, "switch-on" )
								scope.removeClass( this, "switch-off" );
								 
								if( flip && charObj.switchCharacterAuto() ){
									
									flip = false; 
									
									setTimeout(function(){
										
										scope.addClass( this, "switch-off" );
										scope.removeClass( this, "switch-on" );
										flip = true;
									}.bind(this),1000)
								}else{
									
									scope.addClass( this, "switch-off" );
									scope.removeClass( this, "switch-on" );
								}
						})
							
						
					},
					createItem : function( item, preventBagLocation, selectedSlot ){
						var  div = document.createElement('div');
						div.className  = 'item '+ item.className;
						div.setAttribute( 'label', item.label )
						
						var divNumber = document.createElement('div');
						divNumber.className = item.quantity > 1 ? 'item-number' : 'item-number hidden';
						scope.text( divNumber, item.quantity )
						div.appendChild( divNumber )
						
						 
						if( selectedSlot ){
							selectedSlot.appendChild( div )
							
						}else if( item.bagLocation !== '' && !preventBagLocation ){
							scope.id( item.bagLocation ).appendChild( div )
						}else{
							for( var kk = 0; kk < slots.length ; kk++ ){
								if( !slots[kk].getElementsByTagName('div').length ){
									slots[kk].appendChild( div );
									item.indexBagLocation = ii;
									break;
								}
							}
						}
					},
					createDetail : function( infoText, obj, object ){
						
						var textFn = function(  text ){
							return owlData.lang.fn( "gui", "charaGUI", text );
						}
						
						
						
						infoText = 'enchant' === infoText.toLowerCase() ? 'Required Material' : infoText;
						if( obj instanceof Object &&  !(obj instanceof Array) ){
							if( /magic resistance/i.test( infoText ) ){
								var min = 'magicDefenseMin', max = 'magicDefenseMax';
								infoText = textFn( "magicDef" );
							}else if( /physical resistance/i.test( infoText ) ){
								var min = 'defenseMin', max = 'defenseMax';
								infoText =  textFn( "physicalDef" );
							}else if( /range damage/i.test( infoText ) ){
								var min = 'attackRangeMin', max = 'attackRangeMax';
								infoText =  textFn( "rangeDmg" );
							}else if( /melee damage/i.test( infoText ) ){
								var min = 'attackMin', max = 'attackMax';
								infoText = textFn( "meleeDmg" );
							}else if( infoText === 'displayName'){
								infoText = textFn( "name" );
							}
							
							if( obj.originalParams ){
								var  minOri = obj.originalParams[ min ],
								minParam = Math.round( obj[ min ] ),
								minChange = Math.round( minParam - minOri ),
								maxParam = Math.round( obj[ max ] ),
								maxOri = obj.originalParams[ max ],
								maxChange = Math.round( maxParam - maxOri )
							}else{
								var minOri = Math.round( obj[ min ] ),
								maxOri = Math.round( obj[ max ] );
							}
							
							var li = document.createElement('li'),
							spanInfo = document.createElement('span'),
							spanMinInfoOri = document.createElement('span'),
							spanMinInfoParams = document.createElement('abbr'),
							spanMaxInfoOri = document.createElement('span'),
							spanMaxInfoParams = document.createElement('abbr');
							spanStrip = document.createElement('span');
							
							spanMaxInfoOri.className = spanMinInfoOri.className = 'static bold';
							spanInfo.className = 'staticBlock';
							
							spanMinInfoParams.className = spanMaxInfoParams.className = object.color ? object.color : 'light-blue';
							
							var op;
							if( parseInt( minChange ) < 0 ){
								op = "-";
								minChange = Math.abs( minChange );
								maxChange = Math.abs( maxChange );
							}else{
								op = "+";
							}
							
							scope.text( spanInfo, infoText )
							
							scope.text( spanMinInfoOri, minOri )
							scope.text( spanMinInfoParams, ' '+op+' '+minChange )
							
							scope.text( spanMaxInfoOri, maxOri )
							scope.text( spanMaxInfoParams, ' '+op+' '+maxChange )
							
							scope.text( spanStrip, ' - ')
							
							parseInt( minChange ) && spanMinInfoOri.appendChild( spanMinInfoParams )
							parseInt( maxChange ) && spanMaxInfoOri.appendChild( spanMaxInfoParams )
							parseInt( maxChange ) && parseInt( maxChange )
							
							li.appendChild( spanInfo )
							li.appendChild( spanMinInfoOri )
							li.appendChild( spanStrip )
							li.appendChild( spanMaxInfoOri )
							
						
						}else{
							
							var li = document.createElement('li'),
							spanInfo = document.createElement('span'),
							spanDetail = document.createElement('span'),
							objIsArray = obj instanceof Array;
							spanDetail.className = objIsArray ? 'gold' : '',
							obj = objIsArray  ? obj.join(', ') : obj;
							
							if( infoText === 'Abilities ' ){
								spanDetail.className =  object.color ? object.color : 'light-blue';
								infoText = textFn( "ability" );
							}else if( /name|displayName/i.test( infoText ) ){
								infoText = textFn( "name" );
							}else if( infoText === 'mp'){
								infoText = textFn( "mpReq" ); 
							}else if( /attack range/i.test( infoText ) ){
								infoText = textFn( "atkRange" );  
							}else if( /health points/i.test( infoText ) ){
								infoText = textFn( "hp" );  
							}else if( /magic points/i.test( infoText ) ){
								infoText = textFn( "hp" );  
							}
							 
							scope.text( spanInfo, infoText )
							scope.text( spanDetail, obj )
							li.appendChild( spanInfo )
							li.appendChild( spanDetail )
						}
						
						return li
					},
					charDetail : function( object ){
						var cParms = object.params ;
						if( !isMobile ) object.box.innerHTML = '';
						 
						object.box.appendChild( this.createDetail( 'Name ', cParms.name , object  ) )
						object.box.appendChild( this.createDetail( 'Health Points ', cParms.health ? ( cParms.health  +' / '+  cParms.maxHealth ) : cParms.maxHealth , object    ) )
						object.box.appendChild( this.createDetail( 'Magic Points ', cParms.mp ? ( cParms.maxMp ? ( cParms.mp +' / '+  cParms.maxMp ) : cParms.mp )  : cParms.maxMp, object  ) )
						object.box.appendChild( this.createDetail( 'Attack Range ',  cParms.range ? cParms.range :  cParms.attackRange , object  ) )
						object.box.appendChild( this.createDetail( 'Melee Damage', cParms , object  ) )
						object.box.appendChild( this.createDetail( 'Range Damage',  cParms , object  ) )
						object.box.appendChild( this.createDetail( 'Physical Resistance ', cParms , object  ) )
						object.box.appendChild( this.createDetail( 'Magic Resistance ', cParms , object ) )
						
						if( cParms.modifierAbilities ){
							var temp = [],
							textFn = function( text ){
								return owlData.lang.fn( "gui", "charaGUI", text )  
							}
							for(var ii in cParms.modifierAbilities ){
								
								if( cParms.modifierAbilities[ii] > 0 ){
									switch(ii){
										case "stun" : temp.push( Math.round( cParms.modifierAbilities[ii] )+' % '+ 
											textFn( "stun" ) ); break;
										case "avoid" : temp.push( Math.round( cParms.modifierAbilities[ii] )+' % '+ 
											textFn( "avoidance" ) ); break;
										case "block" : temp.push( Math.round( cParms.modifierAbilities[ii] )+' % '+ 
											textFn( "block" ) ); break;
										case "critical" : temp.push(  Math.round( cParms.modifierAbilities[ii] )+' % '+
											textFn( "critical" ) ); break;
										case "criticalChance" : temp.push(  Math.round( cParms.modifierAbilities[ii] )+' % '+ 
											textFn( "criticalChance" ) ); break;
									}
								}
							}
							
							temp.length && object.box.appendChild( this.createDetail( 'Abilities ',  temp.join(' ,  ') , object  ) )
						}
						
						//monsterLevel
						if( cParms.monsterLevel ){
							object.box.appendChild( this.createDetail( 'Level ', cParms.monsterLevel , object ) )
						}
						
						//Kemampuan Skill
						if( Object.keys( cParms.abilitySkill ).length > 0 ){
							
							var li = document.createElement('li'),
							spanInfo = document.createElement('span');
							scope.text( spanInfo, owlData.lang.fn( "gui", "charaGUI", "skillTalent" ) + " :");
							
							spanInfo.style.width = "100%";
							li.appendChild( spanInfo )
							
							for( var ii in cParms.abilitySkill ){
								var elChild = document.createElement("div");
								elChild.className = "m-level "+ii;
								li.appendChild( elChild )
							}
							
							object.box.appendChild( li )
						}
						
					},
					shopDetail : function( options ){
						options.box.innerHTML = '';
						for(var ii = 0, jj = options.items; ii < jj.length ; ii++ ){
							if( jj[ii].label === options.label ){
								for( var kk in jj[ii] ){
									if( ( /displayName|detail/i.test( kk ) || 'enchant' === kk ) && kk !== 'className'){
										options.box.appendChild( this.createDetail( kk, jj[ii][kk] ) );
									}
								}
								return jj[ii];
								break;
							}
						}
					},
					itemDetail : function( target ){
						var loot = scope.characterInventoryBag['value'].get( scope.oval['value'].label ),
						container = !isMobile ? scope.detailInventory : staticDetail;
						container.innerHTML = '';
						if( target ){ //prevent mobile target is empty
							//item detail
							for(var ii = 0; ii < loot.length ; ii++ ){
								if( loot[ii] && loot[ii].label === target.getAttribute('label') ){
									
									for( var jj in loot[ii] ){
										if( ( /displayName|name|detail/i.test(jj) || 'enchant' === jj ) && jj !== 'className'){
											if( !loot[ii].displayName ){
												container.appendChild( this.createDetail( jj, loot[ii][jj] ) );
											}else{
												if( jj === 'name' ) continue;
												container.appendChild( this.createDetail( jj, loot[ii][jj] ) );
											}
										}
									}
								
									if( !isMobile ){	
										var divRect = target.parentNode.getBoundingClientRect();
										scope.css( scope.qs('item-popup'), {
											'top': divRect.top +'px',
											'left':  divRect.left +'px'
										});
									}
									
									break;
								}
							}
						}
					},
					guiToogle : function(){
					
						if( isMobile && /hidden/i.test( gui.className ) ){
								//GUI MOBILE
								scope.removeClass( gui, 'hidden');
								this.GUImobile.firstLoad();
								this.GUImobile.replaceSkills('detached');
								scope.playAudio('Inventory_Open_01');
							
						}else{	
							if( /hidden/i.test( gui.className ) ){
								scope.removeClass( gui, 'hidden')
								scope.addClass( document.getElementsByTagName('header')[0], 'hidden')
								scope.addClass( scope.qs('nav-bottom-mobile'), 'hidden');
								scope.playAudio('Inventory_Open_01');
							}else{
								scope.addClass( gui, 'hidden');
								scope.removeClass( document.getElementsByTagName('header')[0], 'hidden')
								scope.removeClass( scope.qs('nav-bottom-mobile'), 'hidden');
								scope.playAudio('inventory-close');
							}
						}
						
					},
					activeTab : function( element ){
						var tabs = scope.slice( scope.qs('container-menu').getElementsByTagName('li') )
						scope.playAudio('tab-selected')
						for(var ii = 0, jj = tabs.length;  ii < jj ; ii ++ ){
							var div = scope.getFirstChild( tabs[ii] )
							
							scope.removeClass( div, 'active-tab')
							if( div.className === element.className ){
								scope.addClass( element, 'active-tab')
							}
						}
					},
					selectTab: function( activeEl, tab ){
						var gui =  scope.qs('gui-player'), 
						tabList = [ scope.bagContainer, scope.skillContainer, scope.questContainer, scope.controlContainer ];
						
						
						this.fetchQuest();
						this.charDetail({					
							params : scope.characterParameters['value'],
							box : staticDetail
						});
						
						if( /hidden/i.test( gui.className ) ){
							scope.removeClass( gui, 'hidden');
						}else if( !/hidden/i.test( activeEl.className )){
							obj.guiToogle(); 
						}
						
						for( var ii = 0; ii < tabList.length; ii++ ){
							if(activeEl === tabList[ii] ){
								scope.addClass( activeEl, 'active')
								scope.removeClass( activeEl, 'hidden')
				
							}else{
								scope.addClass(  tabList[ii], 'hidden')
								scope.removeClass(  tabList[ii], 'active')
							}
						}
						
						this.activeTab( tab );
						
						scope.removeClass( sortCutnExpand, 'expand')
						scope.css( scope.qs('hidden-menu') , { 
							'transform': '0px,0px,0px', 
							'transition' : 'transform 450ms ease-in-out'
						})	
						
						if( /hidden/i.test( gui.className ) ){
							scope.removeClass( document.getElementsByTagName('header')[0], 'hidden')
							scope.removeClass( scope.qs('nav-bottom-mobile'), 'hidden')
							
							window.scope.blockRender = false;
						}else{
							scope.addClass( document.getElementsByTagName('header')[0], 'hidden')
							scope.addClass( scope.qs('nav-bottom-mobile'), 'hidden')
						}
						
						
						scope.dragBar();
						
						
						
					},
					emptyBagLocation : function( label ){
						var loot = scope.characterInventoryBag['value'].get( scope.oval["value"].label  );
						for( var ii = 0, jj = loot.length; ii < jj; ii++ ){
							if( label === loot[ii].label ){
								loot[ii].bagLocation = '';
								break
							}
						}
					},
					loadSaveGame : function(){
						var saveGame = JSON.parse( localStorage.getItem( 'saveGame') )
						//clear html
						
						for(var ii in saveGame ){
							var li = document.createElement('li')
							li.setAttribute('target', ii)
							scope.text( li, ii );
							saveCnt.insertBefore( li, saveCnt.firstChild ),
							
							cloneLi = li.cloneNode(true),
							saveMenu.insertBefore( cloneLi, saveMenu.firstChild );
						}
						
						var liSave = document.createElement('li')
						scope.text( liSave, 'SAVE NEW GAME' );
						saveCnt.appendChild( liSave )
						
						//save game
						
						var saveCntLi = saveCnt.getElementsByTagName('li');
						
						var saveList = scope.slice( saveCntLi );
						for(var ii = 0; ii < saveList.length; ii++){ 
							scope.attachListener( saveList[ii], 'click', function(){
								
								scope.playAudio('tab-selected')
								
								var target = this.getAttribute('target');
								if( target ){
									var p = loadContent.getElementsByTagName('p')[0];
									scope.text( p, 'Save Game, ' + target )
									
									scope.removeClass( loadContent, 'hidden' );
									loadContent.setAttribute( 'target', target )
									// load save
								}else{
									// new save
									if( /hidden/i.test( saveContent.className ) ){
										scope.removeClass( saveContent, 'hidden' )
									}else{
										scope.addClass( saveContent, 'hidden' )
									}
								}
							})
						}
						
						//attach event click
						
				
						//first load menu buttons
						var saveMenuLi = scope.slice( saveMenu.getElementsByTagName('li') );
						for( var ii = 0, jj = saveMenuLi; ii < jj.length ; ii++ ){
							scope.attachListener( jj[ii], 'click', function(){
								scope.playAudio('tab-selected')
								var target = JSON.parse( localStorage.getItem( 'saveGame' ) )[ this.getAttribute('target') ];
								localStorage.setItem( 'load', scope.JSONstringfy( target ) );
								location.reload()
							})
						}
						
					},
					loadMenuSaveGame : function(){
						// perform load alert's save & dismiss buttns
						scope.attachListener( loadAlertBtn[1], 'click', function(){
							scope.playAudio('tab-selected')
							scope.addClass( loadAlert, 'hidden' )
							
						})
						scope.attachListener( loadAlertBtn[0], 'click', function(){
							scope.playAudio('tab-selected')
							obj.saveNewGame( loadContent.getAttribute('target'), false, true )
							scope.addClass( loadAlert, 'hidden' )
						})
						
						scope.attachListener( loadButtons[0], 'click', function(){
							scope.playAudio('tab-selected')
							var target = JSON.parse( localStorage.getItem( 'saveGame' ) )[ loadContent.getAttribute('target') ];
							localStorage.setItem( 'load', scope.JSONstringfy( target ) );
							location.reload()
						})
						
						scope.attachListener( loadButtons[1], 'click', function(){
							scope.playAudio('tab-selected')
							scope.removeClass( loadAlert, 'hidden' )
							scope.addClass( loadContent, 'hidden' )
						})
						
						scope.attachListener( loadButtons[2], 'click', function(){
							scope.playAudio('tab-selected')
							scope.addClass( loadContent, 'hidden' )
						})
						
						
						//perform save game;
						//save
						scope.attachListener( saveAlertBtn, 'click', function(){
							scope.playAudio('tab-selected')
							scope.addClass( saveAlert, 'hidden' )
						})
						
						scope.attachListener( saveButtons[1], 'click', function(){
							scope.playAudio('tab-selected')
							scope.addClass( saveContent, 'hidden')
						})
						scope.attachListener( saveButtons[0], 'click', function(){
							scope.playAudio('tab-selected')
							var input = scope.nthParent( this, 2 ).getElementsByTagName('input')[0],
							saveText = scope.encodeStr( input.value );
							
							if( saveText.length  ){
								//save
								obj.saveNewGame( saveText, input )
								
							}else{
								input.focus()
							}
						})
						
						
					},
					saveNewGame : function( saveText, input, pass ){
						var saveGame = JSON.parse( localStorage.getItem( 'saveGame') );
					
						if( !!saveGame && Object.keys( saveGame ).length < 5 || saveGame === null || pass ){
							
							//console.log( Object.keys( localStorage ).length < 5 )
							//console.log( pass )
							
							//overwrite bag and slot location before save
							var loot = scope.characterInventoryBag['value'].get( scope.oval['value'].label ),
							charSkills = scope.characterSkills['value'].get( scope.oval['value'].label );
							
							obj.checkBagLocation( slots, loot, 'bag' );
							obj.checkBagLocation( allSkill, charSkills, 'skill' );
							
							scope.characterSkillDisable['value']('enable');// prevent error
							
							var charBag = scope.characterInventoryBag['value'].get(scope.oval["value"].label ),
							charParams = scope.characterParameters['value'],
							charaQuest = scope.characterQuest['value'].storage,
							charaSkills = scope.characterSkills['value'].get( scope.oval["value"].label  )
							activeMap = scope.activeMap['value'],
							regMagicItem = scope.registerMagicBoxItem['value'].storage,
							itemShop = scope.itemShop['value'].get('global'),
							forceGravity = scope.oval['value'].forceGravity
							test = true;
							pathPoint = {
								userPoint : scope.oval['value'].position,
								map : activeMap
							},
							format =  {
								charPoints : pathPoint,
								charBag : charBag,
								charParams : charParams,
								charQuest : charaQuest,
								charForceGravity : forceGravity,
								regMagicItem :  regMagicItem,
								charSkills : scope.JSONstringfy( charaSkills ), //bug convert string first
								systemSkills : scope.JSONstringfy( scope.items['value'].skills ),
								itemShop : itemShop
							}
							
							
							scope.addClass( saveContent, 'hidden')
							scope.addClass( loadContent, 'hidden')
							
							var newTitle = {}
							
							if( saveGame ){
								for(var ii in saveGame ){
									if( ii === saveText ){
										saveGame[ii] = format
										test = false;
										break;
									}
								}
								
								
								newTitle[ saveText ] =  format
								
								if( test ){
									scope.extend( saveGame, newTitle )
								}
							}else{
								saveGame = {};
								newTitle[ saveText ] = format 
								scope.extend( saveGame, newTitle )
							}
							
							var params = scope.JSONstringfy( saveGame );
							localStorage.setItem( 'saveGame', params );
							
							saveCnt.innerHTML = '';
							obj.loadSaveGame()
							input && ( input.value = '' );
						}else{
							scope.removeClass( saveAlert, 'hidden' )
							scope.addClass( saveContent, 'hidden')
							input && ( input.value = '' );
						}
					},
					installGlobalSaveGame : function(){
						
						var setTime = setInterval(function() {
							if( scope.globalSaveLoad['value'] ){
								scope.globalSaveLoad['value'] = function(){
									obj.charDetail({					
										params : scope.characterParameters['value'],
										box : staticDetail
									});
									obj.fetchLoot();
									obj.fetchSkill();
									obj.fetchSkillOnload();
								}
								
								scope.globalSaveGame['value'] = obj.saveNewGame;
								
								clearInterval( setTime );
							}
						},100);
						/**/
					},
					checkLoadGame : function(){
						var load = localStorage.getItem('load'),
						loadParams;
						if( load ){
							loadParams = JSON.parse( load );
							var setTime = setInterval(function() {
								if( scope.globalLoadGame['value'] ){
									scope.globalLoadGame['value']( loadParams.charPoints.map, loadParams  );
									localStorage.removeItem('load')
									clearInterval( setTime );
								}
							},100);
						}else{
							scope.removeClass( scope.qs('loading-ui'), 'hidden');
							scope.addClass( scope.qs("loading-assets"), "hidden" )
						}
					}, 
					checkBagLocation : function( slot, loot, init ){
						
						var slot = slot == "default" ? slots : slot;
						
						//clear each of item loot to prevent redudant
						for(var jj = 0; jj < loot.length ; jj++ ){
							if( init === 'bag' )
								loot[jj].bagLocation = '';
							else
								loot[jj].slotLocation = '';
						}
						
						for(var ii = 0; ii < slot.length; ii++){
							var item = scope.getFirstChild( slot[ii] );
							if( item.getAttribute ){
								var label = item.getAttribute( 'label' ) 
								if( label ){
									for(var jj = 0; jj < loot.length ; jj++ ){
										if( label === loot[jj].label ){
											if( init === 'bag' ){
												loot[jj].bagLocation = item.parentNode.id ;
											}else{
												loot[jj].slotLocation = item.parentNode.id ;
											}
											
											break;
										}
									}
								}
							}
						}
					},
					GUImobile : {
						isFirstLoad : false,
						heightInventory : 0,
						transformInventory : 0,
						itemWWHH : {
							inventory : 0,
							skill : 0
						},
						previousItem : '',
						firstLoad : function(){
							
							this.layoutMobile();
							this.hideItemCntOverflow('hidden');
							
							if( !this.isFirstLoad ){
								this.tabsInventory()
								this.tabsMainGUI();
								this.tabsControl();
								this.isFirstLoad = true;
							}
						},
						hideItemCntOverflow : function ( init ){
							var cntReac = scope.qs('items-bag-mb').getBoundingClientRect();
							for(var ii = 0 , jj = itemsBag.length; ii < jj ; ii++ ){
								if( init === 'hidden' ){
									var slotReac = itemsBag[ii].getBoundingClientRect();
									if( cntReac.bottom < slotReac.bottom || slotReac.top + 5 <  cntReac.top ){ // 5 inventory bug nexus's screen
										itemsBag[ii].style.opacity = 0;
									}else{
										itemsBag[ii].style.opacity = 1;
									}
								}else{
									itemsBag[ii].style.opacity = 1;
								}
							}
						},
						replaceSkills : function( init ){
							var passiveItemSkillMB =  scope.slice( scope.qs('items-slot-skill-mb').getElementsByTagName('li') ),
							activeItemSkillMB =  scope.slice( scope.qsAll('slot-mb') ),
							replace = function( slotActive, slotPassive ){
								for(var ii = 0, jj = slotActive.length; ii < jj ; ii++ ){
									var itemSkill = slotActive[ii].getElementsByTagName('div'),
									attA = slotActive[ii].getAttribute('att');
									if( itemSkill.length ){
										for(var kk = 0, ll = slotPassive.length; kk < ll ; kk++ ){
											var attB = slotPassive[kk].getAttribute('att');
											if( attA === attB ){
												itemSkill[0].setAttribute('style','')
												slotPassive[kk].appendChild( itemSkill[0] );
												break;
											}
										}
										
									}
								}
							};
							
							if( init === 'attach'){
								replace( activeItemSkillMB, passiveItemSkillMB )
							}else{
								replace( passiveItemSkillMB, activeItemSkillMB )
							}
						},
						replacePotions : function( init ){
							var hpPotionMb = hpSlotMb.getElementsByTagName('div'),
							mpPotionMb = mpSlotMb.getElementsByTagName('div'),
							hpPotion = scope.slotButtonHp.getElementsByTagName('div'),
							mpPotion = scope.slotButtonMp.getElementsByTagName('div');
							
							
							if( init === 'attach'){
								if( hpPotionMb.length ){
									scope.slotButtonHp.appendChild( hpPotionMb[0] );
									obj.markPotions()
								}
								if( mpPotionMb.length ){
									scope.slotButtonMp.appendChild( mpPotionMb[0] )
									obj.markPotions()
								}
							}else{
								if( hpPotion.length ){
									hpSlotMb.appendChild( hpPotion[0] );
								}
								if( mpPotion.length ){
									mpSlotMb.appendChild( mpPotion[0] )
								}
							}
								
						},
						infoItemToogle : function( init, target ){
							if( init === 'char'){
								scope.removeClass( scope.qs('item-info-detail'), 'active' );
								scope.addClass( scope.qs('chara-info-detail'), 'active' );
								obj.charDetail({					
									params : scope.characterParameters['value'],
									box : staticDetail
								});
							}else{
								scope.removeClass( scope.qs('chara-info-detail'), 'active' );
								scope.addClass( scope.qs('item-info-detail'), 'active' );
								obj.itemDetail( target ) 
								
								this.previousItem = target;
							}
							
						},
						layoutMobile : function(){
							//inventory's layout
							var inventoryMb = scope.qs('items-bag-mb').offsetHeight
							scope.css( scope.qs('items-bag-mb') , { 
								'width': inventoryMb +'px', 
							})
							
							var equipMb = scope.qs('items-bag-mb').offsetHeight / 5; 
							scope.css( scope.qs('items-equipment-mb') , { 
								'width': equipMb +'px', 
							})
							
							scope.css( scope.qs('items-hidden-potion-mb') , { 
								'width': equipMb +'px', 
								'height': inventoryMb +'px', 
								'margin-left': -(equipMb + 30)+'px'//30 provided from margin
							})
							 
							var itemInfoMb = scope.qs('cnt-bag-mb').offsetWidth - inventoryMb - equipMb - 35;//30 margin left/right;
							scope.css( scope.qs('items-info-mb') , { 
								'width': itemInfoMb +'px', 
							})
						
							//skill's layout
							var cntSkillMb = scope.qs('items-skill-mb').offsetHeight,
							skillMb = cntSkillMb / 5 ; 
							
							scope.css( scope.qs('items-skill-mb') , { 
								'width': ( cntSkillMb - skillMb ) +'px', 
							})
							
							var availableSkill = scope.qs('items-skill-mb').getElementsByTagName('li'),
							WWHHSlotskill = availableSkill[0].offsetWidth;
							for(var ii = 0; ii < availableSkill.length ; ii++){
								scope.css( availableSkill[ii] , { 
									'height': ( WWHHSlotskill - 2 ) +'px'
								})
							}
							
							var slotSkillMbEl = scope.qs('items-slot-skill-mb').getElementsByTagName('li'),
							cntSkillMbEl = scope.qs('items-slot-skill-mb').getElementsByTagName('ul')[0];
							
							scope.css( scope.qs('items-slot-skill-mb') , { 
								'width': ( ( WWHHSlotskill - 2 ) * 2  + 4 )  +'px',  //4 from border
							})
							
							
							for(var ii = 0; ii < slotSkillMbEl.length ; ii++){
								scope.css( slotSkillMbEl[ii] , { 
									'width': ( WWHHSlotskill - 2 ) +'px',
									'height': ( WWHHSlotskill - 2 ) +'px'
								})
							}
							
							scope.css( cntSkillMbEl, { 
								'margin-top': skillMb +'px',
							})
							
							
							var itemInfoMb = scope.qs('cnt-skill-mb').offsetWidth - scope.qs('items-skill-mb').offsetWidth - scope.qs('items-slot-skill-mb').offsetWidth - 35;//30 margin left/right;
							
							scope.css( scope.qs('items-info-skill-mb') , {
								'width': itemInfoMb +'px'
							})
							
							
							//quest's layout
							var cntQuestMb = scope.qs('items-quest-mb').offsetHeight ; 
							
							scope.css( scope.qs('items-quest-mb') , { 
								'width': cntQuestMb +'px' 
							})
							
							var itemInfoMb = scope.qs('cnt-quest-mb').offsetWidth - scope.qs('items-quest-mb').offsetWidth - 15;//30 margin left;
							
							scope.css( scope.qs('items-info-quest-mb') , { 
								'width': itemInfoMb +'px', 
								'margin-left': '15px'
							})
							
							//// control's layout
							var cntQuestMb = scope.qs('items-control-mb').offsetHeight							; 
							
							scope.css( scope.qs('items-control-mb') , { 
								'width': cntQuestMb - ( cntQuestMb / 4  )+'px' 
							})
							
							var itemInfoMb = scope.qs('cnt-control-mb').offsetWidth - scope.qs('items-control-mb').offsetWidth - 15;//30 margin left;
							
							scope.css( scope.qs('items-info-control-mb') , { 
								'width': itemInfoMb +'px', 
								'margin-left': '15px'
							})
							
							
							this.heightInventory = scope.id('slot-a-mb').offsetHeight * 5;
							this.transformInventory = -(equipMb + 30) ;
							this.itemWWHH.inventory = equipMb;
							this.itemWWHH.skill = ( WWHHSlotskill - 2 )
							
							
						},
						tabsInventory : function(){
							scope.attachListener( scope.qs('chara-info-detail'), 'click', function(){
								scope.playAudio('tab-selected')
								staticDetail.innerHTML = '';
								this.infoItemToogle('char');
							}.bind(this))
							
							scope.attachListener( scope.qs('item-info-detail'), 'click', function(){
								scope.playAudio('tab-selected')
								staticDetail.innerHTML = '';
								this.infoItemToogle( 'item', this.previousItem );
							}.bind(this))
						},
						tabsMainGUI : function(){
							var self = this,
							btnsAll = scope.slice( scope.qs('container-menu-mb').getElementsByTagName('li') ),
							btns = btnsAll.splice( 0 , 4),
							contentLi = scope.slice( document.querySelectorAll( '.tab-list-content-mb > li') );
							
							
							for( var ii = 0; ii < btns.length; ii++ ){
								scope.attachListener( [ btns[ii], sortCutnBtnMb[ ii + 1 ] ], 'click', function( element, index ){
									
									scope.removeClass( gui, 'hidden' )
									
									for( var jj = 0; jj < btns.length; jj++ ){
										scope.removeClass( btns[jj], 'active-tab-mb' );
										scope.removeClass( contentLi[ jj ], 'active-detail-mb' );
									}
									scope.addClass( element, 'active-tab-mb' );
									
									scope.addClass( contentLi[ index ], 'active-detail-mb' );
									
									this.layoutMobile();
									
									this.replaceSkills('attach');
									
									//hide overflow scroll li 
									scope.scrollSlideParams.fn()
							 
									obj.fetchQuest();
									 
									scope.dragBar();
									 
									scope.removeClass( sortCutnExpand, 'expand')
									scope.css( scope.qs('hidden-menu') , { 
										'transform': '0px,0px,0px', 
										'transition' : 'transform 450ms ease-in-out'
									}) 
									
									
									scope.playAudio('tab-selected');
									
								}.bind( this, btns[ii], ii ))
							}
							
							//button close
							scope.attachListener( btnsAll[0], 'click', function(){
								scope.addClass( scope.qs('gui-player-mb'), 'hidden' );
								this.replaceSkills('detached');
								scope.playAudio('inventory-close');
								window.scope.blockRender = false;
							}.bind( this ))
							
						},
						
						tabsControl : function(){
							var tabs = scope.slice( scope.qs('items-control-mb').getElementsByTagName('li') );
							for( var ii = 0, jj = tabs.length; ii < jj ; ii++ ){
								scope.attachListener( tabs[ ii ], 'click', function( el, index ){
									for( var kk = 0, ll = el.length ; kk < ll ; kk++ ){
										scope.removeClass( el[ kk ], 'active' )
									}
									
									scope.addClass( scope.qs('tab-performance-mb'), 'hidden' )
									scope.addClass( scope.qs('tab-save-game-mb'), 'hidden' )
									scope.addClass( scope.qs('tab-volume-mb'), 'hidden' )
									scope.addClass( scope.qs('tab-information-mb'), 'hidden' )
									scope.addClass( scope.qs('tab-kontribusi-mb'), 'hidden' )
									
									if( index === 0 ){
										scope.removeClass( scope.qs('tab-performance-mb'), 'hidden' );
										scope.addClass( el[ index], 'active' );
									}else if( index === 1 ){
										scope.removeClass( scope.qs('tab-volume-mb'), 'hidden' )
										scope.addClass( el[ index ], 'active' );
									}else if( index === 2 ){
										scope.removeClass( scope.qs('tab-information-mb'), 'hidden' )
										scope.addClass( el[ index ], 'active' );
									}else if( index === 3 ){
										scope.removeClass( scope.qs('tab-kontribusi-mb'), 'hidden' )
										scope.addClass( el[ index ], 'active' );
									}else if( index === 4 ){
										scope.removeClass( scope.qs('tab-save-game-mb'), 'hidden' )
										scope.addClass( el[ index ], 'active' );
									}else{
										scope.removeClass( scope.qs('exit-alert'), 'hidden' );
									}
									
								}.bind( this, tabs, ii ))
							}
						}
					},
					GUITowerDef : function(){
						var GUIDef =  scope.qs("gui-tower-def"),
						infoRemaining = scope.qs("info-remaining"),
						questRemaining = scope.qs("quest-remaining"),
						enemyRemaining = scope.qs("enemy-remaining"),
						remainingBox = scope.qs("remaining-box"),
						remainingBoxClose = scope.qs("remaining-box").getElementsByTagName("button")[0],
						remainingContent = scope.qs("remaining-content"), 
						labelRemaining = "",
						menuProfile = scope.qs("menu-profile"),
						cntHero = scope.qs("cnt-hero"),
						cntMap = scope.qs("cnt-map"),
						activeMap = "mapDungeonH",
						cntVillant= scope.qs("cnt-villant"),
						cntProfile = scope.qs("cnt-profile"),
						cntProfileDetail =  scope.qs("cnt-profile-detail"),
						cntProfilePopup = scope.qs("cnt-profile-pop-up"),
						cntSkillDetail = scope.qs("cnt-skill-detail"),
						boxHero = scope.qs("box-hero"),
						boxVillant = scope.qs("ul-villant"),
						boxProfile = scope.qs("box-profile"),
						boxProfileDetail = scope.qs("box-profile-detail"),
						boxProfilePopup = scope.qs("box-profile-pop-up"),
						boxSkillDetail = scope.qs("box-skill-detail "),
						fnPropNpc = function( prop ){
							return prop.initArmored ? prop.initArmored :
								   prop.initArhcer ? prop.initArhcer :
								   prop.initMage ? prop.initMage :
								   prop.initSpear ? prop.initSpear : prop.initStatic;
						},
						fnNext = function( currentBtn, nextBtn ){
							
							currentBtn.querySelectorAll('.button-next').forEach(function( button ){
								scope.attachListener( button, 'click', function(){
									
									scope.playAudio('tab-selected')
									
									scope.removeClass( currentBtn, "hide-previous")
									scope.removeClass( currentBtn, "show-previous")
									scope.removeClass( currentBtn, "show-next")
									scope.addClass( currentBtn, "hide-next")
									setTimeout(function(){
										scope.addClass( currentBtn, "hidden")
										scope.removeClass( currentBtn, "hide-next")
										//next box
										scope.removeClass( nextBtn, "hidden")
										setTimeout(function(){ scope.addClass( nextBtn, "show-next") },20)
									},350)
								})
							})
							
						},
						fnPrevious = function( currentBtn, nextBtn ){
							
							currentBtn.querySelectorAll('.button-previous').forEach(function( button ){
								scope.attachListener( button, 'click', function(){
									
									scope.playAudio('tab-selected')
							
									scope.removeClass( currentBtn, "hide-next")
									scope.removeClass( currentBtn, "show-next")
									scope.removeClass( currentBtn, "show-previous")
									scope.addClass( currentBtn, "hide-previous")
									setTimeout(function(){
										scope.addClass( currentBtn, "hidden")
										scope.removeClass( currentBtn, "hide-previous")
										//previous box
										scope.removeClass( nextBtn, "hidden")
										setTimeout(function(){ scope.addClass( nextBtn, "show-previous") },20)
									},350)
								})
							})
							
						},
						fnCnTHidden = function( target, container, callback){
									
							var el = target,
							body = scope.qs("gui-tower-def "),
							docBound = body.getBoundingClientRect(),
							elBound =  el.getBoundingClientRect();
							
							scope.removeClass( container, "hidden" )
							scope.addClass( container, "show-menu" )
							
							var profileBound =  container.getBoundingClientRect()
							
							
							if( elBound.left + profileBound.width < docBound.right ){
								scope.css( container,{
									"margin-left" : elBound.left + elBound.width +"px"
								})
							}else  {
								scope.css( container,{
									"margin-left" : elBound.left - profileBound.width+"px"
								})
							}
							
							
							//flip when overflow
							if( profileBound.left < docBound.left ||  profileBound.right > docBound.right ){
								if( profileBound.right > docBound.right  ){
									scope.css( container,{
										"margin-left" : elBound.left - profileBound.width+"px"
									})
								}else if( profileBound.left < docBound.left ) {
									scope.css( container,{
										"margin-left" : elBound.left + elBound.width +"px"
									})
								}
							}
							
							callback && callback()
							
						},
						fnCnTHiddenWithNoBound = function( container, callback){
							
							scope.removeClass( container, "gui-hidden" );
							
							scope.removeClass( container, "hidden" );
							scope.addClass( container, "show-menu" );
							callback && callback();
						},
						fnGenerateBoxRemaining = function( label ){
							
							var monsterControl = scope.globalAnimation["value"].monsterControl,
							count = 0;
							remainingContent.innerHTML = "",
							remainingText = label === "enemy" ? 
								owlData.lang.fn( "gui", "htmlGUI", "enemyText"  ) :
								owlData.lang.fn( "gui", "htmlGUI", "towText" );
							
							for(var ii = 0, jj = monsterControl.objSpawnMonster; ii < jj.length; ii++ ){
								
								var  spawnObj = jj[ii];
								spawnObj.forEach(function( objSpawn ){
									
									var li = document.createElement("li"),
									divAvatar = document.createElement("div"),
									divOverflow = document.createElement("div"),
									objFreeze = typeof objSpawn.freeze !== "undefined" ? objSpawn.freeze : false;
									   
									divAvatar.className = objSpawn.avatarClass;
									divOverflow.className = "spawn-overflow";
									
									li.appendChild( divAvatar );
									
									addOverflow = true;
									
									if( objSpawn.currentRespawn &&
									objSpawn.currentRespawn >= objSpawn.respawnLimit && 
									objSpawn.monsters.length === 0 && 
									!objFreeze ){
										addOverflow = false;
									}
									
									
									if( label === "enemy" && !/hero|tower/i.test( objSpawn.initialSpawn )  ){
										 
										addOverflow && count++;
										 
										!addOverflow && li.appendChild( divOverflow );
										
										remainingContent.appendChild( li );
										 
										scope.text( scope.qs("num-enemy"), count  );
										 
										
									}else if( label === "tower" && /tower/i.test( objSpawn.initialSpawn ) ){
										
										addOverflow && count++;
										 
										!addOverflow && li.appendChild( divOverflow );
										
										remainingContent.appendChild( li );
										
										
										scope.text( scope.qs("num-tower"), count );
										
									}
									  
									 
								})
							}
							 
							scope.text( scope.qs("msg-remaining"), count + remainingText );
							
						}
						
						//info remaining
						 
						scope.attachListener( remainingBoxClose, 'click', function(){ 
						
							scope.playAudio('tab-selected')
							
							if( this.getAttribute( "init" ) === "reload" )
								location.reload();
							else
								scope.addClass( remainingBox, "hidden" );
							
							window.scope.blockRender = false;
						})
						
						scope.attachListener( enemyRemaining, 'click', function(){ 
						
							scope.playAudio('tab-selected')
							
							scope.addClass( enemyRemaining, "hidden" )
							scope.removeClass( remainingBox, "hidden" )
							
							labelRemaining = this.getAttribute("label");
							
							fnGenerateBoxRemaining(labelRemaining );
							
							scope.removeClass( scope.qs("eliminate-box"), owlData.lang.fn( "gui", "bgPop", "towersLeft" ) );
							scope.addClass( scope.qs("eliminate-box"), owlData.lang.fn( "gui", "bgPop", "enemiesLeft" ) );
							
							window.scope.blockRender = true;
							
						})
						
						scope.attachListener( questRemaining, 'click', function(){ 
							
							scope.playAudio('tab-selected')
							
							scope.addClass( questRemaining, "hidden" )
							scope.removeClass( remainingBox, "hidden" )
							
							labelRemaining = this.getAttribute("label");
							
							fnGenerateBoxRemaining( labelRemaining );
							
							scope.removeClass( scope.qs("eliminate-box"), owlData.lang.fn( "gui", "bgPop", "enemiesLeft" ) )
							scope.addClass( scope.qs("eliminate-box"), owlData.lang.fn( "gui", "bgPop", "towersLeft" ) )
							
							window.scope.blockRender = true;
						})
						
						scope.attachListener( infoRemaining, 'click', function(){ 
							
							
							scope.playAudio('tab-selected')
							
							scope.removeClass( enemyRemaining, "hidden" );
							scope.removeClass( questRemaining, "hidden" );
							scope.removeClass( infoRemaining, "show" );
							
							
							fnGenerateBoxRemaining( "enemy" );
							fnGenerateBoxRemaining( "tower" );
							
							setTimeout(function(){
								
								scope.addClass( enemyRemaining, "show" );
								scope.addClass( questRemaining, "show" );
								scope.addClass( infoRemaining, "hidden" );
								
								setTimeout(function(){
								
									scope.removeClass( enemyRemaining, "show" )
									scope.removeClass( questRemaining, "show" )
									
									scope.removeClass( infoRemaining, "hidden" )
									scope.addClass( infoRemaining, "show" )
									
									setTimeout(function(){
								
										scope.addClass( questRemaining, "hidden" )
										scope.addClass( enemyRemaining, "hidden" )	
										
									}, 200)
									
								}, 5000)
								
							}, 200)
							
						})
						 
						
						
						/**************************/
						
						 
						/*cnt-profile generate label*/
						
						//npc profile
						var heroFirstLoad = false;
						for( var ii in owlData.NPC ){
							var npc = owlData.NPC[ii];
							if( !/spawn/i.test( ii ) ){
								//create cnt
								var li = document.createElement("li"),
								divAva =document.createElement("div"),
								divSelected =document.createElement("div");
								li.setAttribute( "label", ii )
								var fnCntClone = function( init ){
									
									var divAvaClone = divAva.cloneNode( true ),
									divSelectedClone = divSelected.cloneNode( true ),
									liClone = li.cloneNode( true );
									
									divAvaClone.className = avatarClass ?  avatarClass : "girl-armored";
									liClone.appendChild( divAvaClone );
									
									if( npc[jj].npcType  ){
										var selectedText;
										if( /character/i.test( npc[jj].npcType )  ){
											selectedText = init ? init : "HERO";
											divSelectedClone.className = "selected red";
										}else if( /tower/i.test( npc[jj].npcType ) ){
											selectedText = "TOWER";
											divSelectedClone.className = "selected blue";
										}else{
											selectedText = "LEADER";
											divSelectedClone.className = "selected orange";
										}
										
										if( init === "LEADER" && !heroFirstLoad ){ //hero box add class "selected" at first loop li onload
											scope.addClass( divSelectedClone, "hidden" )
											heroFirstLoad = true;
										}	
										
										scope.text( divSelectedClone, selectedText )
										liClone.appendChild( divSelectedClone )
									}
									return liClone;
								};
								
								for( var jj in npc ){
									var avatarClass = npc[jj].avatarClass;
									
									npc[jj].label = ii;
									
									/*hero profile*/
									npc[jj].npcType === "character" && boxHero.appendChild( fnCntClone("LEADER") )
									
									/*menu profile*/
									boxProfile.appendChild( fnCntClone() )
									
									
								}
							}
						}
							
						cntProfile.querySelectorAll('li').forEach(function( li, index, cntLi ){
							
							scope.attachListener( li, "click" , function(){
								var el = this,
								cntLi = scope.slice( boxProfileDetail.querySelectorAll('li') ),
								textFn = function( text ){
									return owlData.lang.fn( "gui", "charaGUI", text ) 
								};
								
								scope.playAudio('tab-selected')
								
								fnCnTHidden( el, cntProfileDetail, function(){
									self : for( var ii in owlData.NPC ){
										var npc = owlData.NPC[ii],
										elToText = function( parent, text, prop ){

											var el = document.createElement("div");
											
											var title = scope.getFirstChild( parent );
											scope.getLastChild( parent ).remove();
											
											if( "modifier" === text ){
												scope.addClass( parent, "hidden" );
												
												title.style.width = "100%"
												
												for( var jj in prop ){
													
													if( prop[jj] > 0 ){
														switch(jj){
															case "stun" : name = prop[jj]+"% "+ textFn( "stun" ); break;
															case "avoid" : name = prop[jj]+"% "+ textFn( "avoidance" ); break;
															case "block" : name = prop[jj]+"% "+ textFn( "block" ); break;
															case "critical" : name = prop[jj]+"% "+ textFn( "critical" );  break;
															case "criticalChance" : name = prop[jj]+"%  "+ textFn( "criticalChance" );   break;
															default : name = jj;
														}
														
														var elChild = document.createElement("div")
														
														scope.text( elChild, name );
														el.appendChild( elChild );
														scope.removeClass( parent, "hidden" ); 
													}
												}
												 
												
											}else if( "m-level" === text ){
												
												if( !prop ) scope.addClass( parent, "hidden" );
												else scope.removeClass( parent, "hidden" );
												
												title.style.width = "100%";
												parent.style.border = "none"
												  
												var elChild = document.createElement("div");
												elChild.className = "m-level cyan";
												scope.text( elChild, prop );
												el.appendChild( elChild );
												
												scope.attachListener( elChild, "click" , function(){ 
												
													scope.playAudio('tab-selected')
							
													var boxLi = boxSkillDetail.getElementsByTagName("li")[0];
													
													fnCnTHiddenWithNoBound( cntSkillDetail, function(){
														scope.text( scope.getFirstChild( boxLi ),"Tingkat Kemampuan Musuh")
														scope.text( scope.getLastChild( boxLi ),"Musuh memiliki Tingak Kesulitan ( "+ prop +" ), diurutkan dari tingakatan terlemah hingga terkuat. E, D, C, B, A, S")
													});
												})
												
													
											}else if( "skill" === text ){
												
												scope.addClass( parent, "hidden" );
												title.style.width = "100%";
												for( var jj in prop ){
													var elChild = document.createElement("div");
													elChild.className = "m-level "+jj;
													el.appendChild( elChild );
													scope.removeClass( parent, "hidden" );
													 
													
													scope.attachListener( elChild, "click" , function( index ){ 
													 
														scope.playAudio('tab-selected')
							
														var boxLi = boxSkillDetail.getElementsByTagName("li")[0];
														
														fnCnTHiddenWithNoBound( cntSkillDetail, function(){
															scope.text( scope.getFirstChild( boxLi ), 
															owlData.lang.fn( "gui", "charaGUI", "skillTalent" ) + 
															owlData.lang.fn( "skill", index, "displayName" ));
															scope.text( scope.getLastChild( boxLi ), owlData.lang.fn( "skill", index, "detail" ) );
														});
														
													}.bind( {}, jj ))
													
												}
												
											} else{
												scope.text( el, text );
											}
											
											parent.appendChild( el )
										};
										if( !/spawn/i.test( ii ) ){
										
											for( var jj in npc ){
												if( el.getAttribute("label") === npc[jj].label ){
													
													var prop = npc[jj];
													elToText( cntLi[0], prop.name );
													elToText( cntLi[1], prop.maxHealth );
													elToText( cntLi[2], prop.mp );
													elToText( cntLi[3], prop.attackRangeMin +' - '+ prop.attackRangeMax );
													elToText( cntLi[4], prop.attackMin +' - '+ prop.attackMax );
													elToText( cntLi[5], prop.defenseMin +' - '+ prop.defenseMax );
													elToText( cntLi[6], prop.magicDefenseMin +' - '+ prop.magicDefenseMax );
													
													elToText( cntLi[7], "modifier", prop.modifierAbilities );
													elToText( cntLi[8], "skill", prop.abilitySkill, prop.monsterLevel );
													elToText( cntLi[9], "m-level", prop.monsterLevel );
													
													break self;
												}
											}
										}
									}
								})
								
							})
							
						})
						
						
						/*menu profile*/
						var flip = true
						scope.attachListener( menuProfile, 'click', function(){ 
							
							scope.playAudio('tab-selected')
							
							if(/show-menu/i.test( cntProfile.className ) && flip ){
								scope.removeClass( cntProfile, "show-menu" );
								scope.removeClass( cntProfileDetail, "show-menu")
								scope.removeClass( cntProfilePopup, "show-menu")
								flip = false;
								scope.removeClass( menuProfile, "menuclose" );
								setTimeout(function(){
									scope.addClass( cntProfile, "hidden" );
									scope.addClass( cntProfileDetail, "hidden")
									scope.addClass( cntProfilePopup, "hidden")
									flip = true;
								},350);
								
								GUIDef.querySelectorAll('.cnt-tower-def').forEach(function( div ){
									if( !/cnt-profile/i.test( div.className ) ){
										scope.removeClass( div, "gui-hidden" )
									}
								})
								
								
							}else if( flip ){
								scope.removeClass( cntProfile, "hidden" )
								scope.removeClass( cntProfilePopup, "show-menu")
								flip = false;
								setTimeout(function(){
									scope.addClass( cntProfile, "show-menu" )
									scope.addClass( cntProfilePopup, "hidden")
									flip = true;
									scope.addClass( menuProfile, "menuclose" );
								},50);
								
								GUIDef.querySelectorAll('.cnt-tower-def').forEach(function( div ){
									if( !/cnt-profile/i.test( div.className ) ){
										scope.addClass( div, "gui-hidden" )
									}
								})
								
							}
						})
						
						/*cnt-hero*/
						cntHero.querySelectorAll('li').forEach(function( li, index ){
							scope.attachListener( li, 'click', function(){
								
								scope.playAudio('tab-selected')
							
								var el = this,
								parentSibling = scope.sibling( el, !index ? "next" : "previous" ),
								elLastChild = scope.sibling( scope.getFirstChild(li), 'next'),
								siblingLastChild = scope.sibling( scope.getFirstChild( parentSibling ), 'next');
								
								scope.removeClass( elLastChild,"hidden" )
								scope.addClass( siblingLastChild,"hidden" )
								
								
							})
						})
						
						fnNext( cntHero, cntMap )
						fnPrevious( cntMap, cntHero )
						
						/*cnt-peta*/
						cntMap.querySelectorAll('li').forEach(function( li, index, cntLi ){
							scope.attachListener( li, 'click', function(){
								var el = this,
								elFirstChild = scope.getFirstChild(el);
								
								scope.playAudio('tab-selected')
							
								cntLi.forEach(function( li ){
									scope.removeClass(  scope.getFirstChild(li),"red" )
								})
								
								scope.addClass( elFirstChild,"red" );
								activeMap = el.getAttribute("label"); 
								 
								
							})
						})
						
						fnNext( cntMap, cntVillant )
						fnPrevious( cntVillant, cntMap )
						
						
						/*cnt-villant*/
						
						var tempLeader = [];
						var randomVillant = function( hardness ){
							tempLeader.length = 0;
							for( var ii in owlData.NPC ){
								
								if( !/spawn/i.test( ii ) ){
									var propLeader = fnPropNpc( owlData.NPC[ ii ] ),
									party = {};
									
									
									for( var jj in propLeader.spawn ){
										var npcSpawn = propLeader.spawn[ jj ]
									}
									
									if( propLeader.npcType === "monster-leader" ){
										//create cnt
										for( var kk = 0; kk < npcSpawn.length ; kk++ ){
											//pions
											if( npcSpawn[0].pions ){
												var tempPawn = [];
												
												for( var kk in npcSpawn[0].pions ){
													tempPawn.push( fnPropNpc( owlData.NPC[ kk ] ) )
												}
											
												party.pions = tempPawn;
												break;
											}
										}
										
										tempLeader.push( party )
										party.leader = propLeader;
										
									}
									
								}
							}
							
							//suffle
							tempLeader = scope.randomArray( tempLeader ),
							fnCreateVillant = function( prop ){
								//create container
								var li = document.createElement("li"),
								ul = document.createElement("ul"),
								childLi = function( avatarClass, init ){
									var liChild = document.createElement("li"),
									divA =  document.createElement("div"),
									divB =  document.createElement("div");
									
									divA.className = avatarClass ? avatarClass : "girl-armored" ;
									liChild.appendChild( divA );
									
									if( init === "leader" ){
										divB.className = "selected orange";
										scope.text( divB,"LEADER" )
										liChild.appendChild( divB );
									}else{
										liChild.className = "child-villant";
									}
									
									return liChild
								};
								ul.className = "box-villant list-inline";
								
								var liLeader = childLi( prop.leader.avatarClass, "leader" );
								li.setAttribute( "label", prop.leader.label )
								ul.appendChild( liLeader )
								
								prop.pions && prop.pions.forEach(function( chProp ){
									ul.appendChild( childLi( chProp.avatarClass, "pawns" ) )
								})
								
								return {
									parent : li,
									content : ul
								};
							};
							boxVillant.innerHTML = "";
							
							//
							var limit = 0,
							generateVillant = function( lvl ){
								for(var ii = 0; ii < tempLeader.length ; ii++ ){
									var prop = tempLeader[ii],
									domLi = function(){					
										limit++;
										var cnt = fnCreateVillant( prop );
										cnt.parent.appendChild( cnt.content )
										boxVillant.appendChild( cnt.parent );
									};
									
									if( hardness === "hard" ){
										if( lvl === "hig" && /s/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 1 ) break; 
										}
										
										if( lvl === "midhig" && /a/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 3 ) break; 
										}
										
										if( lvl === "mid" && /b/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 5 )break; 
										}
										
										if( lvl === "low" && /c|e|d/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 7 )break; 
										}
									}else if( hardness === "normal" ){
										if( lvl === "hig" && /s/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 0 ) break; 
										}
										
										if( lvl === "midhig" && /a/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 1 )break; 
										}
										
										
										if( lvl === "mid" && /b/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 3 )break; 
										}
										
										if( lvl === "low" && /c|d|e/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 6 )break; 
										}
									}else if( hardness === "easy" ){
										if( lvl === "hig" && /a/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 0 ) break; 
										}
										
										if( lvl === "midhig" && /b/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 2 )break; 
										}
										
										if( lvl === "mid" && /c/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 3 )break; 
										}
										
										if( lvl === "low" && /e|d/i.test( prop.leader.monsterLevel ) ){
											domLi();
											if( limit > 5 )break; 
										}
									}
								}
							}
							 
							generateVillant("hig");
							generateVillant("midhig");
							generateVillant("mid");
							generateVillant("low");
							
							//attach click event
							var selectedParent = "";
							cntVillant.querySelectorAll(' .ul-villant > li').forEach(function( li, index, cntLi ){
								scope.attachListener( li, "click" , function(){
									
									scope.playAudio('tab-selected')
									
									selectedParent =  this ;
									fnCnTHidden( this, cntProfilePopup, function(){
										var villantBound =  cntVillant.getBoundingClientRect();
										scope.css( cntProfilePopup,{
											"margin-top" :"0px",
											"top" : villantBound.top+"px",
											"height" : villantBound.height - 6 +"px"
										})
									})
									
								})
							})
							
							//store to popup
							boxProfilePopup.innerHTML = "";
							tempLeader.forEach(function( prop ){
								var liChild = document.createElement("li"),
								divA =  document.createElement("div");
								divA.className = prop.leader ? prop.leader.avatarClass : "girl-armored" ;
								liChild.className = "child-villant";
								liChild.appendChild( divA );
								boxProfilePopup.appendChild( liChild );
									
								//attach to click
								scope.attachListener( liChild, "click" , function(){
									
									scope.playAudio('tab-selected')
									if( selectedParent ){
										var cnt = fnCreateVillant( prop );
										selectedParent.setAttribute( "label", cnt.parent.getAttribute("label") ) //replace attribut
										selectedParent.innerHTML = "";
										selectedParent.appendChild( cnt.content );
									}
								})
							})
							
						}
						
						 
						randomVillant("easy");
					
						window.scope.gameLevel = "easy";
						
						cntVillant.querySelectorAll('.button-random-mid').forEach(function( div ){
							scope.attachListener( div, "click" , function(){
								
								scope.playAudio('tab-selected')
								
								window.scope.gameLevel = "normal";
								
								randomVillant("normal");
							})
						})
						
						cntVillant.querySelectorAll('.button-random-hig').forEach(function( div ){
							scope.attachListener( div, "click" , function(){
								
								scope.playAudio('tab-selected')
								
								window.scope.gameLevel = "medium";
								
								randomVillant("hard");
							})
						})
						
						cntVillant.querySelectorAll('.button-random-eas').forEach(function( div ){
							scope.attachListener( div, "click" , function(){
								
								scope.playAudio('tab-selected')
								
								window.scope.gameLevel = "easy";
								
								randomVillant("easy");
							})
						})
						
						cntVillant.querySelectorAll('.button-start').forEach(function( div ){
							scope.attachListener( div, "click" , function(){
								var el = this;
								scope.removeClass( el.parentNode, "show-menu" );
								
								scope.playAudio('tab-selected');
							
								scope.delayFire(function(){
									
									scope.addClass( el.parentNode, "hidden");
									scope.addClass( GUIDef, "hidden");
									
									//capture data
									var data = {},
									fnRegisterSpawnNPC = function( prop ){
										var npcProperty = fnPropNpc( prop.npcProperty );
										
										if( prop.init === "hero" ){
											npcProperty.hero = true;
										}
										
										for( var ii in npcProperty.spawn ){
											if( prop.clear  ){
												prop.parent[ ii ] = [];
											}else{
												
												//reupdate npc properties
												
												if( prop.init === "villant" ){
													if( !prop.parent[ ii ]  ){
														
														prop.parent[ ii ] = npcProperty.spawn[ii];
														prop.parent[ ii ][0].monsterLevel = npcProperty.monsterLevel;
														prop.parent[ ii ][0].name = npcProperty.name;
														
													}else{
														//clone when spawn more than one
														var originProp =  npcProperty.spawn[ii][0],
														cloneProp = {
															monsters : [],
															name : originProp.name,
															objectSpawn : originProp.objectSpawn,
															spawnTotal : originProp.spawnTotal,
															reSpawnTick : originProp.reSpawnTick,
															reSpawnTickFixed : originProp.reSpawnTickFixed,
															respawnLimit: originProp.respawnLimit,
															monsterLevel : originProp.monsterLevel,
															install : false,
															location : ''
														};
														
														if( originProp.pions ) cloneProp.pions = originProp.pions;
														
														prop.parent[ ii ].push( cloneProp );
													}
													

												}else if( /tower|hero/i.test( prop.init ) ){
													var spawnTower = npcProperty.spawn[ii][ activeMap ];
													prop.parent[ ii ] = spawnTower ? spawnTower : [];
												}
												
												// replace spawn location and spawn obj location
												prop.parent[ ii ].forEach(function( obj ){
													
													//for remaining class
													//initialSpawn
													obj.initialSpawn = ii.split("Spawn").join("");
													
													//initialClass
													obj.avatarClass = npcProperty.avatarClass;
													/**************/
													
													var spawnLabel = scope.staticAllMap['value'][ activeMap ].content.staticSpawnLabel;
													 
													if( !/hero|tower/i.test( prop.init ) ) obj.objectSpawn = spawnLabel[ scope.random( spawnLabel.length - 1, 0 ) ];
													
													obj.location = activeMap;
													
													if( prop.init === "villant" ){
														
														obj.freeze = true;
													}
												})
												
											}
										};
									},
									fnRegisterFrameNPC = function( npcProperty, init ){
										
										var dataFrame = owlData.frame.data;
										//extend frame by map
										!owlData.frame[ activeMap ] && ( owlData.frame[ activeMap ] = [] );
										
										if( init === "spawn" ){
											var npcName = npcProperty.split('monsters').join(''),
											npcName = npcName.split('Spawn').join(''); 
										}else{
											var npcName = npcProperty.split('monster').join(''); 
										}
										
										npcName = npcName.charAt(0).toLowerCase() + npcName.slice(1);
										owlData.frame[ activeMap ].push( dataFrame[ npcName ] );
										  
									} 
									//hero
									boxHero.querySelectorAll('li').forEach(function( li ){
										if( li.getElementsByClassName('hidden')[0] ){;
											fnRegisterSpawnNPC({
												init : "",
												npcProperty : owlData.NPC[ li.getAttribute("label") ],
												parent : owlData.NPC,
												clear : true
											})
											
										}else{ //indicate hero leader
											fnRegisterSpawnNPC({
												init : "hero",
												npcProperty : owlData.NPC[ li.getAttribute("label") ],
												parent : owlData.NPC
											})
										}
										
										
										fnRegisterFrameNPC( li.getAttribute("label") )
										
									})
									
									//villant
									var liVillant = GUIDef.querySelectorAll('.ul-villant > li');
									liVillant.forEach(function( li ){
										fnRegisterSpawnNPC({
											init : "villant",
											npcProperty : owlData.NPC[ li.getAttribute("label") ],
											parent : owlData.NPC
										})
									})
									 
									//tower
									var towers = [ "monsterTowerBlue", "monsterTowerRed" , "monsterTowerRedb" ]
									while( towers.length ){
										var tower = towers.pop();
										fnRegisterFrameNPC( tower );
											
										fnRegisterSpawnNPC({
											init : "tower",
											npcProperty : owlData.NPC[ tower ],	
											parent : owlData.NPC
										})
										
									}
									
									
									tempLeader.forEach(function( prop ){
										var leader = prop.leader,
										pawns = prop.pions;
										for( var ii in leader.spawn ){
											if( !owlData.NPC[ii] ){
												owlData.NPC[ ii ] = [];
											}
											
											fnRegisterFrameNPC( ii, "spawn" )
											
										}
										
										if( pawns ){
											pawns.forEach(function( prop ){
												for( var ii in prop.spawn ){
													
													if( !owlData.NPC[ii] ){
														owlData.NPC[ ii ] = [];
													}
													
													fnRegisterFrameNPC( ii, "spawn" )
												}
											})
										}
										
									})
									
									scope.globalLoadGame['value']( activeMap ); // let compile install first
								
									scope.globalAnimation["value"].monsterControl.compile( owlData.NPC, activeMap );
								
									//bug, sometimes loading-ui not close
									scope.addClass( scope.qs('loading-ui'), 'hidden');
									  
									
								},1000);
							})
						})
						
						
						
						/*GUIDef-menu-close*/
						GUIDef.querySelectorAll('.menu-close').forEach(function( div ){
							scope.attachListener( div, "click" , function(){
								
								scope.playAudio('tab-selected')
								
								var el = this
								scope.removeClass( el.parentNode, "show-menu")
								setTimeout(function(){
									scope.addClass( el.parentNode, "hidden")
								},350);
							})
						})
						
						
						//control menu	
						if( isMobile ){
							scope.qs('tab-performance-mb').appendChild( scope.getFirstChild( scope.qs('performance-detail') )  );
							scope.qs('tab-volume-mb').appendChild( scope.getFirstChild( scope.qs('sound-detail') ) );
							scope.qs('tab-information-mb').appendChild( scope.getFirstChild( scope.qs('information-detail') ) );
							scope.qs('tab-kontribusi-mb').appendChild(scope.getFirstChild(  scope.qs('contribution-detail') ) );
						}
						
						
						/*ad money for the first time*/
						var heroGold =  localStorage.getItem('goldHero');
						
						if( !heroGold ){
							scope.updateGoldtoLocalStorageHero["value"]( 30000, { label : "heroArmor"} )
							scope.updateGoldtoLocalStorageHero["value"]( 30000, { label : "heroArcher"} )
						}
						
						
					},
					initShop : function(){
						var self = this,
						shopDetail = scope.qs('shop-detail'),
						shopInfo = scope.qs('shop-detail-item'),
						objShop = {
							selected : {
								charaterParams : scope.characterParameters['value'],
								characterLoot : scope.characterInventoryBag['value'].get( scope.oval["value"].label  ),
								attach : false,
								item : '',
								current : 1,
								itemParams : '',
								initialTimeOut :'',
								initialTimeInverval : '',
								reset : function(){
									this.item = '';
									this.itemParams = '';
									this.current = 1;
								}
								
							},
							objectItems : [],
							items : scope.itemShop['value'].get('global'),
							displayBuyProperties : function( options, selected ){
								var parent = document.createElement('li'),
								item = document.createElement('div'),
								abbrSoul = document.createElement('abbr'),
								itemBox = scope.qs('buy-item-content'),
								itemTitle = scope.qs('buy-title'),
								buyProce = scope.qs('buy-text'),
								displayPrice = scope.qs('price-display'),
								selected = objShop.selected;
								
								scope.text( abbrSoul, ' GOLD '+selected.charaterParams.gold)
								scope.text( itemTitle, options.displayName )
								scope.text( buyProce, options.shop.price+' x '+1 )
								item.className = 'item '+options.className;
								item.setAttribute( 'label', options.label );
								
								abbrSoul.className = 'gold'
								
								itemTitle.appendChild( abbrSoul )
								
								itemBox.innerHTML = '';
								itemBox.appendChild( item );
								
								selected.itemParams = options;
								
								
								scope.text( displayPrice, options.shop.price * selected.current );
								
								
								//listener buy box
								if( !selected.attach ){
									
									selected.attach = true;
									//buttons
									var plus = scope.qs('buy-button-plus'),
									min = scope.qs('buy-button-min'),
									buyButton = scope.qs('buy-button-confirm'),
									plusFn = function( el ){
										var params = selected.itemParams
										if( params.shop && 
										selected.current < params.shop.max 
										&& ( params.shop.price * ( selected.current + 1 ) ) < selected.charaterParams.gold ) selected.current++
										scope.text( buyProce, params.shop.price +' x '+ selected.current );
										scope.text( displayPrice, params.shop.price * selected.current );
										scope.css( el , { 
											'background-size':'30%'
										})
									},
									minFn = function( el ){
										var params = selected.itemParams
										if( selected.current > 1 ) selected.current--
										scope.text( buyProce, params.shop.price +' x '+ selected.current );
										scope.text( displayPrice, params.shop.price * selected.current );
										scope.css( el , { 
											'background-size':'30%'
										})
									};
									
									
									scope.attachListener( buyButton, 'click', function(){
										 
										var params = selected.itemParams,
										tot = params.shop.price * selected.current,
										shopParams = objShop.items[ params.shop.itemName ],
										pass = true;
										
										
										switch( params.itemfor ){
											case "leader" :
												pass = scope.globalAnimation["value"].characterControl.bossObject.label === selected.charaterParams.object.label;
												!pass && 
													scope.pushMsgText['value']( owlData.lang.fn( "gui", "itemLeader", "detail" ), 100 );
												break;
											case "archer":
												pass = selected.charaterParams.classType === "archer";
												!pass && 
													scope.pushMsgText['value']( owlData.lang.fn( "gui", "itemRanger", "detail" ), 100 );
												break;
												
											
										}
										
										
										 
										if( pass ){
											 
											if( tot <= selected.charaterParams.gold ){
												selected.charaterParams.gold -= tot;
												 selected.characterLoot.push (
													new scope.items['value'][ params.shop.root ][ params.shop.itemName ]({ quantity : selected.current })
												)
												
												if( shopParams.available !== '~' )
													objShop.items[ params.shop.itemName ].available --;
												
												scope.pushMsgText['value']( '+'+selected.current+' '+ params.displayName + owlData.lang.fn( "gui", "addItemToInvt", "detail" ) + selected.charaterParams.name, 100 );
												
												obj.attachMainPotions({ updateSlot : true });
												
												scope.updateGoldtoLocalStorageHero["value"]( selected.charaterParams.gold, selected.charaterParams.object )
												
											}else{
												
												scope.pushMsgText['value']( owlData.lang.fn( "gui", "notEnoughGold", "detail" ), 100 );
											} 
										
										}
										
										scope.addClass( shopDialog, 'hidden' );
										scope.addClass( buyBox, 'hidden' );
										
										scope.playAudio('tab-selected')
							
										selected.reset();
										
										window.scope.blockRender = false;
										
									})
								
									scope.attachListener( [ plus, min ], scope.CursorStartEvent , function( ){
										var el = this,
										fn = /buy-button-plus/i.test( el.className ) ? plusFn : minFn;
										clearTimeout( selected.initialTimeOut )
										clearInterval( selected.initialTimeInverval )
										selected.initialTimeOut = setTimeout(function(){
											selected.initialTimeInverval = setInterval(function(){
												fn( el ) 
											},10)
										},1000);
										
										fn( el ) 
										
									})
									scope.attachListener( [ plus, min ], scope.CursorEndEvent , function( ){
										clearTimeout( selected.initialTimeOut )
										clearInterval( selected.initialTimeInverval )
										scope.css( this , { 
											'background-size':'35%'
										})
									})
								
								}
								
							},
							createItem : function( options ){
								
								var parent = document.createElement('li'),
								item = document.createElement('div'),
								price = document.createElement('span'),
								objectItem = new scope.items['value'][ options.root ][ options.itemName ],
								itemClassName = objectItem.className;
								
								options.shopParams.itemName =  options.itemName;
								
								scope.extend( objectItem, { shop : options.shopParams }, true );
								
								item.setAttribute( 'label', objectItem.label )
								
								item.className = 'item '+itemClassName;
								price.className = 'price';
								scope.text( price, options.price );
								
								parent.appendChild( item );
								parent.appendChild( price );
								
								this.objectItems.push( objectItem )
								
								return parent;
								
							},
							
							generateItems : function(){
								for( var ii in this.items ){
									var item = this.items[ii];
									if( item.available ){
										var elLi = this.createItem({
											price : item.price,
											root : item.root,
											itemName : ii,
											shopParams : item
										});
										
										this.attachEvent( elLi )
										
										shopDetail.appendChild( elLi )
									}
								}
								
							},
							attachEvent : function( el ){
								var selected = {
									item : ''
								},
								divITem = el.getElementsByTagName('div')[0],
								startOrHoverItem = function(){
									
									scope.removeClass( shopInfo, 'hidden' );
									
									var item = scope.getFirstChild( el ),
									itemReac = el.getBoundingClientRect(),
									x = scope.mousePosition['value'].pos.mousedown.x,
									parentReac = scope.getFirstChild( shopDialog ).getBoundingClientRect(),
									infoReac = shopInfo.getBoundingClientRect(),
									center = parentReac.left + ( parentReac.width / 2 );
									
									shopInfo.setAttribute('style','');
									
									
											
									if( itemReac.right > center ){
										scope.css( shopInfo , { 
											'left': ( isMobile ? itemReac.left : x ) - ( isMobile ? infoReac.width : parentReac.left + infoReac.width + itemReac.width / 2 )  +'px',
											'border-right' : '2px solid rgba( 0, 0, 0, 0.33 )',
											'text-align' : 'right',
											'position' : 'fixed'
										})
									}else{
										
										scope.css( shopInfo , { 
											'left': ( ( isMobile ? itemReac.left : x ) + itemReac.width  ) - parentReac.left - ( isMobile ? 0 : itemReac.width / 2 ) +'px',
											'border-left' : '2px solid rgba( 0, 0, 0, 0.33 )',
											'text-align' : 'left',
											'position' : 'fixed'
										})
									}
							
									selected.item = self.shopDetail({
										box : shopInfo,
										items : objShop.objectItems, 
										label : item.getAttribute( 'label' ) 
									})
									
								};
								
								
								scope.attachListener( divITem, scope.CursorStartEvent ,  startOrHoverItem )
								scope.attachListener( divITem, scope.CursorMoveEvent ,  startOrHoverItem )
								
								scope.attachListener( divITem, scope.CursorLeaveEvent , function( event ){
									scope.addClass( shopInfo, 'hidden' );
								})
								
								scope.attachListener( divITem, scope.CursorEndEvent , function( event ){
									objShop.displayBuyProperties( selected.item )
									scope.removeClass( buyBox, 'hidden' )
								})
								scope.attachListener( shopDialog, scope.CursorEndEvent , function( event ){
									scope.addClass( shopInfo, 'hidden' );
								})
							}
						}
						
						
						scope.attachListener( shopOpen, 'click', function( e ){ 
						
							/* update params prevent bug when perform load and save game */
							objShop.items =  scope.itemShop['value'].get('global');
							objShop.selected.charaterParams = scope.characterParameters['value'];
							objShop.selected.characterLoot = scope.characterInventoryBag['value'].get( scope.oval["value"].label  );
							
							shopDetail.innerHTML = '';
							objShop.generateItems()
							scope.removeClass( shopDialog, 'hidden' );
							scope.playAudio('tab-selected');
							
							window.scope.blockRender = true;
						})
						
						scope.attachListener( shopBtnClose, 'click', function( e ){ 
							scope.addClass( shopDialog, 'hidden' );
							scope.playAudio('tab-selected');
							
							window.scope.blockRender = false;
						})
					
						
						scope.attachListener( buyBoxBtnClose, 'click', function( e ){ 
							scope.addClass( buyBox, 'hidden' );	
							scope.playAudio('tab-selected');
							
							//reset for selected item
							objShop.selected.reset();
						})
						
					},
					initMiningControl : function(){
						
						var boxConfirm = scope.slice( scope.qs("mining-content").getElementsByTagName("li") ),
						adsBox = scope.qs("ads-box"),
						adsTitle = scope.qs("ads-title"),
						msBox = scope.qs("ms-box"),
						selfInterval, secondLoop,
						preventMining =  false,
						convertMilToTime = function( el, milisecond ){
							
							var m, time, s = Math.floor( milisecond * 33 / 1000   );
						 
							if ( s >= 60 ){
								m = Math.floor( s / 60 )
								time = m+' : '+( s - ( m * 60 ) );
							}else{
								time = ( s < 0 ) ? 1 : s + 1;
							}
							
							scope.text( el, time )
						}
						
						
						//map-box button popup
						scope.attachListener( miningButton, 'click', function()
						{
							
							scope.playAudio('tab-selected');
							
							/hidden/i.test( miningDialog.className ) ?
								scope.removeClass( miningDialog, 'hidden' ) :
								scope.addClass( miningDialog, 'hidden' );
								
							window.scope.blockRender = true;
						})
						
						scope.attachListener( miningBtnClose, 'click', function( e ){ 
							scope.addClass( miningDialog, 'hidden' );
							scope.playAudio('tab-selected');
							
							window.scope.blockRender = false;
						})
					
						//ads-box content
						boxConfirm.forEach(function( li, index ){
							scope.attachListener( li, 'click', function()
							{
								
								if( index === 2 ){
									
									scope.removeClass( msBox, "hidden" );
									
								}else if( index === 1 ||  index === 0 ){
									 
									var seconds = li.getAttribute("label"),
									secondLoop = seconds, selfInterval,
									goldAlreadyAdded = false;
									 
									scope.removeClass( adsBox, "hidden" );
									 
									scope.text( adsTitle,  owlData.lang.fn( "gui", "internetConnection", "internetCheck" ) );

									scope.globalAnimation["value"].blockRender = true;
									
									scope.transport({
										setTimeout : 10000,
										url: "https://api.github.com/search/users?q=hariagustian",
										type:'GET',
										timeoutFn : function(){
											
											scope.text( adsTitle, owlData.lang.fn( "gui", "internetConnection", "serverFail" ) ); 
										
												setTimeout( function(){
													 
													scope.addClass( adsBox, "hidden" );
													
													scope.text( adsTitle,  owlData.lang.fn( "gui", "goldMining", "title" ) );
												 
													scope.globalAnimation["value"].blockRender = false;
														
													
												}, 3000 );
											
										},
										errorFn : function(){
											
											scope.text( adsTitle, owlData.lang.fn( "gui", "internetConnection", "loss" ) ); 
										
											setTimeout( function(){
												 
												scope.addClass( adsBox, "hidden" );
												
												scope.text( adsTitle,  owlData.lang.fn( "gui", "goldMining", "title" ) );
											 
												scope.globalAnimation["value"].blockRender = false;
													
												
											}, 3000 );
											
										},
										callback:function( data ){
											
											if( !preventMining ){ 
											 
												scope.globalAnimation["value"].blockRender = true;
									 
												scope.text( adsTitle,  owlData.lang.fn( "gui", "goldMining", "title" ) );
												
												
												var adsProp = function( options ){
													return {
														eventClose : function(){
															 
															if( !goldAlreadyAdded ){
																
																
																//loading 
																
																scope.removeClass( scope.qs("loading-ads"), "hidden"  );
																 
																var timeAdsEl = scope.qs('time-ads'),
																inMilisec = options.loadingInterval,// 2700, //1.5  minutes
																testTime = setInterval(function(){
																	 
																	if( inMilisec-- ){
																		
																		preventMining = true;
																		
																		convertMilToTime( timeAdsEl, inMilisec )
																		
																	}else{
																										
																		scope.addClass( scope.qs("loading-ads"), "hidden"  )
																		
																		preventMining = false;
																		
																		clearInterval( testTime );
																		
																	}
																	
																	
																},33 )
																
																 
																var miningInSeconds = seconds - secondLoop,
																golds =  Math.abs( miningInSeconds * ( options.rewardGold / seconds ) ),
																	
																charaParams = scope.characterParameters["value"];
																
																charaParams.gold += golds;
																
																scope.pushMsgText['value']( golds + 
																owlData.lang.fn( "gui", "goldMining", "interruptA" ) + 
																miningInSeconds + 
																owlData.lang.fn( "gui", "goldMining", "interruptB" )  +
																charaParams.name, 250 );
													
																scope.addClass( adsBox, "hidden" );
																
																scope.globalAnimation["value"].blockRender = false;
																
																scope.updateGoldtoLocalStorageHero["value"]( charaParams.gold, charaParams.object )
																 
																clearInterval( selfInterval )
																
																goldAlreadyAdded = true;
																
																scope.globalObjectGUI["value"].audioBackground.setVolumeForAds("on")
												 
															}
															
															
														},
														eventOpen : function(){
															
															options.additionFnOpen && 
																	options.additionFnOpen();
															
															selfInterval = setInterval( function(){
														
																if( secondLoop <= 0 ){ 
																
																	secondLoop = 0
																
																	clearInterval( selfInterval );
																	
																	return false;
																	
																}
																
																options.additionalFnLoading && 
																	options.additionalFnLoading();
																 
																secondLoop--;
																
															}, 1000 )
															
															scope.globalObjectGUI["value"].audioBackground.setVolumeForAds("off");
															 
															
														},
														eventLoadfail : function(){
															 
															scope.text( adsTitle, owlData.lang.fn( "gui", "internetConnection", "adsFail" ) ); 
															
															setTimeout( function(){
																 
																scope.addClass( adsBox, "hidden" ); 
															 
																scope.globalAnimation["value"].blockRender = false;
																	
																
															}, 3000 )
															
														},
														eventLoad : function(){},
														evenAdsUndefined : function(){
															
															scope.text( adsTitle, owlData.lang.fn( "gui", "internetConnection", "adsFail" ) ); 
															
															setTimeout( function(){
																 
																scope.addClass( adsBox, "hidden" ); 
															 
																scope.globalAnimation["value"].blockRender = false;
																	 
															}, 3000 )
														}
													}
													
												}
												
												var initBanner = ["r", "e", "n", "n", "a", "b"].reverse().join(""),
												spec = ["l", "a", "i", "t", "i", "t", "s", "r", "e", "t", "n", "i"].reverse().join("");
												
												if( index ){
												
													scope.ikGog[ spec ]( adsProp({
														loadingInterval : 2700,
														rewardGold : 10000
													}) )  
												
												}else{
													
													var emitProp = adsProp({
														loadingInterval : 2700,
														rewardGold : 2000,
														additionFnOpen : function(){
															scope.removeClass( scope.qs("banner-box"), "hidden" )
														},
														additionalFnLoading : function(){
															scope.text( scope.qs("banner-second"), secondLoop  - 1  )
														}
													}) 
												 
													var bannerInterval = setInterval(function(){
														
														if( secondLoop <= 0 ){ 
															 
															scope.addClass( scope.qs("banner-box"), "hidden" )
														 	
															clearInterval( bannerInterval );
															
															emitProp.eventClose();
															
															// Remove the banner
															global[ init ][ initBanner ].remove()
															
															return false;
															
														}
														
													},100)
													 
													
													scope.attachListener( scope.qs("banner-dismiss"), 'click', function( e ){
														
														scope.addClass( scope.qs("banner-box"), "hidden" )
														
														emitProp.eventClose();
															
														//clear mining loop
														clearInterval( selfInterval );
														// Remove the banner
														global[ init ][ initBanner ].remove()
													}) 
													 
													scope.ikGog[ initBanner ]( emitProp ) 
												}
											
											}else{
											
												scope.text( adsTitle, owlData.lang.fn( "gui", "htmlGUI", "waitMining" ) ); 
										
												setTimeout( function(){
													 
													scope.addClass( adsBox, "hidden" );
													
													scope.text( adsTitle,  owlData.lang.fn( "gui", "goldMining", "title" ) );
												 
													scope.globalAnimation["value"].blockRender = false;
														
													
												}, 3000 );
											 
											}
											
										}
									})  
								
									

								}
								
								scope.addClass( miningDialog, 'hidden' );
								scope.playAudio('tab-selected');
							})
						})
						  
					
					},
					objDiscard : '',
					initDropItem : function( init ){
						var self =  this;
						if( !init ){
							
							scope.attachListener( dropBtnClose, 'click', function( e ){ 
								scope.addClass( dropMenu, 'hidden' )
								window.scope.blockRender = false;
							})
							
							scope.attachListener( dropBtnDone, 'click' , function(){
								var loot = scope.characterInventoryBag['value'].get( scope.oval["value"].label  );
								for(var ii = 0,  jj = loot.length; ii < jj; ii++ ){
									if( !!loot[ii] && loot[ii].label === self.objDiscard.getAttribute('label') ){
										scope.characterDropItem['value']( loot[ii] );
										scope.addClass( dropMenu, 'hidden' )
										loot.splice( ii, 1 );
										break;
									}
								}
								
								self.objDiscard.remove()
								
								window.scope.blockRender = false;
								 
							})
							
						}else if( init === 'open' && scope.nthParent( self.objDiscard, 2 ) ){ // null indicate familia-box
							scope.removeClass( dropMenu, 'hidden' );
							scope.addClass( scope.qs('gui-player-mb'), 'hidden' );
						} 
						
					},
					initShowMonsterParams : function(){
						scope.attachListener( btnMonsterParams, 'click', function( e ){ 
							
							scope.playAudio('tab-selected')
							
							if( /hidden/i.test( monsterParamsDialog.className ) ){
								scope.removeClass( monsterParamsDialog, 'hidden' );
								var monsterParams =  scope.monsterParameters['value'].get( scope.globalAnimation["value"].monsterTarget  ),
								boxContent = scope.qs('content-detail'),
								boxTitle = scope.qs('monster-title') ;
								boxContent.innerHTML = '';
								scope.text( boxTitle, monsterParams.name );
								obj.charDetail({					
									params : monsterParams,
									box : boxContent,
									color : "ocean-blue"
								});
								
							}else{
								scope.addClass( monsterParamsDialog, 'hidden' )
							}
						})
						
						scope.attachListener( monsterParamsDialogClose, 'click', function( e ){ 
							
							scope.playAudio('tab-selected')
							scope.addClass( monsterParamsDialog, 'hidden' )
						})
						
					},
					initUpgradeGUI : function(){
						scope.attachListener( upgradeButtons[0], 'click', function(){
							var label = upgradeContent.getAttribute('label'),
							prevLabel = upgradeContent.getAttribute('prev-label'),
							selectedSkill = obj.getSkillByProperty( label, 'label' ),
							charParams = scope.characterParameters['value'],
							skills = scope.characterSkills['value'].get( scope.oval['value'].label ),
							systemSkill = scope.items['value'].skills;
							
							for(var ii = 0, jj = skills; ii < jj.length ; ii++ ){
								if( jj[ii].label === prevLabel ){
									
									if( charParams.skillPoint >= jj[ii].require.skillPoint 
									&& charParams.level >= jj[ii].require.level ){
										charParams.skillPoint -= jj[ii].require.skillPoint ;
										//jj[ii] = selectedSkill;
										
										for(var kk in  systemSkill ){
											if( systemSkill[kk].label === selectedSkill.label ){
												systemSkill[kk].active = true;
											}
										}
										
										
										selectedSkill.active = true;
										obj.skillDetail( selectedSkill.label )
										obj.fetchSkill()
										//remove old skill when it attach in right nav
										/*
										for( var ii = 0, jj = allSkill; ii < jj.length; ii++ ){
											var attachSkill = jj[ii].getElementsByTagName('div')
											if( !!attachSkill[0] && attachSkill[0].getAttribute('label') === prevLabel ){
												jj[ii].innerHTML = '';
												break;
											}
										}*/
						
									}else{
										scope.removeClass( upgradeAlert, 'hidden');
									}
									
									//dismiss
									scope.addClass( upgradeContent, 'hidden');
									break;
								}
							}
							
							
							scope.playAudio('tab-selected')
							
						})
						//dismiss
						scope.attachListener( alertButtons, 'click', function(){
							scope.playAudio('tab-selected')
							scope.addClass( upgradeAlert, 'hidden')
						})
						
						scope.attachListener( upgradeButtons[1], 'click', function(){
							scope.playAudio('tab-selected')
							scope.addClass( upgradeContent, 'hidden')
						})
					},
					initIsLanscape : function(){
						scope.attachListener( lanscapeBtnClose, 'click', function(){
							scope.addClass( lanscapeBox, 'hidden')
						})
					 
						
					},
					initSpecialItem : {
						bind : function( label, name ){
							
							obj.guiToogle(); 
							scope.removeClass( scope.qs("special-item-alert"), "hidden");
							scope.qs("special-item-alert").setAttribute( "label", label );
							scope.text( scope.qs("item-name"), name.toUpperCase() )
							obj.GUImobile.replaceSkills('detached');
							
							
						},
						init : function(){
							var itemBox = scope.qs("special-item-alert"),
							dismissBtn = itemBox.getElementsByTagName("button")[0],
							yesBtn = itemBox.getElementsByTagName("button")[1];
							
							scope.attachListener( dismissBtn, 'click', function(){
								
								window.scope.blockRender = false;
								
								scope.playAudio('tab-selected')
								scope.addClass( itemBox, "hidden" )
								itemBox.setAttribute("label","");
								
							})

							scope.attachListener( yesBtn, 'click', function(){
								
								var label = itemBox.getAttribute('label'),
								loot = scope.characterInventoryBag['value'].get( scope.oval['value'].label );
								for(var ii = 0; ii < loot.length ; ii++ ){
									if( loot[ii].label === label ){
										 scope.globalAnimation["value"].characterControl.specialItems.register( scope.oval['value'],  loot[ii] );
										
										 if( !loot[ii].quantity ){
											loot.splice(ii, 1)
										 }
										 
										 itemBox.setAttribute("label","");
										
										break;
									}
								}
								
								window.scope.blockRender = false;
								
								scope.playAudio('tab-selected')
							
								scope.addClass( itemBox, "hidden" )
							})
						}
					},
					initGUIText : function(){
						
						var textFn = function( elText, text, prop ){
							 
							scope.qsAll( elText ).forEach( function( el ){
								scope.text( el, owlData.lang.fn( "gui", prop ? prop : "htmlGUI", text )  )
							})
							
							
						}
						 
						textFn( "text-info-success", "textInfoSuccess" )
						textFn( "close-info", "closeInfo" )
						textFn( "close-info-success", "closeInfo" )
						textFn( "tow-text", "towText" )
						textFn( "enemy-text", "enemyText" )
						textFn( "exit-alert-text", "exitAlertText" )
						textFn( "app-alert-text", "appAlertText" )
						textFn( "item-alert-text", "itemAlertText" )
						textFn( "item-alert-text2", "itemAlertText2" )
						textFn( "ads-title", "adsTitle" )
						textFn( "mining-title", "miningTitle" )
						textFn( "ads-mining", "adsMining" )
						textFn( "ads-mining-b", "adsMiningB" )
						textFn( "facebook-mining", "facebookMining" )
						textFn( "buy-button-confirm", "buyButtonConfirm" )
						textFn( "shop-title", "shopTitle" )
						textFn( "item-discard-text", "itemDiscardText" )
						textFn( "inventory-text", "inventoryText" )
						textFn( "stat-text", "statText" )
						textFn( "item-info-text", "itemInfoText" )
						textFn( "chara-info-text", "charaInfoText" )
						textFn( "control-choose-text", "controlChooseText" )
						textFn( "control-menu-text", "controlMenuText" )
						textFn( "perform-text", "performText" )
						textFn( "sound-text", "soundText" )
						textFn( "tutorial-text", "tutorialText" )
						textFn( "contribution-text", "contributionText" )
						textFn( "exit-game-text", "exitGameText" )
						textFn( "info-menu-text", "infoMenuText" )
						textFn( "volume-head-text", "volumeHeadText" )
						textFn( "volume-content-text", "volumeContentText" )
						textFn( "volume-head-text2", "volumeHeadText2" )
						textFn( "volume-content-text2", "volumeContentText2" )
						textFn( "info-head-text", "infoHeadText" )
						textFn( "info-content-text", "infoContentText" )
						textFn( "perform-head-text", "performHeadText" )
						textFn( "perform-content-text", "performContentText" )
						textFn( "perform-head-text2", "performHeadText2" )
						textFn( "perform-content-text2", "performContentText2" )
						textFn( "play-game-text", "playGameText" )
						textFn( "select-hero-text", "selectHeroText" )
						textFn( "select-map-text", "selectMapText" )
						textFn( "select-enemy-text", "selectEnemyText" )
						textFn( "character-skill-text", "characterSkillText" )
						textFn( "character-skill-text2", "characterSkillText2" )
						textFn( "time-ads-text", "nextMining" )
						 
						
						textFn( "name-text", "name", "charaGUI" )
						textFn( "hp-text", "hp", "charaGUI" )
						textFn( "mp-text", "mp", "charaGUI" )
						textFn( "rangedmg-text", "rangeDmg", "charaGUI" ) 
						textFn( "meleedmg-text", "meleeDmg", "charaGUI" ) 
						textFn( "physicaldef-text", "physicalDef", "charaGUI" ) 
						textFn( "magicdef-text", "magicDef", "charaGUI" ) 
						textFn( "ability-text", "ability", "charaGUI" ) 
						textFn( "skilltalent-text", "skillTalent", "charaGUI" ) 
						textFn( "difficultylevel-text", "difficultyLevel", "charaGUI" ) 
						textFn( "banner-second-text", "second", "goldMining" ) 
						
						scope.qsAll("game-cover").forEach(function( obj ){
							scope.addClass( obj, owlData.lang.fn( "gui", "bgPop", "bg" ) )
						})
						  
						
						
						 
					},
					preloadAndExitAlert : function(){
						//exit-alert
						var buttons = scope.slice( scope.qs('exit-alert').getElementsByTagName('button') );
						scope.attachListener( buttons[0], 'click', function(){
							scope.addClass( scope.qs('exit-alert'), 'hidden' );
							scope.playAudio('tab-selected');
						})
						
						scope.attachListener( buttons[1], 'click', function(){
							location.reload();
							scope.playAudio('tab-selected');
						})
						
						//exit-alert
						
						var appAlertInterval = setInterval(function(){
							
							if( window.owlData.isDeviceread ){
								 
								var buttons = scope.slice( scope.qs('app-alert').getElementsByTagName('button') );
								
								scope.attachListener( buttons[0], 'click', function(){
									scope.playAudio('tab-selected');
									scope.addClass( scope.qs('app-alert'), 'hidden' );
								})
								
								scope.attachListener( buttons[1], 'click', function(){
									navigator.app.exitApp();
									scope.playAudio('tab-selected');
								})
								
								   
								document.addEventListener("backbutton", function (e) {
								 
									scope.removeClass( scope.qs('app-alert'), 'hidden' );
									e.preventDefault();  
									
									
								}, false );
								
								clearInterval( appAlertInterval );
							}
							
						},1)
						
						
						
						
						
					},
					registerAutoSave : function(){
						
						scope.intervalListGlobal["value"]['auto-save'] = {
							always : true,
							tick : 12000, // 8 m
							tickUpdate : 12000,
							fn : function(){ 
								scope.pushMsgText['value']( 'saving your progress ', 100 );
								scope.globalSaveGame['value']( 'Auto Save','',true )
							}
						}
						
					},
					audioBackground : scope.audioBackground,
					
					
				}
				 
				//localStorage.removeItem('goldHero')
				//localStorage.removeItem('saveGame')
				//console.log( scope.JSONstringfy( JSON.parse( localStorage.getItem( 'saveGame' ) )[ 'fsss' ] ) );
				 
				//rewrite gui text base on lang 
				obj.initGUIText(); 
				
				obj.GUITowerDef();
				  
				scope.attachListener( switchBtn, 'click', function(){
					for(var ii = 0, jj = navRight.length; ii < jj ; ii++){
						if( /hidden/i.test( navRight[ii].className ) ){
							scope.removeClass( navRight[ii], "hidden" )
						}else{
							scope.addClass( navRight[ii], "hidden" )
						}
					}
				})
				
				//store object to global
				scope.globalObjectGUI["value"] = obj
				
				//upgrade gui
				obj.initUpgradeGUI();
				
				//save and load game
				obj.checkLoadGame();
				
				 //drag bar and toogle effct required update characterParameters
				scope.dragBar();
				scope.toggleButton();
				
				obj.installGlobalSaveGame();
				
				obj.loadSaveGame();
				
				//gui mobile
				isMobile && obj.GUImobile.firstLoad()
				
				//monster parameters
				obj.initShowMonsterParams();
				
				//shop
				obj.initShop();
				
				//mining control
				obj.initMiningControl()
				
				// drop item
				obj.initDropItem();
				
				//special shop item
				obj.initSpecialItem.init();
				
				//exit-alert
				obj.preloadAndExitAlert();
				
				// menu save game
				obj.loadMenuSaveGame();
				
				//close lanscapeBox
				obj.initIsLanscape();
				 
				//trigger manual or auto skill
				obj.skillGUITriggered();
				
				
				
				//registerAutoSave
				//obj.registerAutoSave()
				
				//control menu 
				for(var ii = 0; ii < controlMenu.length ; ii++ ){
					scope.attachListener( controlMenu[ii], 'click', function(){
							
						scope.playAudio('tab-selected')
						 
						if( this.getAttribute('target') ){
						
							
							for( var jj = 0; jj < controlDetail.length; jj++ ){
								if( controlDetail[jj].getAttribute('target')){
									scope.addClass( controlDetail[jj], 'hidden')
								}
							}
							for( var kk = 0; kk < controlMenu.length; kk++ ){
								scope.removeClass( controlMenu[kk], 'selected')
							}
							
							scope.removeClass( scope.qs( [ this.getAttribute('target') ] ), 'hidden' )
							
							scope.addClass(  this , 'selected' )
						}else{
							scope.removeClass( scope.qs('exit-alert'), 'hidden' );
						}
					})
				}

				//btn Expand
				scope.attachListener( sortCutnExpand, 'click', function(){
					if( /expand/i.test( this.className ) ){
						scope.removeClass( this, 'expand')
						scope.css( scope.qs('hidden-menu') , { 
							'transform': '0px,0px,0px', 
							'transition' : 'transform 450ms ease-in-out'
						})
					}else{
						scope.addClass( this, 'expand')
						scope.css( scope.qs('hidden-menu') , { 
							'transform': '-195px,0px,0px', 
							'transition' : 'transform 450ms ease-in-out'
						})    //margin-left: 150px;
					}
					
				})
				
				//shortcut tab button , sortCutBtnControlMb, sortCutBtnQuestMb, sortCutBtnSkillMb, sortCutBtnBagMb
				scope.attachListener( [ scope.controlTab, sortCutBtnControl ], 'click', function(){
					obj.selectTab( scope.controlContainer, scope.controlTab )
				})
			
				scope.attachListener( [ scope.questTab, sortCutBtnQuest ], 'click', function(){
					obj.selectTab( scope.questContainer, scope.questTab )
				})
				
				scope.attachListener( [ scope.skillTab, sortCutBtnSkill ], 'click', function(){
					obj.selectTab( scope.skillContainer, scope.skillTab )
				})
				
				scope.attachListener( [ scope.bagTab, sortCutBtnBag ], 'click', function( ){
					obj.selectTab( scope.bagContainer, scope.bagTab )
				})
				
				
				scope.attachListener( sortCutFullscreen, 'click', function(){
					scope.fullscreenToogle( this );
					scope.playAudio('tab-selected')
				})
				
				scope.attachListener( sortCutSpeaker, 'click', function(){
					 
					if( /off/i.test( this.className ) ){
						this.className = "speaker-on";
						scope.objTranslate['value'].volume = true;
						scope.globalObjectGUI["value"].audioBackground.setVolume("on");
					}else{
						this.className = "speaker-off";
						scope.globalObjectGUI["value"].audioBackground.setVolume("off");
						scope.objTranslate['value'].volume = false;
					}
					scope.playAudio('tab-selected')
				})
				
				
				scope.attachListener( scope.slotPassiveSkill, 'click', function( event )
				{
					if( event.target === this ){
						var passiveSkillBox = this.getElementsByTagName('div')[0];
						if( /hidden/i.test( passiveSkillBox.className) ){
							scope.removeClass( passiveSkillBox, 'hidden' )
						}else{
							scope.addClass( passiveSkillBox, 'hidden' )
						}
					}

				})
				 
				//fetch items
				scope.attachListener( scope.bagButton, 'click', function()
				{
					container = !isMobile ? scope.detailInventory : staticDetail;
					container.innerHTML = '';
					obj.charDetail({					
						params : scope.characterParameters['value'],
						box : container
					});
					
					obj.charDetail({					
						params : scope.characterParameters['value'],
						box : staticDetail
					});
					obj.fetchLoot();
					obj.fetchSkill();
					obj.guiToogle()
					obj.fetchQuest();
					scope.dragBar();
					//hide overflow plugin scroll li 
					scope.scrollSlideParams.fn();
					obj.GUImobile.replaceSkills('attach');
					 
					
					window.scope.blockRender = true;
					
				})
				
				//skill detail
				scope.attachListener( scope.qs('close-btn-skill'), 'click', function()
				{
					scope.addClass( scope.qs('list-skills'), "hidden" );
					scope.qs('button-skills').style.backgroundImage = 'url('+scope.path+'plus.png)';
				})
				
				//close quest
				scope.attachListener( scope.qs('close-quest'), 'click', function( index ){
					var activeEl = this;
					if( /hidden/i.test( scope.qs('init-box').className ) ){
						scope.removeClass( scope.qs('init-box'), "hidden" )
						activeEl.style.backgroundImage = 'url('+scope.path+'minus.png)';
						
					}else{
						scope.addClass( scope.qs('init-box'), "hidden" );
						activeEl.style.backgroundImage = 'url('+scope.path+'plus.png)';
					}
				})
				
				scope.attachListener( scope.qs('button-skills'), 'click', function(){ 
					var activeEl = this;
					if( /hidden/i.test( scope.qs('list-skills').className ) ){
						scope.removeClass( scope.qs('list-skills'), "hidden" )
						scope.qs('button-skills').style.backgroundImage = 'url('+scope.path+'minus.png)';
						
					}else{
						scope.addClass( scope.qs('list-skills'), "hidden" );
						scope.qs('button-skills').style.backgroundImage = 'url('+scope.path+'plus.png)';
					}
				})
				
				
				//skills
				var skillActive = {
					move : false,
					startX : 0,
					startY : 0,
					endX : 0,
					endY : 0,
					startItem : '',
					endItem : '',
					itemName : true
				}
				for(var ii = 0; ii < slotSkills.length; ii++){
					scope.attachListener( slotSkills[ii], scope.CursorMoveEvent , function( event ){
						if( !skillActive.move && !!scope.getFirstChild( this ) && skillActive.itemName !== scope.getFirstChild( this ).className ){
							
							var item = scope.getFirstChild( this )
							obj.skillInfoDetail( item );
							
							if( !/clone/i.test( item.className ) ) {
									scope.removeClass( scope.qs('item-popup'), 'hidden');
							}else{
								scope.addClass( scope.qs('item-popup'), 'hidden');
							}
							skillActive.itemName = item.className;
							
						}
						
					})
					
					scope.attachListener( slotSkills[ii], scope.CursorLeaveEvent , function( event ){
						scope.addClass( scope.qs('item-popup'), 'hidden');
						skillActive.itemName = true;
					})
					
					scope.attachListener( slotSkills[ii], scope.CursorStartEvent , function( event ){
							
						var getItem = this.getElementsByTagName('div');
					
						if( getItem.length  && !skillActive.move ){
							var divRect = getItem[0].getBoundingClientRect(),
							posX = scope.mousePosition['value'].pos.mousedown.x ,
							posY = scope.mousePosition['value'].pos.mousedown.y ;
							
							skillActive.startX + ( posX - skillActive.clientX )
							
							skillActive.startX = divRect.left
							skillActive.startY = divRect.top
							skillActive.move = true;
							skillActive.bugMove = true;
							skillActive.startItem = getItem[0];
							
							obj.skillDetail( skillActive.startItem.getAttribute('label') ); 
							
							if( /container-skill/i.test( scope.nthParent( getItem[0], 3 ).className ) ){
								scope.addClass( scope.qs('list-skills'), 'hidden' );
							}
							
							/*if( !/hidden/i.test( gui.className ) && scope.isMobile() ){
								var item = getItem[0];
								obj.skillInfoDetail( item );
								scope.removeClass( scope.qs('item-popup'), 'hidden')
							}*/
						}
					})
				}

				scope.attachListener( document.body, scope.CursorMoveEvent , function( event ){
					if( skillActive.move && function(){
						var attachSkill = skillActive.startItem.parentNode.getAttribute('drag')
						if( !!attachSkill && attachSkill === 'false' ) return false;
						return true;
					}() ){
							
						var posX = scope.mousePosition['value'].pos.mousemove.x ,
						posY = scope.mousePosition['value'].pos.mousemove.y ;
						scope.addClass( scope.qs('item-popup'), 'hidden')
							
						if( skillActive.bugMove ){
							skillActive.clientX = posX
							skillActive.clientY = posY
							skillActive.bugMove = false;
						}
						scope.css( skillActive.startItem, {
							'top': skillActive.startY  + ( posY - skillActive.clientY ) +'px',
							'left':  skillActive.startX + ( posX - skillActive.clientX ) +'px',
							'width': skillActive.startItem.parentNode.offsetWidth +'px ',
							'height': skillActive.startItem.parentNode.offsetHeight +'px ',
							'position' : 'fixed',
							'z-index' : '1'
						});
						
					}
				})
		
				scope.attachListener( document.body, scope.CursorEndEvent , function( event ){
					scope.id('nav').appendChild( scope.qs('item-popup') ) // prevent delete
						
					//passive && active skill
					var slotIdName = scope.getRelativeMousePositionToRegisterObject( allSkill );
					
					if( skillActive.move && slotIdName && function()
					{
						for(var ii = 0; ii < allSkill.length ; ii++ ){
							var attachedSkill = allSkill[ii].getElementsByTagName('div');
							if( attachedSkill.length && attachedSkill[0].getAttribute('label') === skillActive.startItem.getAttribute('label') ){
								return false;
							}
						}
						return true;
					}()){
						
						var selectedSlot = scope.id( slotIdName ),
						slotSkillRect = selectedSlot.getBoundingClientRect(),
						cloneSkill = skillActive.startItem.cloneNode(true),
						skillType = /active/i.test( selectedSlot.className ) ? 'active' : 'passive';
						cloneSkill.className = cloneSkill.className+' clone';
						cloneSkill.innerHTML = '';
						
						if( skillActive.startItem.getAttribute('type') === skillType ){
							
							var skills = scope.characterSkills['value'].get( scope.oval['value'].label ),
							label = cloneSkill.getAttribute('label'),
							previousSkill = scope.getFirstChild( selectedSlot ),
							labelPrevSkill = previousSkill && previousSkill.getAttribute("label") || "";
							
							//update new skill slotLocation
							//and remove prev skill slotLocation
							for(var jj = 0; jj < skills.length; jj++ ){
								if( skills[jj].label === label ){
									skills[jj].slotLocation = selectedSlot.id;
								}
								if( labelPrevSkill && skills[jj].label === labelPrevSkill ){
									skills[jj].slotLocation = "";
								}
							}
							 
							scope.playAudio('item-drop');
							
							selectedSlot.innerHTML = '';
							var timeSpan = document.createElement('div');
							timeSpan.className = 'time-span time-span-'+label;
							
							var disable = document.createElement('div');
							disable.className = 'disable-skill';
							
							cloneSkill.appendChild( timeSpan )
							
							cloneSkill.appendChild( disable )
							
							
							selectedSlot.appendChild ( cloneSkill )
							scope.css( cloneSkill, {
								'top': slotSkillRect.top  +'px',
								'left':  slotSkillRect.left +'px',
								'width': '100%',
								'height':  '100%',
								'position' : ''
							});
							
							scope.css( skillActive.startItem, {
								'top': skillActive.startY  +'px',
								'left':  skillActive.startX +'px',
								'position' : ''
							});
							
							
							if( !isMobile ){
								obj.fetchSkill()
								scope.addClass( scope.qs('list-skills'), "hidden" );
							}
							
							//scope.initUndeadSkill['value']()
							//scope.caracterSkillToogleFn['value']( 'pass' );
						
							
						}else{
							scope.css( skillActive.startItem, {
								'top': skillActive.startY  +'px',
								'left':  skillActive.startX +'px',
								'position' : ''
							});
						}

					}else{
						scope.css( skillActive.startItem, {
							'top': skillActive.startY  +'px',
							'left':  skillActive.startX +'px',
							'position' : ''
						});
					}
					
					//remove active skill
					var parentClass = skillActive.startItem.parentNode && skillActive.startItem.parentNode.className;
					
					//drag out
					/*					
					if( /active/i.test( parentClass ) ){
						//bug mouse x,y = 0,0
						var x = scope.mousePosition['value'].pos.mouseup.x,
						y = scope.mousePosition['value'].pos.mouseup.y;
						if( !x && !y){
							var x = scope.mousePosition['value'].pos.mousemove.x,
							y = scope.mousePosition['value'].pos.mousemove.y;
							scope.mousePosition['value'].pos.mouseup.x = x
							scope.mousePosition['value'].pos.mouseup.y = y
						}
						var posReac = skillActive.startItem.getBoundingClientRect();
						if( !(posReac.right > x &&  posReac.left < x
						&& posReac.top < y &&  posReac.bottom > y ) && skillActive.move  ){
							skillActive.startItem.parentNode.innerHTML = '';
							obj.fetchSkill();
							//remove skill slotLocation
							var skills = scope.characterSkills['value'].get( scope.oval['value'].label );
							for(var jj = 0; jj < skills.length; jj++ ){
								if( skills[jj].label === skillActive.startItem.getAttribute( "label" ) ){ 
									skills[jj].slotLocation = "";
								}
							}
						}
					}*/
					
					
					isMobile && !/hidden/i.test( gui.className ) &&  scope.addClass( scope.qs('item-popup'), 'hidden')
					skillActive.move  = false
				})

				//bags
				
				var itemPoint = {
					move : false,
					startX : 0,
					startY : 0,
					endX : 0,
					endY : 0,
					startItem : '',
					endItem : '',
					itemName : true
				};
				
				//hover bags bottom 
				
				//desktop & mobile
				var bagButtonsFN = function( element ){
					if( !isMobile ){
									
						var childs = scope.slice( element.parentNode.getElementsByTagName( 'li' ) );
						
						if( /loot-c/i.test( element.className ) ){
							scope.css( scope.qs('bag-wrap'), {
								'margin-top':'0px'
							});
						}else if( /loot-b/i.test( element.className ) ){
							scope.css( scope.qs('bag-wrap'), {
								'margin-top':'-250px'
							});
						}else if( /loot-a/i.test( element.className ) ){
							scope.css( scope.qs('bag-wrap'), {
								'margin-top':'-500px'
							});
						}
					}else{
						var childs = scope.slice( element.parentNode.getElementsByTagName( 'div' ) );
						if( /control-bagA-mb/i.test( element.className ) ){
							scope.css( scope.qs('bag-wrap-mb'), {
								'margin-top':'0px'
							});
						}else if( /control-bagB-mb/i.test( element.className ) ){
							scope.css( scope.qs('bag-wrap-mb'), {
								'margin-top': -obj.GUImobile.heightInventory+'px'
							});
						}else if( /control-bagC-mb/i.test( element.className ) ){
							scope.css( scope.qs('bag-wrap-mb'), {
								'margin-top': -obj.GUImobile.heightInventory*2+'px'
							});
						}
						obj.GUImobile.hideItemCntOverflow('show')
					}
					
					for(var jj = 0; jj < childs.length; jj++ ){
						scope.removeClass( childs[jj], 'active' )
					}
					scope.addClass( element, 'active' );
				}
				
				scope.attachListener( [ scope.qs('bag-loot-container'), scope.qs('inventory-detail-mb') ], scope.CursorMoveEvent , function( event ){
					if( itemPoint.move ){
						for(var ii =0; ii < bags.length; ii++ ){
							var bound = bags[ii].getBoundingClientRect(),
							posX = scope.mousePosition['value'].pos.mousemove.x ,
							posY = scope.mousePosition['value'].pos.mousemove.y ;
							if( posX > bound.x 
								&& posX < ( bound.x + bound.width ) 
								&& posY > bound.y 
								&& posY < ( bound.y + bound.height ) ){
								bagButtonsFN( bags[ii] )
							};
							
						}
					}
				})
				
				//click bag bottom
				for(var ii =0; ii < bags.length; ii++ ){
					scope.attachListener( bags[ii], 'click', function(){
						bagButtonsFN( this )
						if( isMobile ) obj.GUImobile.hideItemCntOverflow('hidden');
					})
				}
			
				
				for(var ii = 0; ii < slots.length; ii++){
					
					//hover detail item
					scope.attachListener( slots[ii], scope.CursorMoveEvent , function( event ){
						if( !itemPoint.move && !!scope.getFirstChild( this ) && itemPoint.itemName !== scope.getFirstChild( this ).className ){
							var item = scope.getFirstChild( this );
							if( !/slot-button/i.test( this.className ) && item.getAttribute('label') ){
								obj.itemDetail( item );
								scope.removeClass( scope.qs('item-popup'), 'hidden');
								itemPoint.itemName = item.className;
								scope.removeClass( scope.qs('item-popup'), 'hidden'); 
							}
						}
						
						
					})
					
					scope.attachListener( slots[ii], scope.CursorLeaveEvent , function( event ){
						scope.addClass( scope.qs('item-popup'), 'hidden') 
						itemPoint.itemName = true;
					})
					
					scope.attachListener( slots[ii], scope.CursorStartEvent , function( event ){
						var getItem = this.getElementsByTagName('div');
						if( getItem.length  && !itemPoint.move ){
							var divRect = getItem[0].getBoundingClientRect(),
							posX = scope.mousePosition['value'].pos.mousedown.x ,
							posY = scope.mousePosition['value'].pos.mousedown.y ;
						
							
							
							if( !isMobile ){
							
								if( /slot-upgrd/i.test( getItem[0].parentNode.id ) ){
									scope.css( scope.qs('bag-loot'), { 'z-index': '1' });
									scope.css( scope.qs('upgrader-box'), { 'z-index': '2' });
								}else{
									scope.css( scope.qs('bag-loot'), { 'z-index': '2' });
									scope.css( scope.qs('upgrader-box'), { 'z-index': '2' });
								}
								
								if( /passive-magic/i.test( scope.nthParent( getItem[0] , 3 ).className ) ){
									scope.css( scope.qs('bag-loot'), { 'z-index': '1' });
									scope.css( scope.qs('passive-magic'), { 'z-index': '2' });
								}
							 
							}else if( !/hidden/i.test( gui.className )  ){
								var item = getItem[0];
								obj.GUImobile.infoItemToogle( 'item', item );
								
								scope.css( scope.qs('items-hidden-potion-mb'), {  'display':'none'});
								
								var preventOpaictyZero = potions ;
								
								for( var jj =0; jj < preventOpaictyZero.length; jj++ ){
									preventOpaictyZero[jj].style.opacity = 1;
								}
								 
								scope.isScroll['value'] = false;
								
								if( /slot-upgrd/i.test( item.parentNode.id ) ){
									scope.css( scope.qs('items-bag-mb'), { 'z-index': '1' });
									scope.css( scope.qs('upgrader-box'), { 'z-index': '2' });
									scope.css( scope.qs('items-equipment-mb'), { 'z-index': '1' });
								}else if( /slot-magic/i.test( item.parentNode.id ) ){
									scope.css( scope.qs('items-equipment-mb'), { 'z-index': '2' });
									scope.css( scope.qs('items-bag-mb'), { 'z-index': '1' });
									scope.css( scope.qs('upgrader-box'), { 'z-index': '1' });
								}else{
									scope.css( scope.qs('items-bag-mb'), { 'z-index': '2' });
									scope.css( scope.qs('upgrader-box'), { 'z-index': '2' });
									scope.css( scope.qs('items-equipment-mb'), { 'z-index': '1' });
								}
								
								item.setAttribute('style','');
								scope.removeClass( item, 'force-overflow');
								
								var staticContainerMb = scope.qs("wrap-item-detail-mb");
								cnt = scope.getFirstChild( staticContainerMb ),
								scroll = scope.getLastChild( staticContainerMb );
								
								scope.css( cnt, { 'transform': '0px,0px,0px',  });
								scope.css( scroll, { 'transform': '0px,0px,0px',  });
								
							} 
							
							scope.playAudio('item-pick')
							
							itemPoint.startX = divRect.left
							itemPoint.startY = divRect.top
							itemPoint.move = true;
							itemPoint.bugMove = true;
							itemPoint.startItem = getItem[0];
							scope.scrollSlideParams.fn()
						}
					})
					
					scope.attachListener( slots[ii], scope.CursorEndEvent , function( ){
						var slotIdName = scope.getRelativeMousePositionToRegisterObject( slots ),
						leaveSlot = false
						 
						
						
						if( itemPoint.move && slotIdName )
						{
							var selectedSlot = scope.id( slotIdName ),
							getItem = selectedSlot.getElementsByTagName('div'),
							selectedSlotRect = selectedSlot.getBoundingClientRect(),
							slotButtonHpChild = scope.slotButtonHp.getElementsByTagName('div'),
							slotButtonMpChild = scope.slotButtonMp.getElementsByTagName('div'),
							loot = scope.characterInventoryBag['value'].get( scope.oval['value'].label ),
							posX = scope.mousePosition['value'].pos.mousemove.x ,
							posY = scope.mousePosition['value'].pos.mousemove.y ;
							
							
							//magic box
							if( /magic/i.test( slotIdName ) ){
								for(var ii = 0,  jj = loot.length; ii < jj; ii++ ){
									if( loot[ii] && loot[ii].label === itemPoint.startItem.getAttribute('label') && loot[ii].usage === 'upgrade' ){
									   
									   scope.playAudio('item-drop')
										
										if( !getItem.length ){
											scope.css( itemPoint.startItem, {
												'top': selectedSlotRect.top  +'px',
												'left':  selectedSlotRect.left +'px',
												'position' : ''
											});
											selectedSlot.appendChild( itemPoint.startItem )
										}
										
										
										break;
									}else{
										scope.css( itemPoint.startItem, {
											'top': itemPoint.startY  +'px',
											'left':  itemPoint.startX +'px',
											'position' : ''
										});
									}
									
								}
							} else {
								if( getItem.length ){
									//slot active
									//item swap
									var slotHpRect = scope.slotButtonHp.getBoundingClientRect(),
									slotMpRect = scope.slotButtonMp.getBoundingClientRect();
									if( slotHpRect.right > posX &&  slotHpRect.left < posX
										&& slotHpRect.top < posY &&  slotHpRect.bottom > posY ){
												 
										for(var ii = 0; ii < loot.length ; ii++ ){
											if( loot[ii] && loot[ii].label === itemPoint.startItem.getAttribute('label') && loot[ii].name === 'healthpotion' ){
												var getItem = slotButtonHpChild;
												 
												if( !getItem.length ){
													scope.css( itemPoint.startItem, {
														'top': slotHpRect.top  +'px',
														'left':  slotHpRect.left +'px',
														'position' : ''
													});
													scope.slotButtonHp.appendChild( itemPoint.startItem )
												}else{
													scope.css( getItem[0], {
														'top': itemPoint.startY  +'px',
														'left':  itemPoint.startX +'px',
														'position' : ''
													});

													itemPoint.startItem.parentNode.appendChild( getItem[0] )

													scope.css( itemPoint.startItem, {
														'top': itemPoint.startY  +'px',
														'left':  itemPoint.startX +'px',
														'position' : ''
													});
													scope.slotButtonHp.appendChild( itemPoint.startItem )
												}

												scope.text( itemPoint.startItem.getElementsByTagName('div')[0], loot[ii].quantity )
												
												//loot[ii].bagLocation = slotIdName;
												break;
												
											}else{
												
												scope.css( itemPoint.startItem, {
													'top': itemPoint.startY  +'px',
													'left':  itemPoint.startX +'px',
													'position' : ''
												});
											}
										}
									//mp hp slots	
									}else if( slotMpRect.right > posX &&  slotMpRect.left < posX
										&& slotMpRect.top < posY &&  slotMpRect.bottom > posY ){

										for(var ii = 0; ii < loot.length ; ii++ ){
											if( loot[ii] && loot[ii].label === itemPoint.startItem.getAttribute('label') && loot[ii].name === 'manapotion' ){
												
												var getItem = slotButtonMpChild;
												if( !getItem.length ){
													scope.css( itemPoint.startItem, {
														'top': slotMpRect.top  +'px',
														'left':  slotMpRect.left +'px',
														'position' : ''
													});
													scope.slotButtonMp.appendChild( itemPoint.startItem )
												}else{
													scope.css( getItem[0], {
														'top': itemPoint.startY  +'px',
														'left':  itemPoint.startX +'px',
														'position' : ''
													});

													itemPoint.startItem.parentNode.appendChild( getItem[0] )

													scope.css( itemPoint.startItem, {
														'top': itemPoint.startY  +'px',
														'left':  itemPoint.startX +'px',
														'position' : ''
													});
													scope.slotButtonMp.appendChild( itemPoint.startItem )
												}

												scope.text( itemPoint.startItem.getElementsByTagName('div')[0], loot[ii].quantity )
												break;
											}else{
												scope.css( itemPoint.startItem, {
													'top': itemPoint.startY  +'px',
													'left':  itemPoint.startX +'px',
													'position' : ''
												});
											}
										}
									} else{
										//if items need sum
										var label = itemPoint.startItem.getAttribute('label'),
										labelSum = getItem[0].getAttribute('label'),
										tempSum, tempSumA, tempSumB;
										if( label ){
											for(var ii = 0; ii < loot.length ; ii++ ){
												if( loot[ii] && loot[ii].label === label ){
													
													for( var jj = 0; jj < loot.length ; jj++ ){
														if( loot[jj] && loot[jj].label === labelSum
															&& function(){
																return loot[ii].displayName === loot[jj].displayName 
																&& loot[ii].name === loot[jj].name
															}()
															&& !loot[ii].unique
															&& loot[ii].label !== loot[jj].label ){
																 
															tempSum = loot[ii].quantity + loot[jj].quantity;
															if( tempSum <= 99 ){
																tempSumA = loot[ii].quantity +=  loot[jj].quantity
																loot.splice( jj, 1 )
																getItem[0].remove();
															}else{
																tempSumB = 99 - loot[ii].quantity;
																tempSumA = loot[ii].quantity = 99;
																loot[jj].quantity -= tempSumB;
															}

															if( 'undefined' !== typeof getItem[0] ){
																var itemA = getItem[0].getElementsByTagName('div')[0];
																scope.text( itemA, loot[jj].quantity );
																
																if( loot[jj].quantity > 1) scope.removeClass( itemA, "hidden" )
																
															}
															
															var itemB = itemPoint.startItem.getElementsByTagName('div')[0];
															scope.text( itemB, tempSumA )
															if( tempSumA > 1) scope.removeClass( itemB, "hidden" );
															
															break;
														}
													}
												}
											}
										}

										//slot bag
										if( 'undefined' !== typeof getItem[0] ){
											scope.css( getItem[0], {
												'top': itemPoint.startY  +'px',
												'left':  itemPoint.startX +'px',
												'position' : ''
											});

											itemPoint.startItem.parentNode.appendChild( getItem[0] )
										}

										scope.css( itemPoint.startItem, {
											'top': itemPoint.startY  +'px',
											'left':  itemPoint.startX +'px',
											'position' : ''
										});
										selectedSlot.appendChild( itemPoint.startItem )
										
										/**
											item bag  location not move yet
										*/
										//if drag item is upgrader
										if( /upgrader/i.test( itemPoint.startItem.className  ) ){
											obj.upgrader();
											
										//bind  special item's label to its box
										}else if( /summoner/i.test( itemPoint.startItem.className  ) ){
											
											
											for(var ii = 0; ii < loot.length ; ii++ ){
												if( loot[ii] && loot[ii].label === label ){
													obj.initSpecialItem.bind( label, loot[ii].displayName );
													break;
												}
											}
											
											
											
										}
										/*************/
										// required for switchCharacter
										
										if(/slot-hp|shot-mp/i.test( slotIdName ) ){
											
											obj.markPotions();
										}	
										
										if( !slotButtonHpChild.length );
										else{
											for(var ii = 0; ii < loot.length ; ii++ ){
												if( loot[ii].label === slotButtonHpChild[0].getAttribute('label') ){
													scope.text( slotButtonHpChild[0].getElementsByTagName('div')[0], loot[ii].quantity )
													 break;
												}
											}
										};

									}
									
			
									
									
								} else if( itemPoint.startItem !== ''){
									

									scope.css( itemPoint.startItem, {
										'top': itemPoint.startY  +'px',
										'left':  itemPoint.startX +'px',
										'position' : ''
									});
									selectedSlot.appendChild( itemPoint.startItem )
								}

							} 
							
							obj.fetchLoot({
								updateSlot : false
							});// update indexBagLocation
							
							 scope.playAudio('item-drop')
							
							itemPoint.move = false
							
							
						}else if( itemPoint.startItem ){
							scope.css( itemPoint.startItem, {
								'top': itemPoint.startY  +'px',
								'left':  itemPoint.startX +'px',
								'position' : ''
							});
							
							//item discard 
							obj.objDiscard = itemPoint.startItem;
							obj.initDropItem( 'open' )
						}
				 
						
						itemPoint.move = false;
						
						obj.magicBox( slotIdName )
						
						if ( isMobile ){
							if( !/hidden/i.test( gui.className ) )
							scope.addClass( scope.qs('item-popup'), 'hidden');
							
							scope.addClass( itemPoint.startItem, 'force-overflow')
									
							obj.GUImobile.hideItemCntOverflow('hidden');
							scope.isScroll['value'] = true;
							setTimeout( function(){
								scope.css( scope.qs('cnt-bag-mb'), { 'margin-left': '15px'});
								scope.css( scope.qs('items-hidden-potion-mb'), { 'margin-left': obj.GUImobile.transformInventory+'px' });
								 
								//attach hp
								setTimeout( function(){
									scope.css( scope.qs('items-hidden-potion-mb'), { 'display':'none'}); 
									obj.GUImobile.replacePotions('attach');
									
								},200)
								
							},500)
							
						
						}else{
						  
							obj.charDetail({					
								params : scope.characterParameters['value'],
								box : staticDetail
							});
						}
						
						
						//clear old item
						itemPoint.startItem = '';
									
						
					}.bind( this, ii) )
				}
				
				
				scope.attachListener( document.body , scope.CursorMoveEvent , function( event ){
					if( itemPoint.move ){
						var posX = scope.mousePosition['value'].pos.mousemove.x ,
						posY = scope.mousePosition['value'].pos.mousemove.y ;
						
						scope.addClass( scope.qs('item-popup'), 'hidden'); 
						
						if( itemPoint.bugMove ){
							itemPoint.clientX = posX
							itemPoint.clientY = posY
							itemPoint.bugMove = false;
						}
						
						if( isMobile ){
							scope.css( itemPoint.startItem, {
								'top': itemPoint.startY  + ( posY - itemPoint.clientY ) +'px',
								'left':  itemPoint.startX + ( posX - itemPoint.clientX ) +'px',
								'width': itemPoint.startItem.parentNode.offsetWidth +'px ',
								'height': itemPoint.startItem.parentNode.offsetHeight +'px ',
								'position' : 'fixed',
								'z-index' : '1'
							});
						}else{
							scope.css( itemPoint.startItem, {
								'top': itemPoint.startY  + ( posY - itemPoint.clientY ) +'px',
								'left':  itemPoint.startX + ( posX - itemPoint.clientX ) +'px',
								'position' : 'fixed',
								'z-index' : '1'
							});

						}
						
						if( isMobile && /mana|health/i.test( itemPoint.startItem.className ) ){
							
							if( /mana|health/i.test( itemPoint.startItem.className ) && /potion/i.test( itemPoint.startItem.className )){
								scope.css( scope.qs('items-hidden-potion-mb'), { 'margin-left':'15px', 'display':'block'});
								//detached hp 
								obj.GUImobile.replacePotions('detached');
							} 
							
							scope.css( scope.qs('cnt-bag-mb'), { 'margin-left': -obj.GUImobile.transformInventory+'px'})
						}
						
						
					}

				})
					
				
			}.bind(this),1)
			
		}

	}


	_owlBird.init = function() {
			
		var fn = new _owlBird.utils,
		plugins = new _owlBird.plugins,
		transport = _owlBird.transport,
		parent = fn.qsAll('page-content'),
		_obj = {
			
			messageCnt : fn.qs('screen-info'),
			blocker : fn.qs('screen-info'),
			bagButton : fn.qs('bag-button'),
			tabButton : fn.qs('tab-button'),
			skillTab : fn.qs('skill-tab'),
			skillBox : fn.qs('box-skill'),
			skillContainer : fn.qs('box-skill-container'),
			questContainer : fn.qs('box-quest-container'),
			questTab : fn.qs('quest-tab'),
			controlContainer : fn.qs('box-config-container'),
			controlTab : fn.qs('control-tab'),
			bagContainer : fn.qs('bag-loot-container'),
			detailInventory : fn.qs('inventory-detail'),
			detailSkill : fn.qs('skill-detail'),
			buffBox : fn.qs('buff-box'),
			bagTab : fn.qs('bag-tab'),
			bagLoot : fn.qs('bag-loot'),
			loading : fn.qs('loading-assets'),
			slotButtonHp : fn.id('slot-hp'),
			slotButtonMp : fn.id('slot-mp'),
			slotSkillA : fn.id('slot-skill-a'),
			slotSkillB : fn.id('slot-skill-b'),
			slotSkillC : fn.id('slot-skill-c'),
			slotPassiveSkill : fn.qs('slot-passive-skill'),
			slotItemNumber : fn.qs('active-item-number'),
			
		//user
			browserWidth : function(){ return  document.body.clientWidth },
			browserHeight : function(){ return  document.body.clientHeight },

		//fn
			utils : _owlBird.utils,
			bridge : _owlBird.bridge,
			deligate : _owlBird.deligate,
			transport : _owlBird.transport,
			particle :_owlBird.particle,
			particle3d : _owlBird.particle3d,
			physics : _owlBird.physics,
			sprites : _owlBird.sprites,
			plugins : _owlBird.plugins,
			AIs : _owlBird.AIs,
			component : _owlBird.component,
			mouse : _owlBird.mouse
		}
 
		//delay for orientation-form
		
		plugins.screenTransitionOnload(function( assetsTemp ){
			 
			var gui = new _owlBird.GUI( _obj, fn.extend ),
			animation = new _owlBird.animation( _obj, fn.extend );
			 
			plugins.infoHelp.update();
			
			//store assets temp to data storage
			assetsTemp.forEach(function( obj ){
				animation.globalImage.set( obj.src, obj.img );
			})
			
			assetsTemp.length = 0;
			
		})	
		
	};
	 
	global.addEventListener('DOMContentLoaded', function(){
		
		if ( !window.WebGLRenderingContext ) {
			// the browser doesn't even know what WebGL is
			alert( "browser doesn's suport webgl") 
		} else {
			var canvas = document.getElementById("canvas"),
			gl = canvas.getContext("webgl");
			
			if (!gl) {
				
				alert( "The browser supports WebGL, but initialization failed, Visit http://get.webgl.org to verify that your web browser and hardware support WebGL. Consider trying a different web browser or updating your video drivers." )
				
			}else{
				 
				 
				/* 
				var parent = document.querySelector(".switch-lang").getElementsByTagName("li"),
				btnLang = document.querySelector(".btn-lang"),
				warpperLang = document.querySelector(".wrapper-lang"),				
				selectLang = false,
				localLang = localStorage.getItem( "lang");
				
				if( !localLang ){
				
					dot = document.createElement("div");
					
					dot.className = "select"
					
					for( var ii = 0, jj = parent; ii < jj.length ; ii++ ){
						parent[ii].onclick = function( element, index ){
							var divEl = element.getElementsByTagName("div")[0],
							lang = divEl.getAttribute("label");
									
							divEl.appendChild( dot );
							owlData.lang.lang = lang;
							localStorage.setItem( 'lang', lang );
							 	 
							selectLang = true;
							btnLang.className = "btn-lang";
							 
						}.bind({}, parent[ii],  ii )
					}
					
					btnLang.onclick = function(){
								
						if( selectLang ){

							_owlBird.init();
							warpperLang.className = "hidden"
						}
					}
				
				}else{
					warpperLang.className = "hidden"
					owlData.lang.lang = localLang;
					_owlBird.init();
				}
				*/
				
				kongregateAPI && kongregateAPI.loadAPI(function(){
				   window.kongregate = kongregateAPI.getAPI();
				   
       setTimeout(function(){
					    kongregate.stats.submit( "scoresOnGameCompletedHard", 20 );
				   },5000)
				   
				  _owlBird.init();
				});
				
				
			}
		}
		
	}, false );

} )



	

